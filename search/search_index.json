{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MichaelBot Documentation Welcome to MichaelBot's documentation. This documents all the bot's commands along with its features. For general purposes, please refers to the Commands heading. For those who are interested in some of the more secret stuffs, feel free to look at the bot source code. Below are some of the topics that are might not obvious from a user perspective. Prefix vs Slash MichaelBot has 2 main types of command: prefix command and slash command. Prefix command is the OG \"command system\" that's been widely implemented for pretty much every single bot. Slash command is the official command system in Discord that's been implemented fairly recently. MichaelBot tries to balance these 2, but there are some pros and cons to them: Slash > Prefix: Is officially supported by Discord and is super newbie-friendly. Can use Tab to autocomplete. This makes it somewhat unnecessary for the user to remember the arguments. This is excellent when the user need to input some sort of choice into the command. Arguments are generally easier to deal with since Discord do all the necessary text parsing. Prefix commands don't work without verifying the bot after reaching 100 servers. This is technically not the case for slash commands. Prefix > Slash: Is familiar to a lot of people. Can alias commands. This allows users to smash commands super fast. Slash commands have a hard limit of 100 commands per bot. Prefix commands don't have such thing. Slash commands don't have hidden commands; all commands are public. Slash commands' parent can't be invoked ( queue cannot be invoked if a subcommand queue clear is registered). This is not the case for prefix commands. With these pros and cons, sometimes some commands are exclusive to slash or prefix only. This will be mentioned in each command entry. Besides slash commands, Discord also have user commands and message commands . However, the bot rarely uses them for important features, so you can safely ignore them for the most part. By default, I'll recommend you to use the Prefix version of the command. However, in some cases, Slash command might performs the job easier. I'll sometimes put my preferences if that's the case. Cooldown Some commands have cooldown. This is to ensure the bot has time to do things first before it is invoked again. This is quite common for commands that deal with heavy stuffs such as music or communicating with servers. Some cooldown are simply to avoid spamming potential. Cooldown is applied to a certain target. There are 4 targets a cooldown can apply: A user. This means the user can't execute the command within an interval. A channel. This means the command can't be executed in the same channel within an interval. A guild. This means the command can't be executed in the same guild within an interval. Everywhere. This means the command can't be executed by anyone within an interval. Technical: Most cooldown are soft; they can be reset by resetting the bot or use some commands to reset. Some cooldown are hard-coded; they're saved within the database and you might need to edit the table (and the cache) to remove it. Parameters Many commands require parameters to be passed in. Although the help command already provide a good amount of info, it is still limited because it is auto-generated. Note that these are mostly applied to Prefix Commands; Slash Commands is super user-friendly so you might not even need to care about most of these stuffs. Take the command signature foo <bar> [bar2 = bla] [bar3 = 1] [*baz = None] All parameters are separated by space. Which means if you invoke foo 1 2 3 , it'll store as bar = 1, bar2 = 2, bar3 = 3 and not bar = 1 2 3 . <parameter> means this parameter is required. That means bar is a required parameter. [parameter] or [parameter = None] means this parameter is optional. That means bar2 , bar3 , and baz are optional parameters. parameter = sth means the default value of a parameter is set to whatever sth is. This usually appears in optional parameters. *parameter means it'll consume all the remaining text. This means if you invoke foo 1 2 3 4 5 6 , it'll store as bar = 1, bar2 = 2, bar3 = 3, baz = 4 5 6 . Slash Commands have none of the above problem since parameters are separated by Tab, and they also have indication which parameters are required. Parameter Type There are several types the bot will work with. The most common one is plain text, followed by numbers. These are pretty straightforward. The less obvious types are such as a Discord User or a Discord Guild. There are several ways to pass in such types, which will be shown in this table. Type Pass into Prefix Commands Pass into Slash Commands Plain text Literally any text you type. Literally any text you type. Numbers Literally any numbers you type. Literally any numbers you type. Discord User/Member/Channel/Role ID > Mention > Name > Nickname Choose from the option (you might need to partially type the name for it to show up). Discord Guild ID ID Time 1d10h10m10s or hh:mm:ss 1d10h10m10s or hh:mm:ss","title":"Home"},{"location":"#welcome-to-michaelbot-documentation","text":"Welcome to MichaelBot's documentation. This documents all the bot's commands along with its features. For general purposes, please refers to the Commands heading. For those who are interested in some of the more secret stuffs, feel free to look at the bot source code. Below are some of the topics that are might not obvious from a user perspective.","title":"Welcome to MichaelBot Documentation"},{"location":"#prefix-vs-slash","text":"MichaelBot has 2 main types of command: prefix command and slash command. Prefix command is the OG \"command system\" that's been widely implemented for pretty much every single bot. Slash command is the official command system in Discord that's been implemented fairly recently. MichaelBot tries to balance these 2, but there are some pros and cons to them: Slash > Prefix: Is officially supported by Discord and is super newbie-friendly. Can use Tab to autocomplete. This makes it somewhat unnecessary for the user to remember the arguments. This is excellent when the user need to input some sort of choice into the command. Arguments are generally easier to deal with since Discord do all the necessary text parsing. Prefix commands don't work without verifying the bot after reaching 100 servers. This is technically not the case for slash commands. Prefix > Slash: Is familiar to a lot of people. Can alias commands. This allows users to smash commands super fast. Slash commands have a hard limit of 100 commands per bot. Prefix commands don't have such thing. Slash commands don't have hidden commands; all commands are public. Slash commands' parent can't be invoked ( queue cannot be invoked if a subcommand queue clear is registered). This is not the case for prefix commands. With these pros and cons, sometimes some commands are exclusive to slash or prefix only. This will be mentioned in each command entry. Besides slash commands, Discord also have user commands and message commands . However, the bot rarely uses them for important features, so you can safely ignore them for the most part. By default, I'll recommend you to use the Prefix version of the command. However, in some cases, Slash command might performs the job easier. I'll sometimes put my preferences if that's the case.","title":"Prefix vs Slash"},{"location":"#cooldown","text":"Some commands have cooldown. This is to ensure the bot has time to do things first before it is invoked again. This is quite common for commands that deal with heavy stuffs such as music or communicating with servers. Some cooldown are simply to avoid spamming potential. Cooldown is applied to a certain target. There are 4 targets a cooldown can apply: A user. This means the user can't execute the command within an interval. A channel. This means the command can't be executed in the same channel within an interval. A guild. This means the command can't be executed in the same guild within an interval. Everywhere. This means the command can't be executed by anyone within an interval. Technical: Most cooldown are soft; they can be reset by resetting the bot or use some commands to reset. Some cooldown are hard-coded; they're saved within the database and you might need to edit the table (and the cache) to remove it.","title":"Cooldown"},{"location":"#parameters","text":"Many commands require parameters to be passed in. Although the help command already provide a good amount of info, it is still limited because it is auto-generated. Note that these are mostly applied to Prefix Commands; Slash Commands is super user-friendly so you might not even need to care about most of these stuffs. Take the command signature foo <bar> [bar2 = bla] [bar3 = 1] [*baz = None] All parameters are separated by space. Which means if you invoke foo 1 2 3 , it'll store as bar = 1, bar2 = 2, bar3 = 3 and not bar = 1 2 3 . <parameter> means this parameter is required. That means bar is a required parameter. [parameter] or [parameter = None] means this parameter is optional. That means bar2 , bar3 , and baz are optional parameters. parameter = sth means the default value of a parameter is set to whatever sth is. This usually appears in optional parameters. *parameter means it'll consume all the remaining text. This means if you invoke foo 1 2 3 4 5 6 , it'll store as bar = 1, bar2 = 2, bar3 = 3, baz = 4 5 6 . Slash Commands have none of the above problem since parameters are separated by Tab, and they also have indication which parameters are required.","title":"Parameters"},{"location":"#parameter-type","text":"There are several types the bot will work with. The most common one is plain text, followed by numbers. These are pretty straightforward. The less obvious types are such as a Discord User or a Discord Guild. There are several ways to pass in such types, which will be shown in this table. Type Pass into Prefix Commands Pass into Slash Commands Plain text Literally any text you type. Literally any text you type. Numbers Literally any numbers you type. Literally any numbers you type. Discord User/Member/Channel/Role ID > Mention > Name > Nickname Choose from the option (you might need to partially type the name for it to show up). Discord Guild ID ID Time 1d10h10m10s or hh:mm:ss 1d10h10m10s or hh:mm:ss","title":"Parameter Type"},{"location":"INSTALLATION/","text":"Installation All instructions are geared towards Ubuntu (Kubuntu specifically) because that's what I use. Instructions for Windows is available, but be aware I don't test them often. Prerequisites Requires: Python 3.8+ (ideally latest), Git, pip , virtualenv / python3-venv under Python. Optional: Lavalink (more information below), Docker (for Lavalink), PostgreSQL (more information below). About Lavalink Lavalink is optional for the bot. If you don't plan to use the music functionality, you can simply edit main.py the EXTENSION variable to exclude categories.music . Then you can completely ignore this section and move on. Otherwise, you'll need to finish setting up Lavalink and get it running. There are 2 options to host Lavalink: you can host it directly using the .jar file or use Docker. I personally switched to Docker recently so I won't tell which one you should go. In either cases, you'll need a file application.yml to configure the server. An example is provided in ./lib/Lavalink . You'll also need Java 13+, which can be downloaded here or somewhere else (there are a billion places to download a billion java versions I'm not gonna even bother). Running Lavalink (.jar) Download Lavalink.jar , or use the one currently in ./lib/Lavalink/ . Run java -jar <path to Lavalink.jar> . Lavalink server should start running now. By default, it'll run on localhost:2333 unless you configure it in application.yml . Running Lavalink (Docker) This is not tested on Windows. Download Docker. Here is the guide for Ubuntu. Run docker pull fredboat/lavalink:master . This will pull the stable image. Run docker run --name <name> -p <port>:<port> -d -v <path-to-application.yml>:/opt/Lavalink/application.yml fredboat/lavalink:master , where <name> is the name of the process, <port> is the port the server is on, and <path-to-application.yml> is the absolute path to the config file. To stop the process, run docker stop <name> . About PostgreSQL PostgreSQL is optional for the bot, but is strongly recommended. Without a database, some features will be missing, such as prefix config, blacklisting, logging, etc. In addition to that, although the code can handle no database scenario on its own, it is not well-tested for such cases, so there might be some edge cases here and there. This is a pretty fine guide to install PostgreSQL on Ubuntu: https://linuxhint.com/postgresql_installation_guide_ubuntu_20-04/ After installing Postgres, create a database and check the connection info. You'll need this later. Build Instructions The following instructions has been tested with bash and Powershell . You'll need to replace the python command mentioned below with whatever your system has ( python3 or python3.x for Linux, python for Windows). Clone the repository into the current folder. git clone https://github.com/MikeJollie2707/MichaelBot.git . Activate virtual environment and install libraries. # Linux python -m pip venv venv source ./venv/bin/activate python -m pip install -r requirement.txt # Windows # From my experience, / still works, but if it doesn't, use \\ python -m pip venv venv ./venv/Scripts/Activate.ps1 # This is important; uvloop is not available on Windows. python -m pip install -r win_requirement.txt Configure the bot. Inside ./setup , create a .json file. I'll call it secret.json . // secret.json { \"token\": \"Bot token here\", \"host\": \"localhost\", \"port\": 5432, \"database\": \"database name\", \"user\": \"user name\", \"password\": \"password\", \"weather_api_key\": \"api key\" } If you don't have a database and/or weather_api_key , leave them as dummy values ( \"\" and 0 ). Within ./setup , there's also another file called config.json . The file has the following structure: // config.json { \"BotIndex\": { \"version\": \"Required\", \"description\": \"Required\", \"prefix\": \"Required\", \"launch_options\": \"Optional\", \"default_guilds\": [123456], \"secret\": \"secret.json\" } } BotIndex : the index you'll refer to the bot when you launch it from the terminal. Usually the bot name without space. version : the bot version. Just fake something up like 69.69beta if you don't really care about this. description : the bot's about me. Discord doesn't have a way to retrieve this so this is required for now. prefix : the bot's default prefix. launch_options : an optional string to pass into the bot when it launches. This mostly affects terminal logging. Acceptable options are: -d or --debug : Launch the bot in debug mode. This will set the log level to DEBUG but more importantly, it'll apply slash commands to default_guilds immediately (no need to wait at most 1 hour). If this is passed, default_guilds must also be non-empty. -q or --quiet : Launch the bot in quiet mode. This will disable terminal logging, but any uncaught exceptions will still spawn in stderr . default_guilds : a list of guilds' ids to apply slash commands immediately. This is required if the bot is launched in debug mode. secret : the file name that contains your bot's secret like token. You can view my bot config as an example. (Optional) If you have a database, you'll need to set up the tables beforehand. You only need to do this once. python dbsetup.py BotIndex Run the bot. python -OO main.py BotIndex What's next? For personal convenience, I also have a template script to run the bot in different modes. You can check it out at run.sh (Kubuntu) or run.ps1 (Windows). It'll only run the bot. You'll need to run Lavalink and PostgreSQL on your own.","title":"Installation"},{"location":"INSTALLATION/#installation","text":"All instructions are geared towards Ubuntu (Kubuntu specifically) because that's what I use. Instructions for Windows is available, but be aware I don't test them often.","title":"Installation"},{"location":"INSTALLATION/#prerequisites","text":"Requires: Python 3.8+ (ideally latest), Git, pip , virtualenv / python3-venv under Python. Optional: Lavalink (more information below), Docker (for Lavalink), PostgreSQL (more information below).","title":"Prerequisites"},{"location":"INSTALLATION/#about-lavalink","text":"Lavalink is optional for the bot. If you don't plan to use the music functionality, you can simply edit main.py the EXTENSION variable to exclude categories.music . Then you can completely ignore this section and move on. Otherwise, you'll need to finish setting up Lavalink and get it running. There are 2 options to host Lavalink: you can host it directly using the .jar file or use Docker. I personally switched to Docker recently so I won't tell which one you should go. In either cases, you'll need a file application.yml to configure the server. An example is provided in ./lib/Lavalink . You'll also need Java 13+, which can be downloaded here or somewhere else (there are a billion places to download a billion java versions I'm not gonna even bother).","title":"About Lavalink"},{"location":"INSTALLATION/#running-lavalink-jar","text":"Download Lavalink.jar , or use the one currently in ./lib/Lavalink/ . Run java -jar <path to Lavalink.jar> . Lavalink server should start running now. By default, it'll run on localhost:2333 unless you configure it in application.yml .","title":"Running Lavalink (.jar)"},{"location":"INSTALLATION/#running-lavalink-docker","text":"This is not tested on Windows. Download Docker. Here is the guide for Ubuntu. Run docker pull fredboat/lavalink:master . This will pull the stable image. Run docker run --name <name> -p <port>:<port> -d -v <path-to-application.yml>:/opt/Lavalink/application.yml fredboat/lavalink:master , where <name> is the name of the process, <port> is the port the server is on, and <path-to-application.yml> is the absolute path to the config file. To stop the process, run docker stop <name> .","title":"Running Lavalink (Docker)"},{"location":"INSTALLATION/#about-postgresql","text":"PostgreSQL is optional for the bot, but is strongly recommended. Without a database, some features will be missing, such as prefix config, blacklisting, logging, etc. In addition to that, although the code can handle no database scenario on its own, it is not well-tested for such cases, so there might be some edge cases here and there. This is a pretty fine guide to install PostgreSQL on Ubuntu: https://linuxhint.com/postgresql_installation_guide_ubuntu_20-04/ After installing Postgres, create a database and check the connection info. You'll need this later.","title":"About PostgreSQL"},{"location":"INSTALLATION/#build-instructions","text":"The following instructions has been tested with bash and Powershell . You'll need to replace the python command mentioned below with whatever your system has ( python3 or python3.x for Linux, python for Windows). Clone the repository into the current folder. git clone https://github.com/MikeJollie2707/MichaelBot.git . Activate virtual environment and install libraries. # Linux python -m pip venv venv source ./venv/bin/activate python -m pip install -r requirement.txt # Windows # From my experience, / still works, but if it doesn't, use \\ python -m pip venv venv ./venv/Scripts/Activate.ps1 # This is important; uvloop is not available on Windows. python -m pip install -r win_requirement.txt Configure the bot. Inside ./setup , create a .json file. I'll call it secret.json . // secret.json { \"token\": \"Bot token here\", \"host\": \"localhost\", \"port\": 5432, \"database\": \"database name\", \"user\": \"user name\", \"password\": \"password\", \"weather_api_key\": \"api key\" } If you don't have a database and/or weather_api_key , leave them as dummy values ( \"\" and 0 ). Within ./setup , there's also another file called config.json . The file has the following structure: // config.json { \"BotIndex\": { \"version\": \"Required\", \"description\": \"Required\", \"prefix\": \"Required\", \"launch_options\": \"Optional\", \"default_guilds\": [123456], \"secret\": \"secret.json\" } } BotIndex : the index you'll refer to the bot when you launch it from the terminal. Usually the bot name without space. version : the bot version. Just fake something up like 69.69beta if you don't really care about this. description : the bot's about me. Discord doesn't have a way to retrieve this so this is required for now. prefix : the bot's default prefix. launch_options : an optional string to pass into the bot when it launches. This mostly affects terminal logging. Acceptable options are: -d or --debug : Launch the bot in debug mode. This will set the log level to DEBUG but more importantly, it'll apply slash commands to default_guilds immediately (no need to wait at most 1 hour). If this is passed, default_guilds must also be non-empty. -q or --quiet : Launch the bot in quiet mode. This will disable terminal logging, but any uncaught exceptions will still spawn in stderr . default_guilds : a list of guilds' ids to apply slash commands immediately. This is required if the bot is launched in debug mode. secret : the file name that contains your bot's secret like token. You can view my bot config as an example. (Optional) If you have a database, you'll need to set up the tables beforehand. You only need to do this once. python dbsetup.py BotIndex Run the bot. python -OO main.py BotIndex","title":"Build Instructions"},{"location":"INSTALLATION/#whats-next","text":"For personal convenience, I also have a template script to run the bot in different modes. You can check it out at run.sh (Kubuntu) or run.ps1 (Windows). It'll only run the bot. You'll need to run Lavalink and PostgreSQL on your own.","title":"What's next?"},{"location":"dev/errors/","text":"Custom exceptions (errors) to handle in global error handler. CustomAPIFailed Bases: hikari . HTTPError Exception raised when a third-party API call failed (not status 200). CustomCheckFailed Bases: lightbulb . CheckFailure Exception raised when a custom check (not lightbulb check) failed. NoDatabase Bases: CustomCheckFailed Exception raised when the bot doesn't have a database connection pool. NoHTTPClient Bases: CustomCheckFailed Exception raised when the bot doesn't have a http client. GuildDisabled Bases: CustomCheckFailed Exception raised when the guild disable the command. GuildBlacklisted Bases: CustomCheckFailed Exception raised when the guild is blacklisted by the bot's owner. UserBlacklisted Bases: CustomCheckFailed Exception raised when the user is blacklisted by the bot's owner.","title":"errors.py"},{"location":"dev/errors/#utils.errors.CustomAPIFailed","text":"Bases: hikari . HTTPError Exception raised when a third-party API call failed (not status 200).","title":"CustomAPIFailed"},{"location":"dev/errors/#utils.errors.CustomCheckFailed","text":"Bases: lightbulb . CheckFailure Exception raised when a custom check (not lightbulb check) failed.","title":"CustomCheckFailed"},{"location":"dev/errors/#utils.errors.NoDatabase","text":"Bases: CustomCheckFailed Exception raised when the bot doesn't have a database connection pool.","title":"NoDatabase"},{"location":"dev/errors/#utils.errors.NoHTTPClient","text":"Bases: CustomCheckFailed Exception raised when the bot doesn't have a http client.","title":"NoHTTPClient"},{"location":"dev/errors/#utils.errors.GuildDisabled","text":"Bases: CustomCheckFailed Exception raised when the guild disable the command.","title":"GuildDisabled"},{"location":"dev/errors/#utils.errors.GuildBlacklisted","text":"Bases: CustomCheckFailed Exception raised when the guild is blacklisted by the bot's owner.","title":"GuildBlacklisted"},{"location":"dev/errors/#utils.errors.UserBlacklisted","text":"Bases: CustomCheckFailed Exception raised when the user is blacklisted by the bot's owner.","title":"UserBlacklisted"},{"location":"dev/funtext/","text":"Contains funny text manipulations. pekofy ( / , text : str ) -> str A simple implementation of pekofy which simply adds peko at the end of a sentence. Parameters: Name Type Description Default text str The text to transform. required Returns: Type Description str The pekofy text. Source code in utils\\funtext.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def pekofy ( text : str , / ) -> str : '''A simple implementation of `pekofy` which simply adds `peko` at the end of a sentence. Parameters ---------- text : str The text to transform. Returns ------- str The pekofy text. ''' words = text . split () for index , word in enumerate ( words ): for punc in [ '.' , '!' , '?' ]: if word . endswith ( punc ): words [ index ] = words [ index ][: - 1 ] + f \" peko { punc } \" if word == words [ - 1 ]: words [ index ] += \" peko\" return ' ' . join ( words ) uwuify ( / , text : str , * , allow_nyvowels = True , stutter_chance : float = 0.2 , emote_chance : float = 0.8 , action_chance : float = 0.05 ) -> str Transform a text into uwu text. Parameters: Name Type Description Default text str The text to transform. required allow_nyvowels bool , optional Whether or not to transform na , no , etc. into nya , nyo , etc. Default to True . True stutter_chance float , optional The chance to stutter a word. Must be [0, 1] . Default to 0.20 . 0.2 emote_chance float , optional The chance to put an emote after a punctuation like , or . Must be [0, 1] . Default to 0.8 . 0.8 action_chance float , optional The chance to put an action string after a word. Must be [0, 1] . Default to 0.05 . 0.05 Returns: Type Description str The uwu text. Source code in utils\\funtext.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def uwuify ( text : str , / , * , allow_nyvowels = True , stutter_chance : float = 0.20 , emote_chance : float = 0.8 , action_chance : float = 0.05 ) -> str : '''Transform a text into uwu text. Parameters ---------- text : str The text to transform. allow_nyvowels : bool, optional Whether or not to transform `na`, `no`, etc. into `nya`, `nyo`, etc. Default to `True`. stutter_chance : float, optional The chance to stutter a word. Must be `[0, 1]`. Default to `0.20`. emote_chance : float, optional The chance to put an emote after a punctuation like `,` or `.` Must be `[0, 1]`. Default to `0.8`. action_chance : float, optional The chance to put an action string after a word. Must be `[0, 1]`. Default to `0.05`. Returns ------- str The uwu text. ''' words = text . split () for index , word in enumerate ( words ): words [ index ] = words [ index ] . replace ( 'l' , 'w' ) words [ index ] = words [ index ] . replace ( 'L' , 'W' ) words [ index ] = words [ index ] . replace ( 'r' , 'w' ) words [ index ] = words [ index ] . replace ( 'R' , 'W' ) if allow_nyvowels : words [ index ] = words [ index ] . replace ( \"na\" , \"nya\" ) words [ index ] = words [ index ] . replace ( \"Na\" , \"Nya\" ) words [ index ] = words [ index ] . replace ( \"NA\" , \"NyA\" ) words [ index ] = words [ index ] . replace ( \"ne\" , \"nye\" ) words [ index ] = words [ index ] . replace ( \"Ne\" , \"Nye\" ) words [ index ] = words [ index ] . replace ( \"NE\" , \"NyE\" ) words [ index ] = words [ index ] . replace ( \"no\" , \"nyo\" ) words [ index ] = words [ index ] . replace ( \"No\" , \"Nyo\" ) words [ index ] = words [ index ] . replace ( \"NO\" , \"NyO\" ) words [ index ] = words [ index ] . replace ( \"nu\" , \"yu\" ) words [ index ] = words [ index ] . replace ( \"Nu\" , \"Nyu\" ) words [ index ] = words [ index ] . replace ( \"NU\" , \"NyU\" ) if word in __REPLACE_WORDS : words [ index ] = __REPLACE_WORDS [ word ] is_stutter = random . random () if is_stutter <= stutter_chance : words [ index ] = f \" { words [ index ][ 0 ] } - { words [ index ] } \" is_emote = random . random () if is_emote <= emote_chance and words [ index ] . endswith (( '.' , '?' , '!' , ',' )): words [ index ] += random . choice ( __RANDOM_EMOTES ) is_action = random . random () if is_action <= action_chance : words [ index ] += random . choice ( __RANDOM_ACTIONS ) return ' ' . join ( words )","title":"funtext.py"},{"location":"dev/funtext/#utils.funtext.pekofy","text":"A simple implementation of pekofy which simply adds peko at the end of a sentence. Parameters: Name Type Description Default text str The text to transform. required Returns: Type Description str The pekofy text. Source code in utils\\funtext.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def pekofy ( text : str , / ) -> str : '''A simple implementation of `pekofy` which simply adds `peko` at the end of a sentence. Parameters ---------- text : str The text to transform. Returns ------- str The pekofy text. ''' words = text . split () for index , word in enumerate ( words ): for punc in [ '.' , '!' , '?' ]: if word . endswith ( punc ): words [ index ] = words [ index ][: - 1 ] + f \" peko { punc } \" if word == words [ - 1 ]: words [ index ] += \" peko\" return ' ' . join ( words )","title":"pekofy()"},{"location":"dev/funtext/#utils.funtext.uwuify","text":"Transform a text into uwu text. Parameters: Name Type Description Default text str The text to transform. required allow_nyvowels bool , optional Whether or not to transform na , no , etc. into nya , nyo , etc. Default to True . True stutter_chance float , optional The chance to stutter a word. Must be [0, 1] . Default to 0.20 . 0.2 emote_chance float , optional The chance to put an emote after a punctuation like , or . Must be [0, 1] . Default to 0.8 . 0.8 action_chance float , optional The chance to put an action string after a word. Must be [0, 1] . Default to 0.05 . 0.05 Returns: Type Description str The uwu text. Source code in utils\\funtext.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def uwuify ( text : str , / , * , allow_nyvowels = True , stutter_chance : float = 0.20 , emote_chance : float = 0.8 , action_chance : float = 0.05 ) -> str : '''Transform a text into uwu text. Parameters ---------- text : str The text to transform. allow_nyvowels : bool, optional Whether or not to transform `na`, `no`, etc. into `nya`, `nyo`, etc. Default to `True`. stutter_chance : float, optional The chance to stutter a word. Must be `[0, 1]`. Default to `0.20`. emote_chance : float, optional The chance to put an emote after a punctuation like `,` or `.` Must be `[0, 1]`. Default to `0.8`. action_chance : float, optional The chance to put an action string after a word. Must be `[0, 1]`. Default to `0.05`. Returns ------- str The uwu text. ''' words = text . split () for index , word in enumerate ( words ): words [ index ] = words [ index ] . replace ( 'l' , 'w' ) words [ index ] = words [ index ] . replace ( 'L' , 'W' ) words [ index ] = words [ index ] . replace ( 'r' , 'w' ) words [ index ] = words [ index ] . replace ( 'R' , 'W' ) if allow_nyvowels : words [ index ] = words [ index ] . replace ( \"na\" , \"nya\" ) words [ index ] = words [ index ] . replace ( \"Na\" , \"Nya\" ) words [ index ] = words [ index ] . replace ( \"NA\" , \"NyA\" ) words [ index ] = words [ index ] . replace ( \"ne\" , \"nye\" ) words [ index ] = words [ index ] . replace ( \"Ne\" , \"Nye\" ) words [ index ] = words [ index ] . replace ( \"NE\" , \"NyE\" ) words [ index ] = words [ index ] . replace ( \"no\" , \"nyo\" ) words [ index ] = words [ index ] . replace ( \"No\" , \"Nyo\" ) words [ index ] = words [ index ] . replace ( \"NO\" , \"NyO\" ) words [ index ] = words [ index ] . replace ( \"nu\" , \"yu\" ) words [ index ] = words [ index ] . replace ( \"Nu\" , \"Nyu\" ) words [ index ] = words [ index ] . replace ( \"NU\" , \"NyU\" ) if word in __REPLACE_WORDS : words [ index ] = __REPLACE_WORDS [ word ] is_stutter = random . random () if is_stutter <= stutter_chance : words [ index ] = f \" { words [ index ][ 0 ] } - { words [ index ] } \" is_emote = random . random () if is_emote <= emote_chance and words [ index ] . endswith (( '.' , '?' , '!' , ',' )): words [ index ] += random . choice ( __RANDOM_EMOTES ) is_action = random . random () if is_action <= action_chance : words [ index ] += random . choice ( __RANDOM_ACTIONS ) return ' ' . join ( words )","title":"uwuify()"},{"location":"dev/help/","text":"Define the behavior of the 'help' command for the bot. Includes help-specific utilities. MenuLikeHelp Bases: lightbulb . DefaultHelpCommand A custom help command that's tailored for MichaelBot . Source code in categories\\help.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 class MenuLikeHelp ( lightbulb . DefaultHelpCommand ): ''' A custom help command that's tailored for `MichaelBot`. ''' async def send_help ( self , ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None : ''' The main logic for the help command. ''' bot : models . MichaelBot = self . bot # Reference: https://github.com/tandemdude/hikari-lightbulb/blob/development/lightbulb/help_command.py#L100 if obj is None : await self . send_bot_help ( ctx ) return # Prioritize searching command based on context. if isinstance ( ctx , lightbulb . PrefixContext ): cmd = bot . get_prefix_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . PrefixCommandGroup , lightbulb . PrefixSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) if isinstance ( ctx , lightbulb . SlashContext ): cmd = bot . get_slash_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) # We don't have user/message commands yet. await super () . send_help ( ctx , obj ) async def send_bot_help ( self , ctx : lightbulb . Context ) -> None : ''' Send a generic help message. ''' if isinstance ( ctx , lightbulb . PrefixContext ): await ctx . event . message . delete () main_page = helpers . get_default_embed ( title = \"Help\" , description = \"\" , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) plugins = ctx . bot . plugins # {plugin_name: command_count} plugin_info : dict [ str , int ] = {} for plugin in plugins . values (): public_commands = [] if isinstance ( ctx , lightbulb . PrefixContext ): public_commands = filter_command_type ( plugin . all_commands , __PREFIX_COMMAND_TYPES__ , True ) else : public_commands = filter_command_type ( plugin . all_commands , __SLASH_COMMAND_TYPES__ , True ) public_commands_len = len ( public_commands ) if public_commands_len > 0 : embed_name = f \" { plugin . d . emote } { plugin . name } ( { public_commands_len } commands)\" embed_description = \"*No description provided*\" if bool ( plugin . description ): embed_description = plugin . description main_page . add_field ( name = embed_name , value = embed_description , inline = False ) plugin_info [ plugin . name ] = public_commands_len menu_root = menu . MenuComponent ( main_page ) for name in plugin_info : menu_root . add_list_options ( menu . MenuButton ( label = name , emoji = plugins [ name ] . d . emote , ), plugin_help_format ( ctx , plugins [ name ]) ) await menu . ComplexView ( menu_root ) . run ( ctx ) async def send_plugin_help ( self , ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None : ''' Send a plugin help that contains all commands. ''' embeds = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ public_commands = filter_command_type ( plugin . all_commands , types , True ) for command in sorted ( public_commands , key = lambda cmd : cmd . name ): page = command_help_format ( ctx , command ) if page is not None : embeds . append ( page ) await navigator . ButtonNavigator ( pages = embeds ) . send ( ctx . channel_id ) async def send_command_help ( self , ctx : lightbulb . Context , command : lightbulb . Command ) -> None : ''' Send a command help. ''' await ctx . respond ( embed = command_help_format ( ctx , command )) async def send_group_help ( self , ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None : ''' Send a group help. Internally, this does the same as `send_command_help()`. ''' await ctx . respond ( embed = command_help_format ( ctx , group )) send_help ( ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None async The main logic for the help command. Source code in categories\\help.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 async def send_help ( self , ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None : ''' The main logic for the help command. ''' bot : models . MichaelBot = self . bot # Reference: https://github.com/tandemdude/hikari-lightbulb/blob/development/lightbulb/help_command.py#L100 if obj is None : await self . send_bot_help ( ctx ) return # Prioritize searching command based on context. if isinstance ( ctx , lightbulb . PrefixContext ): cmd = bot . get_prefix_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . PrefixCommandGroup , lightbulb . PrefixSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) if isinstance ( ctx , lightbulb . SlashContext ): cmd = bot . get_slash_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) # We don't have user/message commands yet. await super () . send_help ( ctx , obj ) send_bot_help ( ctx : lightbulb . Context ) -> None async Send a generic help message. Source code in categories\\help.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 async def send_bot_help ( self , ctx : lightbulb . Context ) -> None : ''' Send a generic help message. ''' if isinstance ( ctx , lightbulb . PrefixContext ): await ctx . event . message . delete () main_page = helpers . get_default_embed ( title = \"Help\" , description = \"\" , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) plugins = ctx . bot . plugins # {plugin_name: command_count} plugin_info : dict [ str , int ] = {} for plugin in plugins . values (): public_commands = [] if isinstance ( ctx , lightbulb . PrefixContext ): public_commands = filter_command_type ( plugin . all_commands , __PREFIX_COMMAND_TYPES__ , True ) else : public_commands = filter_command_type ( plugin . all_commands , __SLASH_COMMAND_TYPES__ , True ) public_commands_len = len ( public_commands ) if public_commands_len > 0 : embed_name = f \" { plugin . d . emote } { plugin . name } ( { public_commands_len } commands)\" embed_description = \"*No description provided*\" if bool ( plugin . description ): embed_description = plugin . description main_page . add_field ( name = embed_name , value = embed_description , inline = False ) plugin_info [ plugin . name ] = public_commands_len menu_root = menu . MenuComponent ( main_page ) for name in plugin_info : menu_root . add_list_options ( menu . MenuButton ( label = name , emoji = plugins [ name ] . d . emote , ), plugin_help_format ( ctx , plugins [ name ]) ) await menu . ComplexView ( menu_root ) . run ( ctx ) send_plugin_help ( ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None async Send a plugin help that contains all commands. Source code in categories\\help.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 async def send_plugin_help ( self , ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None : ''' Send a plugin help that contains all commands. ''' embeds = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ public_commands = filter_command_type ( plugin . all_commands , types , True ) for command in sorted ( public_commands , key = lambda cmd : cmd . name ): page = command_help_format ( ctx , command ) if page is not None : embeds . append ( page ) await navigator . ButtonNavigator ( pages = embeds ) . send ( ctx . channel_id ) send_command_help ( ctx : lightbulb . Context , command : lightbulb . Command ) -> None async Send a command help. Source code in categories\\help.py 317 318 319 320 321 async def send_command_help ( self , ctx : lightbulb . Context , command : lightbulb . Command ) -> None : ''' Send a command help. ''' await ctx . respond ( embed = command_help_format ( ctx , command )) send_group_help ( ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None async Send a group help. Internally, this does the same as send_command_help() . Source code in categories\\help.py 322 323 324 325 326 327 328 async def send_group_help ( self , ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None : ''' Send a group help. Internally, this does the same as `send_command_help()`. ''' await ctx . respond ( embed = command_help_format ( ctx , group )) filter_command_type ( commands : t . Sequence [ lightbulb . Command ], types : t . Sequence [ t . Type ], remove_hidden : bool = False ) -> t . List [ lightbulb . Command ] Filter commands with one of the type mentioned in types . Parameters: Name Type Description Default commands t . Sequence [ lightbulb . Command ] A sequence of commands. required types t . Sequence [ t . Type ] A sequence of command's types to filter. Example: (lightbulb.PrefixCommand, lightbulb.SlashCommand) . required remove_hidden bool , optional Whether or not to remove hidden commands. Default to False . False Returns: Type Description t . List [ lightbulb . Command ] A list of commands filtered out by types. Source code in categories\\help.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def filter_command_type ( commands : t . Sequence [ lightbulb . Command ], types : t . Sequence [ t . Type ], remove_hidden : bool = False ) -> t . List [ lightbulb . Command ]: '''Filter commands with one of the type mentioned in `types`. Parameters ---------- commands : t.Sequence[lightbulb.Command] A sequence of commands. types : t.Sequence[t.Type] A sequence of command's types to filter. Example: `(lightbulb.PrefixCommand, lightbulb.SlashCommand)`. remove_hidden : bool, optional Whether or not to remove hidden commands. Default to `False`. Returns ------- t.List[lightbulb.Command] A list of commands filtered out by types. ''' l = [] for command in commands : if isinstance ( command , types ): if ( not remove_hidden ) or ( remove_hidden and not command . hidden ): l . append ( command ) return l plugin_help_format ( ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> t . List [ hikari . Embed ] Return a list of formatted embed for a plugin help. This list can be passed into a paginator to display. Parameters: Name Type Description Default ctx lightbulb . Context The context. required plugin lightbulb . Plugin The plugin to display the help. required Returns: Type Description t . List [ hikari . Embed ] A list of formatted embed for a plugin help. Source code in categories\\help.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def plugin_help_format ( ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> t . List [ hikari . Embed ]: '''Return a list of formatted embed for a plugin help. This list can be passed into a paginator to display. Parameters ---------- ctx : lightbulb.Context The context. plugin : lightbulb.Plugin The plugin to display the help. Returns ------- t.List[hikari.Embed] A list of formatted embed for a plugin help. ''' MAX_COMMANDS = 10 display = \"\" plugins = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ commands : t . List [ lightbulb . Command ] = filter_command_type ( plugin . all_commands , types , True ) commands . sort ( key = lambda command : command . name ) for index , command in enumerate ( commands ): # Signature includes command name. command_title = command . signature . replace ( '=' , ' = ' ) display += f \"** { command_title } :** \\n \" description = command . description if not description : description = \"*No help provided*\" display += f \"- { description } \\n\\n \" if index == MAX_COMMANDS - 1 or index == len ( commands ) - 1 : title = f \" { plugin . name } ( { len ( commands ) } commands):\" embed = helpers . get_default_embed ( title = title , description = display , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) . set_thumbnail ( ctx . bot . get_me () . avatar_url ) plugins . append ( embed ) display = \"\" return plugins command_help_format ( ctx : lightbulb . Context , command : lightbulb . Command ) -> hikari . Embed Return a formatted embed for a command help. Notes For command group, the embed will also include all subcommands. Parameters: Name Type Description Default ctx lightbulb . Context The context. required command lightbulb . Command The command to display the help. Can also be a command group/subcommand/... required Returns: Type Description hikari . Embed The formatted embed for a command help. Source code in categories\\help.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def command_help_format ( ctx : lightbulb . Context , command : lightbulb . Command ) -> hikari . Embed : '''Return a formatted embed for a command help. Notes ----- For command group, the embed will also include all subcommands. Parameters ---------- ctx : lightbulb.Context The context. command : lightbulb.Command The command to display the help. Can also be a command group/subcommand/... Returns ------- hikari.Embed The formatted embed for a command help. ''' bot : models . MichaelBot = ctx . bot # Signature includes full command name. embed_title = command . signature . replace ( '=' , ' = ' ) embed_description = \"*No help provided*\" if command . description != \"\" : embed_description = command . description + ' \\n ' embed = helpers . get_default_embed ( title = embed_title , description = embed_description , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) command_type = [] p_cmd = bot . get_prefix_command ( command . qualname ) s_cmd = bot . get_slash_command ( command . qualname ) m_cmd = bot . get_message_command ( command . qualname ) u_cmd = bot . get_user_command ( command . qualname ) if p_cmd is not None : command_type . append ( \"`Prefix Command`\" ) if s_cmd is not None and not isinstance ( s_cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): command_type . append ( \"`Slash Command`\" ) if m_cmd is not None : command_type . append ( \"`Message Command`\" ) if u_cmd is not None : command_type . append ( \"`User Command`\" ) embed . add_field ( name = \"Type\" , value = ' ' . join ( command_type ) ) if len ( command . options ) > 0 : option_field = \"\" for option in command . options . values (): option_field += f \"- ` { option . name } `: { option . description } \\n \" embed . add_field ( name = \"Parameters\" , value = option_field ) if len ( command . aliases ) > 0 and isinstance ( command , __PREFIX_COMMAND_TYPES__ ): embed . add_field ( name = \"Aliases (Prefix Command only)\" , value = \"- \" + ', ' . join ( f \"` { alias } `\" for alias in command . aliases ) ) if bool ( command . get_help ( ctx )): embed . add_field ( name = \"Note\" , value = dedent ( command . get_help ( ctx )) ) if isinstance ( command , __COMMAND_GROUPS_TYPES__ ): field_value = \"\" subcommands = command . subcommands . values () types = __PREFIX_COMMAND_TYPES__ # Can't check with ctx, since SlashContext can call a PrefixCommandGroup. if isinstance ( command , __SLASH_COMMAND_TYPES__ ): types = __SLASH_COMMAND_TYPES__ for subcommand in sorted ( filter_command_type ( subcommands , types , True ), key = lambda cmd : cmd . name ): field_value += f \"- ` { subcommand . name } `: { subcommand . description } \\n \" if len ( command . subcommands ) > 0 : embed . add_field ( name = \"**Subcommands:**\" , value = field_value , inline = False ) return embed","title":"help.py"},{"location":"dev/help/#categories.help.MenuLikeHelp","text":"Bases: lightbulb . DefaultHelpCommand A custom help command that's tailored for MichaelBot . Source code in categories\\help.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 class MenuLikeHelp ( lightbulb . DefaultHelpCommand ): ''' A custom help command that's tailored for `MichaelBot`. ''' async def send_help ( self , ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None : ''' The main logic for the help command. ''' bot : models . MichaelBot = self . bot # Reference: https://github.com/tandemdude/hikari-lightbulb/blob/development/lightbulb/help_command.py#L100 if obj is None : await self . send_bot_help ( ctx ) return # Prioritize searching command based on context. if isinstance ( ctx , lightbulb . PrefixContext ): cmd = bot . get_prefix_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . PrefixCommandGroup , lightbulb . PrefixSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) if isinstance ( ctx , lightbulb . SlashContext ): cmd = bot . get_slash_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) # We don't have user/message commands yet. await super () . send_help ( ctx , obj ) async def send_bot_help ( self , ctx : lightbulb . Context ) -> None : ''' Send a generic help message. ''' if isinstance ( ctx , lightbulb . PrefixContext ): await ctx . event . message . delete () main_page = helpers . get_default_embed ( title = \"Help\" , description = \"\" , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) plugins = ctx . bot . plugins # {plugin_name: command_count} plugin_info : dict [ str , int ] = {} for plugin in plugins . values (): public_commands = [] if isinstance ( ctx , lightbulb . PrefixContext ): public_commands = filter_command_type ( plugin . all_commands , __PREFIX_COMMAND_TYPES__ , True ) else : public_commands = filter_command_type ( plugin . all_commands , __SLASH_COMMAND_TYPES__ , True ) public_commands_len = len ( public_commands ) if public_commands_len > 0 : embed_name = f \" { plugin . d . emote } { plugin . name } ( { public_commands_len } commands)\" embed_description = \"*No description provided*\" if bool ( plugin . description ): embed_description = plugin . description main_page . add_field ( name = embed_name , value = embed_description , inline = False ) plugin_info [ plugin . name ] = public_commands_len menu_root = menu . MenuComponent ( main_page ) for name in plugin_info : menu_root . add_list_options ( menu . MenuButton ( label = name , emoji = plugins [ name ] . d . emote , ), plugin_help_format ( ctx , plugins [ name ]) ) await menu . ComplexView ( menu_root ) . run ( ctx ) async def send_plugin_help ( self , ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None : ''' Send a plugin help that contains all commands. ''' embeds = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ public_commands = filter_command_type ( plugin . all_commands , types , True ) for command in sorted ( public_commands , key = lambda cmd : cmd . name ): page = command_help_format ( ctx , command ) if page is not None : embeds . append ( page ) await navigator . ButtonNavigator ( pages = embeds ) . send ( ctx . channel_id ) async def send_command_help ( self , ctx : lightbulb . Context , command : lightbulb . Command ) -> None : ''' Send a command help. ''' await ctx . respond ( embed = command_help_format ( ctx , command )) async def send_group_help ( self , ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None : ''' Send a group help. Internally, this does the same as `send_command_help()`. ''' await ctx . respond ( embed = command_help_format ( ctx , group ))","title":"MenuLikeHelp"},{"location":"dev/help/#categories.help.MenuLikeHelp.send_help","text":"The main logic for the help command. Source code in categories\\help.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 async def send_help ( self , ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None : ''' The main logic for the help command. ''' bot : models . MichaelBot = self . bot # Reference: https://github.com/tandemdude/hikari-lightbulb/blob/development/lightbulb/help_command.py#L100 if obj is None : await self . send_bot_help ( ctx ) return # Prioritize searching command based on context. if isinstance ( ctx , lightbulb . PrefixContext ): cmd = bot . get_prefix_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . PrefixCommandGroup , lightbulb . PrefixSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) if isinstance ( ctx , lightbulb . SlashContext ): cmd = bot . get_slash_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) # We don't have user/message commands yet. await super () . send_help ( ctx , obj )","title":"send_help()"},{"location":"dev/help/#categories.help.MenuLikeHelp.send_bot_help","text":"Send a generic help message. Source code in categories\\help.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 async def send_bot_help ( self , ctx : lightbulb . Context ) -> None : ''' Send a generic help message. ''' if isinstance ( ctx , lightbulb . PrefixContext ): await ctx . event . message . delete () main_page = helpers . get_default_embed ( title = \"Help\" , description = \"\" , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) plugins = ctx . bot . plugins # {plugin_name: command_count} plugin_info : dict [ str , int ] = {} for plugin in plugins . values (): public_commands = [] if isinstance ( ctx , lightbulb . PrefixContext ): public_commands = filter_command_type ( plugin . all_commands , __PREFIX_COMMAND_TYPES__ , True ) else : public_commands = filter_command_type ( plugin . all_commands , __SLASH_COMMAND_TYPES__ , True ) public_commands_len = len ( public_commands ) if public_commands_len > 0 : embed_name = f \" { plugin . d . emote } { plugin . name } ( { public_commands_len } commands)\" embed_description = \"*No description provided*\" if bool ( plugin . description ): embed_description = plugin . description main_page . add_field ( name = embed_name , value = embed_description , inline = False ) plugin_info [ plugin . name ] = public_commands_len menu_root = menu . MenuComponent ( main_page ) for name in plugin_info : menu_root . add_list_options ( menu . MenuButton ( label = name , emoji = plugins [ name ] . d . emote , ), plugin_help_format ( ctx , plugins [ name ]) ) await menu . ComplexView ( menu_root ) . run ( ctx )","title":"send_bot_help()"},{"location":"dev/help/#categories.help.MenuLikeHelp.send_plugin_help","text":"Send a plugin help that contains all commands. Source code in categories\\help.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 async def send_plugin_help ( self , ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None : ''' Send a plugin help that contains all commands. ''' embeds = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ public_commands = filter_command_type ( plugin . all_commands , types , True ) for command in sorted ( public_commands , key = lambda cmd : cmd . name ): page = command_help_format ( ctx , command ) if page is not None : embeds . append ( page ) await navigator . ButtonNavigator ( pages = embeds ) . send ( ctx . channel_id )","title":"send_plugin_help()"},{"location":"dev/help/#categories.help.MenuLikeHelp.send_command_help","text":"Send a command help. Source code in categories\\help.py 317 318 319 320 321 async def send_command_help ( self , ctx : lightbulb . Context , command : lightbulb . Command ) -> None : ''' Send a command help. ''' await ctx . respond ( embed = command_help_format ( ctx , command ))","title":"send_command_help()"},{"location":"dev/help/#categories.help.MenuLikeHelp.send_group_help","text":"Send a group help. Internally, this does the same as send_command_help() . Source code in categories\\help.py 322 323 324 325 326 327 328 async def send_group_help ( self , ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None : ''' Send a group help. Internally, this does the same as `send_command_help()`. ''' await ctx . respond ( embed = command_help_format ( ctx , group ))","title":"send_group_help()"},{"location":"dev/help/#categories.help.filter_command_type","text":"Filter commands with one of the type mentioned in types . Parameters: Name Type Description Default commands t . Sequence [ lightbulb . Command ] A sequence of commands. required types t . Sequence [ t . Type ] A sequence of command's types to filter. Example: (lightbulb.PrefixCommand, lightbulb.SlashCommand) . required remove_hidden bool , optional Whether or not to remove hidden commands. Default to False . False Returns: Type Description t . List [ lightbulb . Command ] A list of commands filtered out by types. Source code in categories\\help.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def filter_command_type ( commands : t . Sequence [ lightbulb . Command ], types : t . Sequence [ t . Type ], remove_hidden : bool = False ) -> t . List [ lightbulb . Command ]: '''Filter commands with one of the type mentioned in `types`. Parameters ---------- commands : t.Sequence[lightbulb.Command] A sequence of commands. types : t.Sequence[t.Type] A sequence of command's types to filter. Example: `(lightbulb.PrefixCommand, lightbulb.SlashCommand)`. remove_hidden : bool, optional Whether or not to remove hidden commands. Default to `False`. Returns ------- t.List[lightbulb.Command] A list of commands filtered out by types. ''' l = [] for command in commands : if isinstance ( command , types ): if ( not remove_hidden ) or ( remove_hidden and not command . hidden ): l . append ( command ) return l","title":"filter_command_type()"},{"location":"dev/help/#categories.help.plugin_help_format","text":"Return a list of formatted embed for a plugin help. This list can be passed into a paginator to display. Parameters: Name Type Description Default ctx lightbulb . Context The context. required plugin lightbulb . Plugin The plugin to display the help. required Returns: Type Description t . List [ hikari . Embed ] A list of formatted embed for a plugin help. Source code in categories\\help.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def plugin_help_format ( ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> t . List [ hikari . Embed ]: '''Return a list of formatted embed for a plugin help. This list can be passed into a paginator to display. Parameters ---------- ctx : lightbulb.Context The context. plugin : lightbulb.Plugin The plugin to display the help. Returns ------- t.List[hikari.Embed] A list of formatted embed for a plugin help. ''' MAX_COMMANDS = 10 display = \"\" plugins = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ commands : t . List [ lightbulb . Command ] = filter_command_type ( plugin . all_commands , types , True ) commands . sort ( key = lambda command : command . name ) for index , command in enumerate ( commands ): # Signature includes command name. command_title = command . signature . replace ( '=' , ' = ' ) display += f \"** { command_title } :** \\n \" description = command . description if not description : description = \"*No help provided*\" display += f \"- { description } \\n\\n \" if index == MAX_COMMANDS - 1 or index == len ( commands ) - 1 : title = f \" { plugin . name } ( { len ( commands ) } commands):\" embed = helpers . get_default_embed ( title = title , description = display , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) . set_thumbnail ( ctx . bot . get_me () . avatar_url ) plugins . append ( embed ) display = \"\" return plugins","title":"plugin_help_format()"},{"location":"dev/help/#categories.help.command_help_format","text":"Return a formatted embed for a command help.","title":"command_help_format()"},{"location":"dev/help/#categories.help.command_help_format--notes","text":"For command group, the embed will also include all subcommands. Parameters: Name Type Description Default ctx lightbulb . Context The context. required command lightbulb . Command The command to display the help. Can also be a command group/subcommand/... required Returns: Type Description hikari . Embed The formatted embed for a command help. Source code in categories\\help.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def command_help_format ( ctx : lightbulb . Context , command : lightbulb . Command ) -> hikari . Embed : '''Return a formatted embed for a command help. Notes ----- For command group, the embed will also include all subcommands. Parameters ---------- ctx : lightbulb.Context The context. command : lightbulb.Command The command to display the help. Can also be a command group/subcommand/... Returns ------- hikari.Embed The formatted embed for a command help. ''' bot : models . MichaelBot = ctx . bot # Signature includes full command name. embed_title = command . signature . replace ( '=' , ' = ' ) embed_description = \"*No help provided*\" if command . description != \"\" : embed_description = command . description + ' \\n ' embed = helpers . get_default_embed ( title = embed_title , description = embed_description , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) command_type = [] p_cmd = bot . get_prefix_command ( command . qualname ) s_cmd = bot . get_slash_command ( command . qualname ) m_cmd = bot . get_message_command ( command . qualname ) u_cmd = bot . get_user_command ( command . qualname ) if p_cmd is not None : command_type . append ( \"`Prefix Command`\" ) if s_cmd is not None and not isinstance ( s_cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): command_type . append ( \"`Slash Command`\" ) if m_cmd is not None : command_type . append ( \"`Message Command`\" ) if u_cmd is not None : command_type . append ( \"`User Command`\" ) embed . add_field ( name = \"Type\" , value = ' ' . join ( command_type ) ) if len ( command . options ) > 0 : option_field = \"\" for option in command . options . values (): option_field += f \"- ` { option . name } `: { option . description } \\n \" embed . add_field ( name = \"Parameters\" , value = option_field ) if len ( command . aliases ) > 0 and isinstance ( command , __PREFIX_COMMAND_TYPES__ ): embed . add_field ( name = \"Aliases (Prefix Command only)\" , value = \"- \" + ', ' . join ( f \"` { alias } `\" for alias in command . aliases ) ) if bool ( command . get_help ( ctx )): embed . add_field ( name = \"Note\" , value = dedent ( command . get_help ( ctx )) ) if isinstance ( command , __COMMAND_GROUPS_TYPES__ ): field_value = \"\" subcommands = command . subcommands . values () types = __PREFIX_COMMAND_TYPES__ # Can't check with ctx, since SlashContext can call a PrefixCommandGroup. if isinstance ( command , __SLASH_COMMAND_TYPES__ ): types = __SLASH_COMMAND_TYPES__ for subcommand in sorted ( filter_command_type ( subcommands , types , True ), key = lambda cmd : cmd . name ): field_value += f \"- ` { subcommand . name } `: { subcommand . description } \\n \" if len ( command . subcommands ) > 0 : embed . add_field ( name = \"**Subcommands:**\" , value = field_value , inline = False ) return embed","title":"Notes"},{"location":"dev/helpers/","text":"Contains many useful functions. embed_from_dict ( / , data : dict [ str , t . Any ]) -> hikari . Embed Generate an embed from a dictionary. Parameters: Name Type Description Default data dict [ str , t . Any ] A valid dict representation of an embed. required Returns: Type Description hikari . Embed The embed from the dict. Source code in utils\\helpers.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def embed_from_dict ( data : dict [ str , t . Any ], / ) -> hikari . Embed : '''Generate an embed from a dictionary. Parameters ---------- data : dict[str, t.Any] A valid dict representation of an embed. Returns ------- hikari.Embed The embed from the dict. ''' embed = hikari . Embed () embed . title = data . get ( \"title\" , None ) embed . description = data . get ( \"description\" , None ) embed . url = data . get ( \"url\" , None ) if embed . title is not None : embed . title = str ( embed . title ) if embed . description is not None : embed . description = str ( embed . description ) if embed . url is not None : embed . url = str ( embed . url ) try : embed . color = hikari . Color ( data [ \"color\" ]) except KeyError : pass try : embed . timestamp = dt . datetime . fromtimestamp ( data [ 'timestamp' ], tz = dt . timezone . utc ) except KeyError : pass try : value = data [ \"thumbnail\" ] except KeyError : pass else : embed . set_thumbnail ( value ) try : value = data [ \"author\" ] except KeyError : pass else : embed . set_author ( ** value ) try : value = data [ \"fields\" ] except KeyError : pass else : for field in value : embed . add_field ( ** field ) try : value = data [ \"image\" ] except KeyError : pass else : embed . set_image ( value ) try : value = data [ \"footer\" ] except KeyError : pass else : embed . set_footer ( ** value ) return embed embed_to_dict ( / , embed : hikari . Embed ) -> dict [ str , t . Any ] Convert an embed into a dict object. Parameters: Name Type Description Default embed hikari . Embed An embed object to convert. required Returns: Type Description dict [ str , t . Any ] A dictionary that conforms Discord's structure. Source code in utils\\helpers.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def embed_to_dict ( embed : hikari . Embed , / ) -> dict [ str , t . Any ]: '''Convert an embed into a dict object. Parameters ---------- embed : hikari.Embed An embed object to convert. Returns ------- dict[str, t.Any] A dictionary that conforms Discord's structure. ''' d = {} if bool ( embed . title ): d [ \"title\" ] = embed . title if bool ( embed . description ): d [ \"description\" ] = embed . description if bool ( embed . url ): d [ \"url\" ] = embed . url if bool ( embed . color ): d [ \"color\" ] = int ( embed . color ) if bool ( embed . timestamp ): d [ \"timestamp\" ] = embed . timestamp . timestamp () if bool ( embed . thumbnail ): d [ \"thumbnail\" ] = embed . thumbnail . url if bool ( embed . author ): d [ \"author\" ] = { \"name\" : embed . author . name , \"url\" : embed . author . url } if bool ( embed . author . icon ): d [ \"author\" ][ \"icon\" ] = embed . author . icon . url if bool ( embed . fields ): d [ \"fields\" ] = [] for field in embed . fields : d [ \"fields\" ] . append ({ \"name\" : field . name , \"value\" : field . value , \"inline\" : field . is_inline }) if bool ( embed . image ): d [ \"image\" ] = embed . image . url if bool ( embed . footer ): d [ \"footer\" ] = { \"text\" : embed . footer . text } if bool ( embed . footer . icon ): d [ \"footer\" ][ \"icon\" ] = embed . footer . icon . url return d get_emote ( / , discord_text : str ) -> str Return the Unicode emoji based on the name provided. Parameters: Name Type Description Default discord_text str Discord/Twitter name of the emoji including : . Example: :grin: . required Returns: Type Description str The Unicode emoji matching the text. Raises: Type Description KeyError Cannot find the emoji based on the text. Source code in utils\\helpers.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def get_emote ( discord_text : str , / ) -> str : '''Return the Unicode emoji based on the name provided. Parameters ---------- discord_text : str Discord/Twitter name of the emoji including `:`. Example: `:grin:`. Returns ------- str The Unicode emoji matching the text. Raises ------ KeyError Cannot find the emoji based on the text. ''' ret = emoji . emojize ( discord_text , language = \"alias\" ) if ret == discord_text : raise KeyError ( f \"Emoji { discord_text } cannot be found.\" ) return ret get_friendly_permissions ( / , permissions : hikari . Permissions ) -> t . List [ str ] Return a list of highlighted permissions string presented in the permission provided. This returns the exact Discord's string of the permission. Parameters: Name Type Description Default permissions hikari . Permissions A permission object. required Returns: Type Description t . List [ str ] A list of highlighted permissions string represented in the permission provided. Notes Manage Events cannot be found in Hikari's documentation. Therefore, it is not included. Source code in utils\\helpers.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def get_friendly_permissions ( permissions : hikari . Permissions , / ) -> t . List [ str ]: '''Return a list of highlighted permissions string presented in the permission provided. This returns the exact Discord's string of the permission. Parameters ---------- permissions : hikari.Permissions A permission object. Returns ------- t.List[str] A list of highlighted permissions string represented in the permission provided. Notes ----- `Manage Events` cannot be found in Hikari's documentation. Therefore, it is not included. ''' l = [] for permission , text in __PERMISSIONS_MAPPING__ . items (): if permissions & permission : l . append ( f \"` { text } `\" ) return l get_default_embed ( * , author : hikari . Member = None , ** kwargs ) -> hikari . Embed Return a default embed to work with for consistency. Args: author: The author to set in the footer. **kwargs: hikari.Embed constructor. Parameters: Name Type Description Default author hikari . Member , optional The author to set in the footer. If not provided, the footer will not be edited. None **kwargs dict The options passed into hikari.Embed() . {} Returns: Type Description hikari . Embed The default embed. Source code in utils\\helpers.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 def get_default_embed ( * , author : hikari . Member = None , ** kwargs ) -> hikari . Embed : '''Return a default embed to work with for consistency. Args: author: The author to set in the footer. **kwargs: `hikari.Embed` constructor. Parameters ---------- author : hikari.Member, optional The author to set in the footer. If not provided, the footer will not be edited. **kwargs : dict The options passed into `hikari.Embed()`. Returns ------- hikari.Embed The default embed. ''' title = kwargs . get ( \"title\" ) url = kwargs . get ( \"url\" ) description = kwargs . get ( \"description\" ) color = kwargs . get ( \"color\" ) if kwargs . get ( \"color\" ) is not None else models . DefaultColor . green . value timestamp = kwargs . get ( \"timestamp\" ) embed = hikari . Embed ( title = title , url = url , description = description , color = color , timestamp = timestamp ) if author is not None : embed . set_footer ( text = f \"Requested by { author . username } \" , icon = author . avatar_url ) return embed mention ( / , mentionable_object : t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ]) -> str Return the appropriate mention string for a mentionable object. Parameters: Name Type Description Default mentionable_object t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ] The object to mention. required Returns: Type Description str The object's default mention string. Notes If the object is a hikari.PartialRole and it has the name @everyone , it'll return the name directly. Source code in utils\\helpers.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 def mention ( mentionable_object : t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ], / ) -> str : '''Return the appropriate mention string for a mentionable object. Parameters ---------- mentionable_object : t.Union[hikari.PartialUser, hikari.PartialRole, hikari.TextableGuildChannel] The object to mention. Returns ------- str The object's default mention string. Notes ----- If the object is a `hikari.PartialRole` and it has the name `@everyone`, it'll return the name directly. ''' if isinstance ( mentionable_object , hikari . PartialRole ): if mentionable_object . name == \"@everyone\" : return mentionable_object . name return mentionable_object . mention sleep_until ( / , when : dt . datetime ) async Wait until the specified time. Parameters: Name Type Description Default when dt . datetime The time to resume. Must be tz aware and in utc. required Source code in utils\\helpers.py 324 325 326 327 328 329 330 331 332 333 334 async def sleep_until ( when : dt . datetime , / ): '''Wait until the specified time. Parameters ---------- when : dt.datetime The time to resume. Must be tz aware and in utc. ''' time = when - dt . datetime . now () . astimezone () if time . total_seconds () > 0 : await asyncio . sleep ( time . total_seconds ()) striplist ( / , arr : t . Sequence [ str ]) -> str Return a string from a list, separated by comma. Parameters: Name Type Description Default arr t . Sequence [ str ] A sequence of objects that are convertible to str . required Returns: Type Description str The final string. Empty if sequence is empty. Source code in utils\\helpers.py 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 def striplist ( arr : t . Sequence [ str ], / ) -> str : '''Return a string from a list, separated by comma. Parameters ---------- arr : t.Sequence[str] A sequence of objects that are convertible to `str`. Returns ------- str The final string. Empty if sequence is empty. ''' return \", \" . join ( arr )","title":"helpers.py"},{"location":"dev/helpers/#utils.helpers.embed_from_dict","text":"Generate an embed from a dictionary. Parameters: Name Type Description Default data dict [ str , t . Any ] A valid dict representation of an embed. required Returns: Type Description hikari . Embed The embed from the dict. Source code in utils\\helpers.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def embed_from_dict ( data : dict [ str , t . Any ], / ) -> hikari . Embed : '''Generate an embed from a dictionary. Parameters ---------- data : dict[str, t.Any] A valid dict representation of an embed. Returns ------- hikari.Embed The embed from the dict. ''' embed = hikari . Embed () embed . title = data . get ( \"title\" , None ) embed . description = data . get ( \"description\" , None ) embed . url = data . get ( \"url\" , None ) if embed . title is not None : embed . title = str ( embed . title ) if embed . description is not None : embed . description = str ( embed . description ) if embed . url is not None : embed . url = str ( embed . url ) try : embed . color = hikari . Color ( data [ \"color\" ]) except KeyError : pass try : embed . timestamp = dt . datetime . fromtimestamp ( data [ 'timestamp' ], tz = dt . timezone . utc ) except KeyError : pass try : value = data [ \"thumbnail\" ] except KeyError : pass else : embed . set_thumbnail ( value ) try : value = data [ \"author\" ] except KeyError : pass else : embed . set_author ( ** value ) try : value = data [ \"fields\" ] except KeyError : pass else : for field in value : embed . add_field ( ** field ) try : value = data [ \"image\" ] except KeyError : pass else : embed . set_image ( value ) try : value = data [ \"footer\" ] except KeyError : pass else : embed . set_footer ( ** value ) return embed","title":"embed_from_dict()"},{"location":"dev/helpers/#utils.helpers.embed_to_dict","text":"Convert an embed into a dict object. Parameters: Name Type Description Default embed hikari . Embed An embed object to convert. required Returns: Type Description dict [ str , t . Any ] A dictionary that conforms Discord's structure. Source code in utils\\helpers.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def embed_to_dict ( embed : hikari . Embed , / ) -> dict [ str , t . Any ]: '''Convert an embed into a dict object. Parameters ---------- embed : hikari.Embed An embed object to convert. Returns ------- dict[str, t.Any] A dictionary that conforms Discord's structure. ''' d = {} if bool ( embed . title ): d [ \"title\" ] = embed . title if bool ( embed . description ): d [ \"description\" ] = embed . description if bool ( embed . url ): d [ \"url\" ] = embed . url if bool ( embed . color ): d [ \"color\" ] = int ( embed . color ) if bool ( embed . timestamp ): d [ \"timestamp\" ] = embed . timestamp . timestamp () if bool ( embed . thumbnail ): d [ \"thumbnail\" ] = embed . thumbnail . url if bool ( embed . author ): d [ \"author\" ] = { \"name\" : embed . author . name , \"url\" : embed . author . url } if bool ( embed . author . icon ): d [ \"author\" ][ \"icon\" ] = embed . author . icon . url if bool ( embed . fields ): d [ \"fields\" ] = [] for field in embed . fields : d [ \"fields\" ] . append ({ \"name\" : field . name , \"value\" : field . value , \"inline\" : field . is_inline }) if bool ( embed . image ): d [ \"image\" ] = embed . image . url if bool ( embed . footer ): d [ \"footer\" ] = { \"text\" : embed . footer . text } if bool ( embed . footer . icon ): d [ \"footer\" ][ \"icon\" ] = embed . footer . icon . url return d","title":"embed_to_dict()"},{"location":"dev/helpers/#utils.helpers.get_emote","text":"Return the Unicode emoji based on the name provided. Parameters: Name Type Description Default discord_text str Discord/Twitter name of the emoji including : . Example: :grin: . required Returns: Type Description str The Unicode emoji matching the text. Raises: Type Description KeyError Cannot find the emoji based on the text. Source code in utils\\helpers.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def get_emote ( discord_text : str , / ) -> str : '''Return the Unicode emoji based on the name provided. Parameters ---------- discord_text : str Discord/Twitter name of the emoji including `:`. Example: `:grin:`. Returns ------- str The Unicode emoji matching the text. Raises ------ KeyError Cannot find the emoji based on the text. ''' ret = emoji . emojize ( discord_text , language = \"alias\" ) if ret == discord_text : raise KeyError ( f \"Emoji { discord_text } cannot be found.\" ) return ret","title":"get_emote()"},{"location":"dev/helpers/#utils.helpers.get_friendly_permissions","text":"Return a list of highlighted permissions string presented in the permission provided. This returns the exact Discord's string of the permission. Parameters: Name Type Description Default permissions hikari . Permissions A permission object. required Returns: Type Description t . List [ str ] A list of highlighted permissions string represented in the permission provided.","title":"get_friendly_permissions()"},{"location":"dev/helpers/#utils.helpers.get_friendly_permissions--notes","text":"Manage Events cannot be found in Hikari's documentation. Therefore, it is not included. Source code in utils\\helpers.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def get_friendly_permissions ( permissions : hikari . Permissions , / ) -> t . List [ str ]: '''Return a list of highlighted permissions string presented in the permission provided. This returns the exact Discord's string of the permission. Parameters ---------- permissions : hikari.Permissions A permission object. Returns ------- t.List[str] A list of highlighted permissions string represented in the permission provided. Notes ----- `Manage Events` cannot be found in Hikari's documentation. Therefore, it is not included. ''' l = [] for permission , text in __PERMISSIONS_MAPPING__ . items (): if permissions & permission : l . append ( f \"` { text } `\" ) return l","title":"Notes"},{"location":"dev/helpers/#utils.helpers.get_default_embed","text":"Return a default embed to work with for consistency. Args: author: The author to set in the footer. **kwargs: hikari.Embed constructor. Parameters: Name Type Description Default author hikari . Member , optional The author to set in the footer. If not provided, the footer will not be edited. None **kwargs dict The options passed into hikari.Embed() . {} Returns: Type Description hikari . Embed The default embed. Source code in utils\\helpers.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 def get_default_embed ( * , author : hikari . Member = None , ** kwargs ) -> hikari . Embed : '''Return a default embed to work with for consistency. Args: author: The author to set in the footer. **kwargs: `hikari.Embed` constructor. Parameters ---------- author : hikari.Member, optional The author to set in the footer. If not provided, the footer will not be edited. **kwargs : dict The options passed into `hikari.Embed()`. Returns ------- hikari.Embed The default embed. ''' title = kwargs . get ( \"title\" ) url = kwargs . get ( \"url\" ) description = kwargs . get ( \"description\" ) color = kwargs . get ( \"color\" ) if kwargs . get ( \"color\" ) is not None else models . DefaultColor . green . value timestamp = kwargs . get ( \"timestamp\" ) embed = hikari . Embed ( title = title , url = url , description = description , color = color , timestamp = timestamp ) if author is not None : embed . set_footer ( text = f \"Requested by { author . username } \" , icon = author . avatar_url ) return embed","title":"get_default_embed()"},{"location":"dev/helpers/#utils.helpers.mention","text":"Return the appropriate mention string for a mentionable object. Parameters: Name Type Description Default mentionable_object t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ] The object to mention. required Returns: Type Description str The object's default mention string.","title":"mention()"},{"location":"dev/helpers/#utils.helpers.mention--notes","text":"If the object is a hikari.PartialRole and it has the name @everyone , it'll return the name directly. Source code in utils\\helpers.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 def mention ( mentionable_object : t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ], / ) -> str : '''Return the appropriate mention string for a mentionable object. Parameters ---------- mentionable_object : t.Union[hikari.PartialUser, hikari.PartialRole, hikari.TextableGuildChannel] The object to mention. Returns ------- str The object's default mention string. Notes ----- If the object is a `hikari.PartialRole` and it has the name `@everyone`, it'll return the name directly. ''' if isinstance ( mentionable_object , hikari . PartialRole ): if mentionable_object . name == \"@everyone\" : return mentionable_object . name return mentionable_object . mention","title":"Notes"},{"location":"dev/helpers/#utils.helpers.sleep_until","text":"Wait until the specified time. Parameters: Name Type Description Default when dt . datetime The time to resume. Must be tz aware and in utc. required Source code in utils\\helpers.py 324 325 326 327 328 329 330 331 332 333 334 async def sleep_until ( when : dt . datetime , / ): '''Wait until the specified time. Parameters ---------- when : dt.datetime The time to resume. Must be tz aware and in utc. ''' time = when - dt . datetime . now () . astimezone () if time . total_seconds () > 0 : await asyncio . sleep ( time . total_seconds ())","title":"sleep_until()"},{"location":"dev/helpers/#utils.helpers.striplist","text":"Return a string from a list, separated by comma. Parameters: Name Type Description Default arr t . Sequence [ str ] A sequence of objects that are convertible to str . required Returns: Type Description str The final string. Empty if sequence is empty. Source code in utils\\helpers.py 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 def striplist ( arr : t . Sequence [ str ], / ) -> str : '''Return a string from a list, separated by comma. Parameters ---------- arr : t.Sequence[str] A sequence of objects that are convertible to `str`. Returns ------- str The final string. Empty if sequence is empty. ''' return \", \" . join ( arr )","title":"striplist()"},{"location":"dev/menu/","text":"nav/navigator.py Contains common forms of menu navigator. StopButtonDelete Bases: nav . StopButton A custom button to stop the navigator AND delete the message. This button should only be used in nav.NavigatorView . Source code in utils\\nav\\navigator.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class StopButtonDelete ( nav . StopButton ): ''' A custom button to stop the navigator AND delete the message. This button should only be used in `nav.NavigatorView`. ''' async def callback ( self , context : miru . Context ) -> None : # Reference: https://github.com/HyperGH/hikari-miru/blob/main/miru/ext/nav/buttons.py#L239 #pylint: disable=protected-access view : nav . NavigatorView = self . view if not view . message and not view . _inter : return if view . _inter and view . ephemeral : await view . _inter . delete_initial_response () elif view . message : await view . message . delete () #pylint: enable=protected-access view . stop () ButtonNavigator Bases: nav . NavigatorView The default navigator. Source code in utils\\nav\\navigator.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class ButtonNavigator ( nav . NavigatorView ): ''' The default navigator. ''' def __init__ ( self , * args , ** kwargs ) -> None : super () . __init__ ( * args , ** kwargs ) for index , item in enumerate ( self . pages ): if isinstance ( item , hikari . Embed ): item . set_footer ( f \"Page { index + 1 } / { len ( self . pages ) } \" ) def get_default_buttons ( self ) -> t . List [ nav . NavButton [ nav . NavigatorView ]]: ''' Returns a list of default buttons. These are `FirstButton()`, `PrevButton()`, `NextButton()`, `LastButton()`, and `StopButtonDelete()`. Returns ------- t.List[nav.NavButton[nav.NavigatorView]] A list of default buttons. ''' return [ nav . FirstButton (), nav . PrevButton (), nav . NextButton (), nav . LastButton (), StopButtonDelete ()] async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout () get_default_buttons () -> t . List [ nav . NavButton [ nav . NavigatorView ]] Returns a list of default buttons. These are FirstButton() , PrevButton() , NextButton() , LastButton() , and StopButtonDelete() . Returns: Type Description t . List [ nav . NavButton [ nav . NavigatorView ]] A list of default buttons. Source code in utils\\nav\\navigator.py 60 61 62 63 64 65 66 67 68 69 70 71 def get_default_buttons ( self ) -> t . List [ nav . NavButton [ nav . NavigatorView ]]: ''' Returns a list of default buttons. These are `FirstButton()`, `PrevButton()`, `NextButton()`, `LastButton()`, and `StopButtonDelete()`. Returns ------- t.List[nav.NavButton[nav.NavigatorView]] A list of default buttons. ''' return [ nav . FirstButton (), nav . PrevButton (), nav . NextButton (), nav . LastButton (), StopButtonDelete ()] on_timeout () -> None async Called when the view times out. Notes This adds the timeout button into the menu. Source code in utils\\nav\\navigator.py 73 74 75 76 77 78 79 80 81 82 async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout () timeout_button () -> nav . NavButton Return a NavButton to be use in nav.NavigatorView . This button is safe to use in miru.View . Returns: Type Description nav . NavButton The default timeout button. Source code in utils\\nav\\navigator.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def timeout_button () -> nav . NavButton : '''Return a `NavButton` to be use in `nav.NavigatorView`. This button is safe to use in `miru.View`. Returns ------- nav.NavButton The default timeout button. ''' return nav . NavButton ( style = hikari . ButtonStyle . SECONDARY , emoji = helpers . get_emote ( \":clock12:\" ), custom_id = \"timeout_button\" , disabled = True ) nav/confirm.py Contains a confirmation menu. ConfirmView Bases: miru . View A confirmation menu. Source code in utils\\nav\\confirm.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class ConfirmView ( miru . View ): ''' A confirmation menu. ''' def __init__ ( self , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None : super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . result : t . Optional [ bool ] = None @miru . button ( label = \"Yes\" , emoji = helpers . get_emote ( \":white_check_mark:\" ), style = hikari . ButtonStyle . SUCCESS , custom_id = \"yes_button\" ) async def yes_button ( self , _ : miru . Button , __ : miru . Context ): self . result = True self . stop () @miru . button ( label = \"No\" , emoji = helpers . get_emote ( \":negative_squared_cross_mark:\" ), style = hikari . ButtonStyle . DANGER , custom_id = \"no_button\" ) async def no_button ( self , _ : miru . Button , __ : miru . Context ): self . result = False self . stop () async def wait ( self ) -> t . Optional [ bool ]: ''' Wait until the view times out or stops manually. Return the result of the confirmation, or `None` if it times out. ''' await super () . wait () await self . message . delete () return self . result wait () -> t . Optional [ bool ] async Wait until the view times out or stops manually. Return the result of the confirmation, or None if it times out. Source code in utils\\nav\\confirm.py 27 28 29 30 31 32 33 34 35 36 async def wait ( self ) -> t . Optional [ bool ]: ''' Wait until the view times out or stops manually. Return the result of the confirmation, or `None` if it times out. ''' await super () . wait () await self . message . delete () return self . result nav/menu.py Contains everything needed to build a complex menu. MenuComponent A tree-like node that represents the menu's option structure. The node has two \"states\": a regular node state and a fake node. A regular node state is when the options is a dictionary, which will determine the child nodes. A fake node state is when the options is a list of contents to display. In this case, the node's content is set to None , and no further child nodes can be created from this node. The child nodes can be accessed using dictionary notation IF there are child nodes. Source code in utils\\nav\\menu.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class MenuComponent : ''' A tree-like node that represents the menu's option structure. The node has two \"states\": a regular node state and a fake node. A regular node state is when the `options` is a dictionary, which will determine the child nodes. A fake node state is when the `options` is a list of contents to display. In this case, the node's content is set to `None`, and no further child nodes can be created from this node. The child nodes can be accessed using dictionary notation IF there are child nodes. ''' def __init__ ( self , content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ): ''' Create a node that stores the content and optionally, its options. The `options` can be a list, which will set the content to `None` regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a `dict` through `options`, but instead, use `.add_options()`. ''' self . content = content self . options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = options self . __parent__ : t . Optional [ MenuComponent ] = None if isinstance ( self . options , list ): self . content = None def add_option ( self , key : MenuButton , content : PageLike ) -> MenuComponent : '''Add an option into the current node. Return the newly added node to further add more layers. Warnings -------- The returned object is the newly added object, not the current object. Parameters ---------- key : MenuButton The button for the new option. content : PageLike The content of the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. ''' if isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) if self . options is None : self . options = { key : MenuComponent ( content )} self . options [ key ] . __parent__ = self return self . options [ key ] elif self . options . get ( key ) is None : component = MenuComponent ( content ) component . __parent__ = self self . options [ key ] = component return self . options [ key ] else : raise LookupError ( \"Duplicated keys.\" ) def add_options ( self , options : t . Dict [ MenuButton , PageLike ]): '''Add multiple options into the current node. Warnings -------- This will overwrite any possible duplicate keys. Parameters ---------- options : t.Dict[MenuButton, PageLike] A mapping of {button: content}. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) for key in options : self . options [ key ] = MenuComponent ( options [ key ]) self . options [ key ] . __parent__ = self def add_list_options ( self , key : str , contents : t . List [ PageLike ]) -> MenuComponent : '''Append a fake node to this node. Return the newly added node to do whatever you want. Parameters ---------- key : str The button for the new option. contents : t.List[PageLike] A list of content for the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) component = None if len ( contents ) == 1 : component = MenuComponent ( content = contents [ 0 ]) else : component = MenuComponent ( content = None , options = contents ) component . __parent__ = self self . options [ key ] = component return component def force_add_list_options ( self , contents : t . List [ PageLike ]): '''Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters ---------- contents : t.List[PageLike] A list of content for the option. ''' if self . options is None : self . options = [] for content in contents : self . options . append ( content ) self . content = None def __getitem__ ( self , key : MenuButton ) -> t . Optional [ MenuComponent ]: '''Return the MenuComponent with the matching key, or `None` if none was found. Parameters ---------- key : MenuButton The option you're retrieving. Returns ------- t.Optional[MenuComponent] The option with matching key, or `None` if none was found. Raises ------ IndexError The current MenuComponent is already a fake node. ''' if isinstance ( self . options , dict ): return self . options . get ( key ) raise IndexError ( \"Index doesn't exist.\" ) __init__ ( content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ) Create a node that stores the content and optionally, its options. The options can be a list, which will set the content to None regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a dict through options , but instead, use .add_options() . Source code in utils\\nav\\menu.py 26 27 28 29 30 31 32 33 34 35 36 37 38 def __init__ ( self , content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ): ''' Create a node that stores the content and optionally, its options. The `options` can be a list, which will set the content to `None` regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a `dict` through `options`, but instead, use `.add_options()`. ''' self . content = content self . options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = options self . __parent__ : t . Optional [ MenuComponent ] = None if isinstance ( self . options , list ): self . content = None add_option ( key : MenuButton , content : PageLike ) -> MenuComponent Add an option into the current node. Return the newly added node to further add more layers. Warnings The returned object is the newly added object, not the current object. Parameters: Name Type Description Default key MenuButton The button for the new option. required content PageLike The content of the new option. required Returns: Type Description MenuComponent The newly added option. Raises: Type Description KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. Source code in utils\\nav\\menu.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def add_option ( self , key : MenuButton , content : PageLike ) -> MenuComponent : '''Add an option into the current node. Return the newly added node to further add more layers. Warnings -------- The returned object is the newly added object, not the current object. Parameters ---------- key : MenuButton The button for the new option. content : PageLike The content of the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. ''' if isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) if self . options is None : self . options = { key : MenuComponent ( content )} self . options [ key ] . __parent__ = self return self . options [ key ] elif self . options . get ( key ) is None : component = MenuComponent ( content ) component . __parent__ = self self . options [ key ] = component return self . options [ key ] else : raise LookupError ( \"Duplicated keys.\" ) add_options ( options : t . Dict [ MenuButton , PageLike ]) Add multiple options into the current node. Warnings This will overwrite any possible duplicate keys. Parameters: Name Type Description Default options t . Dict [ MenuButton , PageLike ] A mapping of {button: content}. required Raises: Type Description KeyError The current MenuComponent is already a fake node. Source code in utils\\nav\\menu.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def add_options ( self , options : t . Dict [ MenuButton , PageLike ]): '''Add multiple options into the current node. Warnings -------- This will overwrite any possible duplicate keys. Parameters ---------- options : t.Dict[MenuButton, PageLike] A mapping of {button: content}. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) for key in options : self . options [ key ] = MenuComponent ( options [ key ]) self . options [ key ] . __parent__ = self add_list_options ( key : str , contents : t . List [ PageLike ]) -> MenuComponent Append a fake node to this node. Return the newly added node to do whatever you want. Parameters: Name Type Description Default key str The button for the new option. required contents t . List [ PageLike ] A list of content for the new option. required Returns: Type Description MenuComponent The newly added option. Raises: Type Description KeyError The current MenuComponent is already a fake node. Source code in utils\\nav\\menu.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def add_list_options ( self , key : str , contents : t . List [ PageLike ]) -> MenuComponent : '''Append a fake node to this node. Return the newly added node to do whatever you want. Parameters ---------- key : str The button for the new option. contents : t.List[PageLike] A list of content for the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) component = None if len ( contents ) == 1 : component = MenuComponent ( content = contents [ 0 ]) else : component = MenuComponent ( content = None , options = contents ) component . __parent__ = self self . options [ key ] = component return component force_add_list_options ( contents : t . List [ PageLike ]) Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters: Name Type Description Default contents t . List [ PageLike ] A list of content for the option. required Source code in utils\\nav\\menu.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def force_add_list_options ( self , contents : t . List [ PageLike ]): '''Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters ---------- contents : t.List[PageLike] A list of content for the option. ''' if self . options is None : self . options = [] for content in contents : self . options . append ( content ) self . content = None __getitem__ ( key : MenuButton ) -> t . Optional [ MenuComponent ] Return the MenuComponent with the matching key, or None if none was found. Parameters: Name Type Description Default key MenuButton The option you're retrieving. required Returns: Type Description t . Optional [ MenuComponent ] The option with matching key, or None if none was found. Raises: Type Description IndexError The current MenuComponent is already a fake node. Source code in utils\\nav\\menu.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def __getitem__ ( self , key : MenuButton ) -> t . Optional [ MenuComponent ]: '''Return the MenuComponent with the matching key, or `None` if none was found. Parameters ---------- key : MenuButton The option you're retrieving. Returns ------- t.Optional[MenuComponent] The option with matching key, or `None` if none was found. Raises ------ IndexError The current MenuComponent is already a fake node. ''' if isinstance ( self . options , dict ): return self . options . get ( key ) raise IndexError ( \"Index doesn't exist.\" ) MenuButton Bases: miru . Button Represents a generic button inside ComplexView . This should only be used in ComplexView . Source code in utils\\nav\\menu.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 class MenuButton ( miru . Button ): '''Represents a generic button inside `ComplexView`. This should only be used in `ComplexView`.''' async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the option if the current `MenuComponent` is not a fake node. ''' view : ComplexView = self . view if isinstance ( view . menu . options , dict ): view . menu = view . menu . options [ self ] await view . update () callback ( _ : miru . Context ) -> None async Calls when the button is pressed. It'll move to the option if the current MenuComponent is not a fake node. Source code in utils\\nav\\menu.py 186 187 188 189 190 191 192 193 194 195 196 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the option if the current `MenuComponent` is not a fake node. ''' view : ComplexView = self . view if isinstance ( view . menu . options , dict ): view . menu = view . menu . options [ self ] await view . update () ReturnMenuButton Bases: MenuButton Represents a return button. Source code in utils\\nav\\menu.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 class ReturnMenuButton ( MenuButton ): '''Represents a return button.''' def __init__ ( self ) -> None : super () . __init__ ( style = hikari . ButtonStyle . SECONDARY , emoji = helpers . get_emote ( \":arrow_up_small:\" ), custom_id = \"return_button\" ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the parent node if it is not `None`. Raises ------ RuntimeError The return button is in the root menu. ''' view : ComplexView = self . view if view . menu . __parent__ is not None : view . menu = view . menu . __parent__ view . current_page = 0 else : raise RuntimeError ( \"A return button is available in the root menu.\" ) await view . update () callback ( _ : miru . Context ) -> None async Calls when the button is pressed. It'll move to the parent node if it is not None . Raises: Type Description RuntimeError The return button is in the root menu. Source code in utils\\nav\\menu.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the parent node if it is not `None`. Raises ------ RuntimeError The return button is in the root menu. ''' view : ComplexView = self . view if view . menu . __parent__ is not None : view . menu = view . menu . __parent__ view . current_page = 0 else : raise RuntimeError ( \"A return button is available in the root menu.\" ) await view . update () StopMenuButton Bases: MenuButton Represents a terminate button. Source code in utils\\nav\\menu.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 class StopMenuButton ( MenuButton ): '''Represents a terminate button.''' def __init__ ( self ) -> None : super () . __init__ ( style = hikari . ButtonStyle . DANGER , emoji = helpers . get_emote ( \":stop_button:\" ), custom_id = \"stop_button\" ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll stop the `ComplexView` and delete the menu. ''' view : ComplexView = self . view view . stop () if view . message : await view . message . delete () callback ( _ : miru . Context ) -> None async Calls when the button is pressed. It'll stop the ComplexView and delete the menu. Source code in utils\\nav\\menu.py 236 237 238 239 240 241 242 243 244 245 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll stop the `ComplexView` and delete the menu. ''' view : ComplexView = self . view view . stop () if view . message : await view . message . delete () NextMenuButton Bases: MenuButton A button to move to the next page list. This behaves similarly to nav.NextButton() . Source code in utils\\nav\\menu.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 class NextMenuButton ( MenuButton ): '''A button to move to the next page list. This behaves similarly to `nav.NextButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"next_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":arrow_forward:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. ''' view : ComplexView = self . view view . current_page += 1 if view . current_page > len ( view . menu . options ) - 1 : view . current_page = 0 await view . update () callback ( _ : miru . Context ) -> None async Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. Source code in utils\\nav\\menu.py 262 263 264 265 266 267 268 269 270 271 272 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. ''' view : ComplexView = self . view view . current_page += 1 if view . current_page > len ( view . menu . options ) - 1 : view . current_page = 0 await view . update () PrevMenuButton Bases: MenuButton A button to move to the previous page list. This behaves similarly to nav.PrevButton() . Source code in utils\\nav\\menu.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 class PrevMenuButton ( MenuButton ): '''A button to move to the previous page list. This behaves similarly to `nav.PrevButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"prev_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":arrow_backward:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. ''' view : ComplexView = self . view view . current_page -= 1 if view . current_page < 0 : view . current_page = len ( view . menu . options ) - 1 await view . update () callback ( _ : miru . Context ) -> None async Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. Source code in utils\\nav\\menu.py 289 290 291 292 293 294 295 296 297 298 299 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. ''' view : ComplexView = self . view view . current_page -= 1 if view . current_page < 0 : view . current_page = len ( view . menu . options ) - 1 await view . update () FirstMenuButton Bases: MenuButton A button to move to the first page list. This behaves similarly to nav.FirstButton() . Source code in utils\\nav\\menu.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 class FirstMenuButton ( MenuButton ): '''A button to move to the first page list. This behaves similarly to `nav.FirstButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"first_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":last_track_button:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the first page. ''' view : ComplexView = self . view view . current_page = 0 await view . update () callback ( _ : miru . Context ) -> None async Calls when the button is pressed. Move to the first page. Source code in utils\\nav\\menu.py 316 317 318 319 320 321 322 323 324 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the first page. ''' view : ComplexView = self . view view . current_page = 0 await view . update () LastMenuButton Bases: MenuButton A button to move to the last page list. This behaves similarly to nav.LastButton() . Source code in utils\\nav\\menu.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 class LastMenuButton ( MenuButton ): '''A button to move to the last page list. This behaves similarly to `nav.LastButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"last_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":next_track_button:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the last page. ''' view : ComplexView = self . view view . current_page = len ( view . menu . options ) - 1 await view . update () callback ( _ : miru . Context ) -> None async Calls when the button is pressed. Move to the last page. Source code in utils\\nav\\menu.py 341 342 343 344 345 346 347 348 349 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the last page. ''' view : ComplexView = self . view view . current_page = len ( view . menu . options ) - 1 await view . update () ComplexView Bases: miru . View A complex menu. Source code in utils\\nav\\menu.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 class ComplexView ( miru . View ): '''A complex menu.''' def __init__ ( self , menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None : '''Construct a complex menu. Parameters ---------- menu : MenuComponent A `MenuComponent` tree. This must be a root node. timeout : t.Optional[float], optional How long (in seconds) the menu should accept interactions. Default to `120`. autodefer : bool, optional Whether or not the menu should defer when possible. Default to `True`. ''' super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . menu = menu # For list menu self . current_page : int = 0 def _update_button ( self ) -> None : ''' Update the button based on the current menu state. ''' self . clear_items () if isinstance ( self . menu . options , dict ): for button in self . menu . options : self . add_item ( button ) elif isinstance ( self . menu . options , list ): # TODO: Might optimize this so it wouldn't reset the buttons. self . add_item ( FirstMenuButton ()) self . add_item ( PrevMenuButton ()) self . add_item ( NextMenuButton ()) self . add_item ( LastMenuButton ()) for index , item in enumerate ( self . menu . options ): if isinstance ( item , hikari . Embed ): item . set_footer ( f \"Page { index + 1 } / { len ( self . menu . options ) } \" ) if self . menu . __parent__ is None : self . add_item ( StopMenuButton ()) else : self . add_item ( ReturnMenuButton ()) async def update ( self ) -> None : '''Update the menu. This shouldn't be called by the user. Raises ------ RuntimeError The message is not found (for unknown reasons). Notes ----- All `MenuButton` should call this method inside their callbacks once it's done with everything. ''' self . _update_button () content = self . menu . content # If view is in a list menu. Can also check if menu.content is None instead. if isinstance ( self . menu . options , list ): content = self . menu . options [ self . current_page ] if self . message : await self . message . edit ( content , components = self . build ()) else : raise RuntimeError ( \"Oops ComplexView.update() failed.\" ) async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout () async def run ( self , ctx : lightbulb . Context ) -> None : '''Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters ---------- ctx : lightbulb.Context A `lightbulb` context. ''' self . _update_button () resp_proxy = await ctx . respond ( self . menu . content , components = self . build ()) self . start ( await resp_proxy . message ()) await self . wait () __init__ ( menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None Construct a complex menu. Parameters: Name Type Description Default menu MenuComponent A MenuComponent tree. This must be a root node. required timeout t . Optional [ float ], optional How long (in seconds) the menu should accept interactions. Default to 120 . 120 autodefer bool , optional Whether or not the menu should defer when possible. Default to True . True Source code in utils\\nav\\menu.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 def __init__ ( self , menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None : '''Construct a complex menu. Parameters ---------- menu : MenuComponent A `MenuComponent` tree. This must be a root node. timeout : t.Optional[float], optional How long (in seconds) the menu should accept interactions. Default to `120`. autodefer : bool, optional Whether or not the menu should defer when possible. Default to `True`. ''' super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . menu = menu # For list menu self . current_page : int = 0 update () -> None async Update the menu. This shouldn't be called by the user. Raises: Type Description RuntimeError The message is not found (for unknown reasons). Notes All MenuButton should call this method inside their callbacks once it's done with everything. Source code in utils\\nav\\menu.py 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 async def update ( self ) -> None : '''Update the menu. This shouldn't be called by the user. Raises ------ RuntimeError The message is not found (for unknown reasons). Notes ----- All `MenuButton` should call this method inside their callbacks once it's done with everything. ''' self . _update_button () content = self . menu . content # If view is in a list menu. Can also check if menu.content is None instead. if isinstance ( self . menu . options , list ): content = self . menu . options [ self . current_page ] if self . message : await self . message . edit ( content , components = self . build ()) else : raise RuntimeError ( \"Oops ComplexView.update() failed.\" ) on_timeout () -> None async Called when the view times out. Notes This adds the timeout button into the menu. Source code in utils\\nav\\menu.py 421 422 423 424 425 426 427 428 429 430 async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout () run ( ctx : lightbulb . Context ) -> None async Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters: Name Type Description Default ctx lightbulb . Context A lightbulb context. required Source code in utils\\nav\\menu.py 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 async def run ( self , ctx : lightbulb . Context ) -> None : '''Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters ---------- ctx : lightbulb.Context A `lightbulb` context. ''' self . _update_button () resp_proxy = await ctx . respond ( self . menu . content , components = self . build ()) self . start ( await resp_proxy . message ()) await self . wait ()","title":"nav"},{"location":"dev/menu/#navnavigatorpy","text":"Contains common forms of menu navigator.","title":"nav/navigator.py"},{"location":"dev/menu/#utils.nav.navigator.StopButtonDelete","text":"Bases: nav . StopButton A custom button to stop the navigator AND delete the message. This button should only be used in nav.NavigatorView . Source code in utils\\nav\\navigator.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class StopButtonDelete ( nav . StopButton ): ''' A custom button to stop the navigator AND delete the message. This button should only be used in `nav.NavigatorView`. ''' async def callback ( self , context : miru . Context ) -> None : # Reference: https://github.com/HyperGH/hikari-miru/blob/main/miru/ext/nav/buttons.py#L239 #pylint: disable=protected-access view : nav . NavigatorView = self . view if not view . message and not view . _inter : return if view . _inter and view . ephemeral : await view . _inter . delete_initial_response () elif view . message : await view . message . delete () #pylint: enable=protected-access view . stop ()","title":"StopButtonDelete"},{"location":"dev/menu/#utils.nav.navigator.ButtonNavigator","text":"Bases: nav . NavigatorView The default navigator. Source code in utils\\nav\\navigator.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class ButtonNavigator ( nav . NavigatorView ): ''' The default navigator. ''' def __init__ ( self , * args , ** kwargs ) -> None : super () . __init__ ( * args , ** kwargs ) for index , item in enumerate ( self . pages ): if isinstance ( item , hikari . Embed ): item . set_footer ( f \"Page { index + 1 } / { len ( self . pages ) } \" ) def get_default_buttons ( self ) -> t . List [ nav . NavButton [ nav . NavigatorView ]]: ''' Returns a list of default buttons. These are `FirstButton()`, `PrevButton()`, `NextButton()`, `LastButton()`, and `StopButtonDelete()`. Returns ------- t.List[nav.NavButton[nav.NavigatorView]] A list of default buttons. ''' return [ nav . FirstButton (), nav . PrevButton (), nav . NextButton (), nav . LastButton (), StopButtonDelete ()] async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout ()","title":"ButtonNavigator"},{"location":"dev/menu/#utils.nav.navigator.ButtonNavigator.get_default_buttons","text":"Returns a list of default buttons. These are FirstButton() , PrevButton() , NextButton() , LastButton() , and StopButtonDelete() . Returns: Type Description t . List [ nav . NavButton [ nav . NavigatorView ]] A list of default buttons. Source code in utils\\nav\\navigator.py 60 61 62 63 64 65 66 67 68 69 70 71 def get_default_buttons ( self ) -> t . List [ nav . NavButton [ nav . NavigatorView ]]: ''' Returns a list of default buttons. These are `FirstButton()`, `PrevButton()`, `NextButton()`, `LastButton()`, and `StopButtonDelete()`. Returns ------- t.List[nav.NavButton[nav.NavigatorView]] A list of default buttons. ''' return [ nav . FirstButton (), nav . PrevButton (), nav . NextButton (), nav . LastButton (), StopButtonDelete ()]","title":"get_default_buttons()"},{"location":"dev/menu/#utils.nav.navigator.ButtonNavigator.on_timeout","text":"Called when the view times out.","title":"on_timeout()"},{"location":"dev/menu/#utils.nav.navigator.ButtonNavigator.on_timeout--notes","text":"This adds the timeout button into the menu. Source code in utils\\nav\\navigator.py 73 74 75 76 77 78 79 80 81 82 async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout ()","title":"Notes"},{"location":"dev/menu/#utils.nav.navigator.timeout_button","text":"Return a NavButton to be use in nav.NavigatorView . This button is safe to use in miru.View . Returns: Type Description nav . NavButton The default timeout button. Source code in utils\\nav\\navigator.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def timeout_button () -> nav . NavButton : '''Return a `NavButton` to be use in `nav.NavigatorView`. This button is safe to use in `miru.View`. Returns ------- nav.NavButton The default timeout button. ''' return nav . NavButton ( style = hikari . ButtonStyle . SECONDARY , emoji = helpers . get_emote ( \":clock12:\" ), custom_id = \"timeout_button\" , disabled = True )","title":"timeout_button()"},{"location":"dev/menu/#navconfirmpy","text":"Contains a confirmation menu.","title":"nav/confirm.py"},{"location":"dev/menu/#utils.nav.confirm.ConfirmView","text":"Bases: miru . View A confirmation menu. Source code in utils\\nav\\confirm.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class ConfirmView ( miru . View ): ''' A confirmation menu. ''' def __init__ ( self , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None : super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . result : t . Optional [ bool ] = None @miru . button ( label = \"Yes\" , emoji = helpers . get_emote ( \":white_check_mark:\" ), style = hikari . ButtonStyle . SUCCESS , custom_id = \"yes_button\" ) async def yes_button ( self , _ : miru . Button , __ : miru . Context ): self . result = True self . stop () @miru . button ( label = \"No\" , emoji = helpers . get_emote ( \":negative_squared_cross_mark:\" ), style = hikari . ButtonStyle . DANGER , custom_id = \"no_button\" ) async def no_button ( self , _ : miru . Button , __ : miru . Context ): self . result = False self . stop () async def wait ( self ) -> t . Optional [ bool ]: ''' Wait until the view times out or stops manually. Return the result of the confirmation, or `None` if it times out. ''' await super () . wait () await self . message . delete () return self . result","title":"ConfirmView"},{"location":"dev/menu/#utils.nav.confirm.ConfirmView.wait","text":"Wait until the view times out or stops manually. Return the result of the confirmation, or None if it times out. Source code in utils\\nav\\confirm.py 27 28 29 30 31 32 33 34 35 36 async def wait ( self ) -> t . Optional [ bool ]: ''' Wait until the view times out or stops manually. Return the result of the confirmation, or `None` if it times out. ''' await super () . wait () await self . message . delete () return self . result","title":"wait()"},{"location":"dev/menu/#navmenupy","text":"Contains everything needed to build a complex menu.","title":"nav/menu.py"},{"location":"dev/menu/#utils.nav.menu.MenuComponent","text":"A tree-like node that represents the menu's option structure. The node has two \"states\": a regular node state and a fake node. A regular node state is when the options is a dictionary, which will determine the child nodes. A fake node state is when the options is a list of contents to display. In this case, the node's content is set to None , and no further child nodes can be created from this node. The child nodes can be accessed using dictionary notation IF there are child nodes. Source code in utils\\nav\\menu.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class MenuComponent : ''' A tree-like node that represents the menu's option structure. The node has two \"states\": a regular node state and a fake node. A regular node state is when the `options` is a dictionary, which will determine the child nodes. A fake node state is when the `options` is a list of contents to display. In this case, the node's content is set to `None`, and no further child nodes can be created from this node. The child nodes can be accessed using dictionary notation IF there are child nodes. ''' def __init__ ( self , content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ): ''' Create a node that stores the content and optionally, its options. The `options` can be a list, which will set the content to `None` regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a `dict` through `options`, but instead, use `.add_options()`. ''' self . content = content self . options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = options self . __parent__ : t . Optional [ MenuComponent ] = None if isinstance ( self . options , list ): self . content = None def add_option ( self , key : MenuButton , content : PageLike ) -> MenuComponent : '''Add an option into the current node. Return the newly added node to further add more layers. Warnings -------- The returned object is the newly added object, not the current object. Parameters ---------- key : MenuButton The button for the new option. content : PageLike The content of the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. ''' if isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) if self . options is None : self . options = { key : MenuComponent ( content )} self . options [ key ] . __parent__ = self return self . options [ key ] elif self . options . get ( key ) is None : component = MenuComponent ( content ) component . __parent__ = self self . options [ key ] = component return self . options [ key ] else : raise LookupError ( \"Duplicated keys.\" ) def add_options ( self , options : t . Dict [ MenuButton , PageLike ]): '''Add multiple options into the current node. Warnings -------- This will overwrite any possible duplicate keys. Parameters ---------- options : t.Dict[MenuButton, PageLike] A mapping of {button: content}. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) for key in options : self . options [ key ] = MenuComponent ( options [ key ]) self . options [ key ] . __parent__ = self def add_list_options ( self , key : str , contents : t . List [ PageLike ]) -> MenuComponent : '''Append a fake node to this node. Return the newly added node to do whatever you want. Parameters ---------- key : str The button for the new option. contents : t.List[PageLike] A list of content for the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) component = None if len ( contents ) == 1 : component = MenuComponent ( content = contents [ 0 ]) else : component = MenuComponent ( content = None , options = contents ) component . __parent__ = self self . options [ key ] = component return component def force_add_list_options ( self , contents : t . List [ PageLike ]): '''Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters ---------- contents : t.List[PageLike] A list of content for the option. ''' if self . options is None : self . options = [] for content in contents : self . options . append ( content ) self . content = None def __getitem__ ( self , key : MenuButton ) -> t . Optional [ MenuComponent ]: '''Return the MenuComponent with the matching key, or `None` if none was found. Parameters ---------- key : MenuButton The option you're retrieving. Returns ------- t.Optional[MenuComponent] The option with matching key, or `None` if none was found. Raises ------ IndexError The current MenuComponent is already a fake node. ''' if isinstance ( self . options , dict ): return self . options . get ( key ) raise IndexError ( \"Index doesn't exist.\" )","title":"MenuComponent"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.__init__","text":"Create a node that stores the content and optionally, its options. The options can be a list, which will set the content to None regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a dict through options , but instead, use .add_options() . Source code in utils\\nav\\menu.py 26 27 28 29 30 31 32 33 34 35 36 37 38 def __init__ ( self , content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ): ''' Create a node that stores the content and optionally, its options. The `options` can be a list, which will set the content to `None` regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a `dict` through `options`, but instead, use `.add_options()`. ''' self . content = content self . options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = options self . __parent__ : t . Optional [ MenuComponent ] = None if isinstance ( self . options , list ): self . content = None","title":"__init__()"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.add_option","text":"Add an option into the current node. Return the newly added node to further add more layers.","title":"add_option()"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.add_option--warnings","text":"The returned object is the newly added object, not the current object. Parameters: Name Type Description Default key MenuButton The button for the new option. required content PageLike The content of the new option. required Returns: Type Description MenuComponent The newly added option. Raises: Type Description KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. Source code in utils\\nav\\menu.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def add_option ( self , key : MenuButton , content : PageLike ) -> MenuComponent : '''Add an option into the current node. Return the newly added node to further add more layers. Warnings -------- The returned object is the newly added object, not the current object. Parameters ---------- key : MenuButton The button for the new option. content : PageLike The content of the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. ''' if isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) if self . options is None : self . options = { key : MenuComponent ( content )} self . options [ key ] . __parent__ = self return self . options [ key ] elif self . options . get ( key ) is None : component = MenuComponent ( content ) component . __parent__ = self self . options [ key ] = component return self . options [ key ] else : raise LookupError ( \"Duplicated keys.\" )","title":"Warnings"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.add_options","text":"Add multiple options into the current node.","title":"add_options()"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.add_options--warnings","text":"This will overwrite any possible duplicate keys. Parameters: Name Type Description Default options t . Dict [ MenuButton , PageLike ] A mapping of {button: content}. required Raises: Type Description KeyError The current MenuComponent is already a fake node. Source code in utils\\nav\\menu.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def add_options ( self , options : t . Dict [ MenuButton , PageLike ]): '''Add multiple options into the current node. Warnings -------- This will overwrite any possible duplicate keys. Parameters ---------- options : t.Dict[MenuButton, PageLike] A mapping of {button: content}. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) for key in options : self . options [ key ] = MenuComponent ( options [ key ]) self . options [ key ] . __parent__ = self","title":"Warnings"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.add_list_options","text":"Append a fake node to this node. Return the newly added node to do whatever you want. Parameters: Name Type Description Default key str The button for the new option. required contents t . List [ PageLike ] A list of content for the new option. required Returns: Type Description MenuComponent The newly added option. Raises: Type Description KeyError The current MenuComponent is already a fake node. Source code in utils\\nav\\menu.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def add_list_options ( self , key : str , contents : t . List [ PageLike ]) -> MenuComponent : '''Append a fake node to this node. Return the newly added node to do whatever you want. Parameters ---------- key : str The button for the new option. contents : t.List[PageLike] A list of content for the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) component = None if len ( contents ) == 1 : component = MenuComponent ( content = contents [ 0 ]) else : component = MenuComponent ( content = None , options = contents ) component . __parent__ = self self . options [ key ] = component return component","title":"add_list_options()"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.force_add_list_options","text":"Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters: Name Type Description Default contents t . List [ PageLike ] A list of content for the option. required Source code in utils\\nav\\menu.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def force_add_list_options ( self , contents : t . List [ PageLike ]): '''Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters ---------- contents : t.List[PageLike] A list of content for the option. ''' if self . options is None : self . options = [] for content in contents : self . options . append ( content ) self . content = None","title":"force_add_list_options()"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.__getitem__","text":"Return the MenuComponent with the matching key, or None if none was found. Parameters: Name Type Description Default key MenuButton The option you're retrieving. required Returns: Type Description t . Optional [ MenuComponent ] The option with matching key, or None if none was found. Raises: Type Description IndexError The current MenuComponent is already a fake node. Source code in utils\\nav\\menu.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def __getitem__ ( self , key : MenuButton ) -> t . Optional [ MenuComponent ]: '''Return the MenuComponent with the matching key, or `None` if none was found. Parameters ---------- key : MenuButton The option you're retrieving. Returns ------- t.Optional[MenuComponent] The option with matching key, or `None` if none was found. Raises ------ IndexError The current MenuComponent is already a fake node. ''' if isinstance ( self . options , dict ): return self . options . get ( key ) raise IndexError ( \"Index doesn't exist.\" )","title":"__getitem__()"},{"location":"dev/menu/#utils.nav.menu.MenuButton","text":"Bases: miru . Button Represents a generic button inside ComplexView . This should only be used in ComplexView . Source code in utils\\nav\\menu.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 class MenuButton ( miru . Button ): '''Represents a generic button inside `ComplexView`. This should only be used in `ComplexView`.''' async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the option if the current `MenuComponent` is not a fake node. ''' view : ComplexView = self . view if isinstance ( view . menu . options , dict ): view . menu = view . menu . options [ self ] await view . update ()","title":"MenuButton"},{"location":"dev/menu/#utils.nav.menu.MenuButton.callback","text":"Calls when the button is pressed. It'll move to the option if the current MenuComponent is not a fake node. Source code in utils\\nav\\menu.py 186 187 188 189 190 191 192 193 194 195 196 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the option if the current `MenuComponent` is not a fake node. ''' view : ComplexView = self . view if isinstance ( view . menu . options , dict ): view . menu = view . menu . options [ self ] await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.ReturnMenuButton","text":"Bases: MenuButton Represents a return button. Source code in utils\\nav\\menu.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 class ReturnMenuButton ( MenuButton ): '''Represents a return button.''' def __init__ ( self ) -> None : super () . __init__ ( style = hikari . ButtonStyle . SECONDARY , emoji = helpers . get_emote ( \":arrow_up_small:\" ), custom_id = \"return_button\" ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the parent node if it is not `None`. Raises ------ RuntimeError The return button is in the root menu. ''' view : ComplexView = self . view if view . menu . __parent__ is not None : view . menu = view . menu . __parent__ view . current_page = 0 else : raise RuntimeError ( \"A return button is available in the root menu.\" ) await view . update ()","title":"ReturnMenuButton"},{"location":"dev/menu/#utils.nav.menu.ReturnMenuButton.callback","text":"Calls when the button is pressed. It'll move to the parent node if it is not None . Raises: Type Description RuntimeError The return button is in the root menu. Source code in utils\\nav\\menu.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the parent node if it is not `None`. Raises ------ RuntimeError The return button is in the root menu. ''' view : ComplexView = self . view if view . menu . __parent__ is not None : view . menu = view . menu . __parent__ view . current_page = 0 else : raise RuntimeError ( \"A return button is available in the root menu.\" ) await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.StopMenuButton","text":"Bases: MenuButton Represents a terminate button. Source code in utils\\nav\\menu.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 class StopMenuButton ( MenuButton ): '''Represents a terminate button.''' def __init__ ( self ) -> None : super () . __init__ ( style = hikari . ButtonStyle . DANGER , emoji = helpers . get_emote ( \":stop_button:\" ), custom_id = \"stop_button\" ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll stop the `ComplexView` and delete the menu. ''' view : ComplexView = self . view view . stop () if view . message : await view . message . delete ()","title":"StopMenuButton"},{"location":"dev/menu/#utils.nav.menu.StopMenuButton.callback","text":"Calls when the button is pressed. It'll stop the ComplexView and delete the menu. Source code in utils\\nav\\menu.py 236 237 238 239 240 241 242 243 244 245 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll stop the `ComplexView` and delete the menu. ''' view : ComplexView = self . view view . stop () if view . message : await view . message . delete ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.NextMenuButton","text":"Bases: MenuButton A button to move to the next page list. This behaves similarly to nav.NextButton() . Source code in utils\\nav\\menu.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 class NextMenuButton ( MenuButton ): '''A button to move to the next page list. This behaves similarly to `nav.NextButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"next_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":arrow_forward:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. ''' view : ComplexView = self . view view . current_page += 1 if view . current_page > len ( view . menu . options ) - 1 : view . current_page = 0 await view . update ()","title":"NextMenuButton"},{"location":"dev/menu/#utils.nav.menu.NextMenuButton.callback","text":"Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. Source code in utils\\nav\\menu.py 262 263 264 265 266 267 268 269 270 271 272 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. ''' view : ComplexView = self . view view . current_page += 1 if view . current_page > len ( view . menu . options ) - 1 : view . current_page = 0 await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.PrevMenuButton","text":"Bases: MenuButton A button to move to the previous page list. This behaves similarly to nav.PrevButton() . Source code in utils\\nav\\menu.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 class PrevMenuButton ( MenuButton ): '''A button to move to the previous page list. This behaves similarly to `nav.PrevButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"prev_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":arrow_backward:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. ''' view : ComplexView = self . view view . current_page -= 1 if view . current_page < 0 : view . current_page = len ( view . menu . options ) - 1 await view . update ()","title":"PrevMenuButton"},{"location":"dev/menu/#utils.nav.menu.PrevMenuButton.callback","text":"Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. Source code in utils\\nav\\menu.py 289 290 291 292 293 294 295 296 297 298 299 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. ''' view : ComplexView = self . view view . current_page -= 1 if view . current_page < 0 : view . current_page = len ( view . menu . options ) - 1 await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.FirstMenuButton","text":"Bases: MenuButton A button to move to the first page list. This behaves similarly to nav.FirstButton() . Source code in utils\\nav\\menu.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 class FirstMenuButton ( MenuButton ): '''A button to move to the first page list. This behaves similarly to `nav.FirstButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"first_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":last_track_button:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the first page. ''' view : ComplexView = self . view view . current_page = 0 await view . update ()","title":"FirstMenuButton"},{"location":"dev/menu/#utils.nav.menu.FirstMenuButton.callback","text":"Calls when the button is pressed. Move to the first page. Source code in utils\\nav\\menu.py 316 317 318 319 320 321 322 323 324 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the first page. ''' view : ComplexView = self . view view . current_page = 0 await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.LastMenuButton","text":"Bases: MenuButton A button to move to the last page list. This behaves similarly to nav.LastButton() . Source code in utils\\nav\\menu.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 class LastMenuButton ( MenuButton ): '''A button to move to the last page list. This behaves similarly to `nav.LastButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"last_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":next_track_button:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the last page. ''' view : ComplexView = self . view view . current_page = len ( view . menu . options ) - 1 await view . update ()","title":"LastMenuButton"},{"location":"dev/menu/#utils.nav.menu.LastMenuButton.callback","text":"Calls when the button is pressed. Move to the last page. Source code in utils\\nav\\menu.py 341 342 343 344 345 346 347 348 349 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the last page. ''' view : ComplexView = self . view view . current_page = len ( view . menu . options ) - 1 await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.ComplexView","text":"Bases: miru . View A complex menu. Source code in utils\\nav\\menu.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 class ComplexView ( miru . View ): '''A complex menu.''' def __init__ ( self , menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None : '''Construct a complex menu. Parameters ---------- menu : MenuComponent A `MenuComponent` tree. This must be a root node. timeout : t.Optional[float], optional How long (in seconds) the menu should accept interactions. Default to `120`. autodefer : bool, optional Whether or not the menu should defer when possible. Default to `True`. ''' super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . menu = menu # For list menu self . current_page : int = 0 def _update_button ( self ) -> None : ''' Update the button based on the current menu state. ''' self . clear_items () if isinstance ( self . menu . options , dict ): for button in self . menu . options : self . add_item ( button ) elif isinstance ( self . menu . options , list ): # TODO: Might optimize this so it wouldn't reset the buttons. self . add_item ( FirstMenuButton ()) self . add_item ( PrevMenuButton ()) self . add_item ( NextMenuButton ()) self . add_item ( LastMenuButton ()) for index , item in enumerate ( self . menu . options ): if isinstance ( item , hikari . Embed ): item . set_footer ( f \"Page { index + 1 } / { len ( self . menu . options ) } \" ) if self . menu . __parent__ is None : self . add_item ( StopMenuButton ()) else : self . add_item ( ReturnMenuButton ()) async def update ( self ) -> None : '''Update the menu. This shouldn't be called by the user. Raises ------ RuntimeError The message is not found (for unknown reasons). Notes ----- All `MenuButton` should call this method inside their callbacks once it's done with everything. ''' self . _update_button () content = self . menu . content # If view is in a list menu. Can also check if menu.content is None instead. if isinstance ( self . menu . options , list ): content = self . menu . options [ self . current_page ] if self . message : await self . message . edit ( content , components = self . build ()) else : raise RuntimeError ( \"Oops ComplexView.update() failed.\" ) async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout () async def run ( self , ctx : lightbulb . Context ) -> None : '''Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters ---------- ctx : lightbulb.Context A `lightbulb` context. ''' self . _update_button () resp_proxy = await ctx . respond ( self . menu . content , components = self . build ()) self . start ( await resp_proxy . message ()) await self . wait ()","title":"ComplexView"},{"location":"dev/menu/#utils.nav.menu.ComplexView.__init__","text":"Construct a complex menu. Parameters: Name Type Description Default menu MenuComponent A MenuComponent tree. This must be a root node. required timeout t . Optional [ float ], optional How long (in seconds) the menu should accept interactions. Default to 120 . 120 autodefer bool , optional Whether or not the menu should defer when possible. Default to True . True Source code in utils\\nav\\menu.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 def __init__ ( self , menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None : '''Construct a complex menu. Parameters ---------- menu : MenuComponent A `MenuComponent` tree. This must be a root node. timeout : t.Optional[float], optional How long (in seconds) the menu should accept interactions. Default to `120`. autodefer : bool, optional Whether or not the menu should defer when possible. Default to `True`. ''' super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . menu = menu # For list menu self . current_page : int = 0","title":"__init__()"},{"location":"dev/menu/#utils.nav.menu.ComplexView.update","text":"Update the menu. This shouldn't be called by the user. Raises: Type Description RuntimeError The message is not found (for unknown reasons).","title":"update()"},{"location":"dev/menu/#utils.nav.menu.ComplexView.update--notes","text":"All MenuButton should call this method inside their callbacks once it's done with everything. Source code in utils\\nav\\menu.py 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 async def update ( self ) -> None : '''Update the menu. This shouldn't be called by the user. Raises ------ RuntimeError The message is not found (for unknown reasons). Notes ----- All `MenuButton` should call this method inside their callbacks once it's done with everything. ''' self . _update_button () content = self . menu . content # If view is in a list menu. Can also check if menu.content is None instead. if isinstance ( self . menu . options , list ): content = self . menu . options [ self . current_page ] if self . message : await self . message . edit ( content , components = self . build ()) else : raise RuntimeError ( \"Oops ComplexView.update() failed.\" )","title":"Notes"},{"location":"dev/menu/#utils.nav.menu.ComplexView.on_timeout","text":"Called when the view times out.","title":"on_timeout()"},{"location":"dev/menu/#utils.nav.menu.ComplexView.on_timeout--notes","text":"This adds the timeout button into the menu. Source code in utils\\nav\\menu.py 421 422 423 424 425 426 427 428 429 430 async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout ()","title":"Notes"},{"location":"dev/menu/#utils.nav.menu.ComplexView.run","text":"Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters: Name Type Description Default ctx lightbulb . Context A lightbulb context. required Source code in utils\\nav\\menu.py 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 async def run ( self , ctx : lightbulb . Context ) -> None : '''Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters ---------- ctx : lightbulb.Context A `lightbulb` context. ''' self . _update_button () resp_proxy = await ctx . respond ( self . menu . content , components = self . build ()) self . start ( await resp_proxy . message ()) await self . wait ()","title":"run()"},{"location":"dev/models/","text":"Contains many data structures, including the customized MichaelBot class. UserCache Represent a user data in the database. This contains one module: user_module : Represent the Users table. Source code in utils\\models.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class UserCache : ''' Represent a user data in the database. This contains one module: - `user_module`: Represent the `Users` table. ''' def __init__ ( self , user_module : dict = None ): if user_module is None : user_module = {} else : user_module . pop ( \"id\" , None ) self . user_module = user_module async def add_user_module ( self , conn , user : hikari . User ): ''' Add a user into the cache and the database. ''' await psql . Users . add_one ( conn , user . id , user . username ) user_info = await psql . Users . get_one ( conn , user . id ) self . user_module = user_info async def update_user_module ( self , conn , user_id : int , column : str , new_value ): ''' Edit a user data in the cache and the database. ''' await psql . Users . update_column ( conn , user_id , column , new_value ) self . user_module [ column ] = new_value async def force_sync ( self , conn , user_id : int ): ''' Force this object to update with database. If the method returns `None`, the entry for this user isn't on the database, thus you should use `add_user_module()` instead. Otherwise, it returns itself. ''' user = await psql . Users . get_one ( conn , user_id ) if user is None : return None else : user . pop ( \"id\" , None ) self . user_module = user return self add_user_module ( conn , user : hikari . User ) async Add a user into the cache and the database. Source code in utils\\models.py 32 33 34 35 36 37 38 async def add_user_module ( self , conn , user : hikari . User ): ''' Add a user into the cache and the database. ''' await psql . Users . add_one ( conn , user . id , user . username ) user_info = await psql . Users . get_one ( conn , user . id ) self . user_module = user_info update_user_module ( conn , user_id : int , column : str , new_value ) async Edit a user data in the cache and the database. Source code in utils\\models.py 39 40 41 42 43 44 async def update_user_module ( self , conn , user_id : int , column : str , new_value ): ''' Edit a user data in the cache and the database. ''' await psql . Users . update_column ( conn , user_id , column , new_value ) self . user_module [ column ] = new_value force_sync ( conn , user_id : int ) async Force this object to update with database. If the method returns None , the entry for this user isn't on the database, thus you should use add_user_module() instead. Otherwise, it returns itself. Source code in utils\\models.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 async def force_sync ( self , conn , user_id : int ): ''' Force this object to update with database. If the method returns `None`, the entry for this user isn't on the database, thus you should use `add_user_module()` instead. Otherwise, it returns itself. ''' user = await psql . Users . get_one ( conn , user_id ) if user is None : return None else : user . pop ( \"id\" , None ) self . user_module = user return self GuildCache Represent a guild data in the database. This contains two module: guild_module : Represent the Guilds table. logging_module : Represent the GuildsLogs table. Source code in utils\\models.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 class GuildCache : ''' Represent a guild data in the database. This contains two module: - `guild_module`: Represent the `Guilds` table. - `logging_module`: Represent the `GuildsLogs` table. ''' def __init__ ( self , guild_module : dict = None , logging_module : dict = None ): if guild_module is None : guild_module = {} else : guild_module . pop ( \"id\" , None ) if logging_module is None : logging_module = {} else : logging_module . pop ( \"guild_id\" , None ) self . guild_module = guild_module self . logging_module = logging_module async def add_guild_module ( self , conn , guild : hikari . Guild ): ''' Add a guild module into the cache and the database. ''' await psql . Guilds . add_one ( conn , guild ) guild_info = await psql . Guilds . get_one ( conn , guild . id ) self . guild_module = guild_info async def update_guild_module ( self , conn , guild_id : int , column : str , new_value ): ''' Edit a guild module data in the cache and the database. ''' await psql . Guilds . update_column ( conn , guild_id , column , new_value ) self . guild_module [ column ] = new_value async def add_logging_module ( self , conn , guild : hikari . Guild ): ''' Add a logging module into the cache and the database. ''' await psql . GuildsLogs . add_one ( conn , guild ) logging_info = await psql . GuildsLogs . get_one ( conn , guild . id ) self . logging_module = logging_info async def update_logging_module ( self , conn , guild_id : int , column : str , new_value ): ''' Update a logging module in the cache and the database. ''' await psql . GuildsLogs . update_column ( conn , guild_id , column , new_value ) self . logging_module [ column ] = new_value async def force_sync ( self , conn , guild_id : int ): ''' Force this object to update with database. If the method returns `None`, the entry for this guild isn't on the database, thus you should use `add_guild_module()` instead. Otherwise, it returns itself. ''' guild = await psql . Guilds . get_one ( conn , guild_id ) if guild is None : return None else : guild . pop ( \"id\" , None ) guild_log = await psql . GuildsLogs . get_one ( conn , guild_id ) if guild_log is None : guild_log = {} else : guild_log . pop ( \"guild_id\" , None ) self . guild_module = guild self . logging_module = guild_log return self add_guild_module ( conn , guild : hikari . Guild ) async Add a guild module into the cache and the database. Source code in utils\\models.py 85 86 87 88 89 90 91 async def add_guild_module ( self , conn , guild : hikari . Guild ): ''' Add a guild module into the cache and the database. ''' await psql . Guilds . add_one ( conn , guild ) guild_info = await psql . Guilds . get_one ( conn , guild . id ) self . guild_module = guild_info update_guild_module ( conn , guild_id : int , column : str , new_value ) async Edit a guild module data in the cache and the database. Source code in utils\\models.py 93 94 95 96 97 98 async def update_guild_module ( self , conn , guild_id : int , column : str , new_value ): ''' Edit a guild module data in the cache and the database. ''' await psql . Guilds . update_column ( conn , guild_id , column , new_value ) self . guild_module [ column ] = new_value add_logging_module ( conn , guild : hikari . Guild ) async Add a logging module into the cache and the database. Source code in utils\\models.py 100 101 102 103 104 105 106 async def add_logging_module ( self , conn , guild : hikari . Guild ): ''' Add a logging module into the cache and the database. ''' await psql . GuildsLogs . add_one ( conn , guild ) logging_info = await psql . GuildsLogs . get_one ( conn , guild . id ) self . logging_module = logging_info update_logging_module ( conn , guild_id : int , column : str , new_value ) async Update a logging module in the cache and the database. Source code in utils\\models.py 108 109 110 111 112 113 async def update_logging_module ( self , conn , guild_id : int , column : str , new_value ): ''' Update a logging module in the cache and the database. ''' await psql . GuildsLogs . update_column ( conn , guild_id , column , new_value ) self . logging_module [ column ] = new_value force_sync ( conn , guild_id : int ) async Force this object to update with database. If the method returns None , the entry for this guild isn't on the database, thus you should use add_guild_module() instead. Otherwise, it returns itself. Source code in utils\\models.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 async def force_sync ( self , conn , guild_id : int ): ''' Force this object to update with database. If the method returns `None`, the entry for this guild isn't on the database, thus you should use `add_guild_module()` instead. Otherwise, it returns itself. ''' guild = await psql . Guilds . get_one ( conn , guild_id ) if guild is None : return None else : guild . pop ( \"id\" , None ) guild_log = await psql . GuildsLogs . get_one ( conn , guild_id ) if guild_log is None : guild_log = {} else : guild_log . pop ( \"guild_id\" , None ) self . guild_module = guild self . logging_module = guild_log return self DefaultColor Bases: Enum Store several default colors to use instantly. Source code in utils\\models.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 class DefaultColor ( Enum ): ''' Store several default colors to use instantly. ''' teal = hikari . Color ( 0x1abc9c ) dark_teal = hikari . Color ( 0x11806a ) brand_green = hikari . Color ( 0x57F287 ) green = hikari . Color ( 0x2ecc71 ) dark_green = hikari . Color ( 0x1f8b4c ) blue = hikari . Color ( 0x3498db ) dark_blue = hikari . Color ( 0x206694 ) purple = hikari . Color ( 0x9b59b6 ) dark_purple = hikari . Color ( 0x71368a ) magenta = hikari . Color ( 0xe91e63 ) dark_magenta = hikari . Color ( 0xad1457 ) gold = hikari . Color ( 0xf1c40f ) dark_gold = hikari . Color ( 0xc27c0e ) orange = hikari . Color ( 0xe67e22 ) dark_orange = hikari . Color ( 0xa84300 ) brand_red = hikari . Color ( 0xED4245 ) red = hikari . Color ( 0xe74c3c ) dark_red = hikari . Color ( 0x992d22 ) lighter_gray = hikari . Color ( 0x95a5a6 ) dark_gray = hikari . Color ( 0x607d8b ) light_gray = hikari . Color ( 0x979c9f ) darker_gray = hikari . Color ( 0x546e7a ) og_blurple = hikari . Color ( 0x7289da ) blurple = hikari . Color ( 0x5865F2 ) greyple = hikari . Color ( 0x5865F2 ) dark_theme = hikari . Color ( 0x36393F ) fuchsia = hikari . Color ( 0xEB459E ) yellow = hikari . Color ( 0xFEE75C ) black = hikari . Color ( 0x000000 ) white = hikari . Color ( 0xFFFFFF ) NodeExtra dataclass A class to store extra data for the lavaplayer.Node Source code in utils\\models.py 175 176 177 178 179 @dataclass class NodeExtra : '''A class to store extra data for the `lavaplayer.Node`''' queue_loop : bool = False working_channel : int = 0 MichaelBot Bases: lightbulb . BotApp A subclass of lightbulb.BotApp . This allows syntax highlight on many custom attributes. Source code in utils\\models.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 class MichaelBot ( lightbulb . BotApp ): '''A subclass of `lightbulb.BotApp`. This allows syntax highlight on many custom attributes.''' __slots__ = ( \"info\" , \"secrets\" , \"online_at\" , \"logging\" , \"pool\" , \"aio_session\" , \"guild_cache\" , \"user_cache\" , \"lavalink\" , \"node_extra\" ) def __init__ ( self , token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None : ''' Parameters ----------------- info : dict The bot info. Store the one in `config.json`. secrets : dict The bot's secrets such as token, database info, etc. ''' self . info : dict = kwargs . pop ( \"info\" ) self . secrets : dict = kwargs . pop ( \"secrets\" ) self . online_at : dt . datetime = None self . pool : t . Optional [ asyncpg . Pool ] = None self . aio_session : t . Optional [ aiohttp . ClientSession ] = None # Store some db info. This allows read-only operation much cheaper. self . guild_cache : dict [ int , GuildCache ] = {} self . user_cache : dict [ int , UserCache ] = {} self . lavalink : t . Optional [ lavaplayer . LavalinkClient ] = None # Currently lavaplayer doesn't support adding attr to lavaplayer.objects.Node # so we'll make a dictionary to manually track additional info. self . node_extra : dict [ int , NodeExtra ] = {} launch_options = self . info . get ( \"launch_options\" ) log_level = \"INFO\" if launch_options is None : launch_options = \"\" for option in launch_options . split (): if option in [ \"--debug\" , \"-d\" ]: default_enabled_guilds = self . info [ \"default_guilds\" ] log_level = \"DEBUG\" if option in [ \"--quiet\" , \"-q\" ]: log_level = \"\" super () . __init__ ( token , prefix , ignore_bots , owner_ids , default_enabled_guilds , help_class , help_slash_command , delete_unbound_commands , case_insensitive_prefix_commands , logs = log_level if bool ( log_level ) else None , ** kwargs ) def get_slash_command ( self , name : str ) -> t . Optional [ lightbulb . SlashCommand ]: '''Get the slash command with the given name, or `None` if none was found. Unlike the default behavior in `lightbulb.BotApp`, this also searches for subcommands. Parameters ---------- name : str The command name to search. Returns ------- t.Optional[lightbulb.SlashCommand] The slash command with that name, or `None` if none was found. ''' # Reference: https://hikari-lightbulb.readthedocs.io/en/latest/_modules/lightbulb/app.html#BotApp.get_prefix_command parts = name . split () if len ( parts ) == 1 : return self . _slash_commands . get ( name ) maybe_group = self . _slash_commands . get ( parts . pop ( 0 )) if not isinstance ( maybe_group , lightbulb . SlashCommandGroup ): return None this : t . Optional [ t . Union [ lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup , lightbulb . SlashSubCommand ] ] = maybe_group for part in parts : if this is None or isinstance ( this , lightbulb . SlashSubCommand ): return None this = this . get_subcommand ( part ) return this __init__ ( token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None Parameters: Name Type Description Default info dict The bot info. Store the one in config.json . required secrets dict The bot's secrets such as token, database info, etc. required Source code in utils\\models.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def __init__ ( self , token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None : ''' Parameters ----------------- info : dict The bot info. Store the one in `config.json`. secrets : dict The bot's secrets such as token, database info, etc. ''' self . info : dict = kwargs . pop ( \"info\" ) self . secrets : dict = kwargs . pop ( \"secrets\" ) self . online_at : dt . datetime = None self . pool : t . Optional [ asyncpg . Pool ] = None self . aio_session : t . Optional [ aiohttp . ClientSession ] = None # Store some db info. This allows read-only operation much cheaper. self . guild_cache : dict [ int , GuildCache ] = {} self . user_cache : dict [ int , UserCache ] = {} self . lavalink : t . Optional [ lavaplayer . LavalinkClient ] = None # Currently lavaplayer doesn't support adding attr to lavaplayer.objects.Node # so we'll make a dictionary to manually track additional info. self . node_extra : dict [ int , NodeExtra ] = {} launch_options = self . info . get ( \"launch_options\" ) log_level = \"INFO\" if launch_options is None : launch_options = \"\" for option in launch_options . split (): if option in [ \"--debug\" , \"-d\" ]: default_enabled_guilds = self . info [ \"default_guilds\" ] log_level = \"DEBUG\" if option in [ \"--quiet\" , \"-q\" ]: log_level = \"\" super () . __init__ ( token , prefix , ignore_bots , owner_ids , default_enabled_guilds , help_class , help_slash_command , delete_unbound_commands , case_insensitive_prefix_commands , logs = log_level if bool ( log_level ) else None , ** kwargs ) get_slash_command ( name : str ) -> t . Optional [ lightbulb . SlashCommand ] Get the slash command with the given name, or None if none was found. Unlike the default behavior in lightbulb.BotApp , this also searches for subcommands. Parameters: Name Type Description Default name str The command name to search. required Returns: Type Description t . Optional [ lightbulb . SlashCommand ] The slash command with that name, or None if none was found. Source code in utils\\models.py 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 def get_slash_command ( self , name : str ) -> t . Optional [ lightbulb . SlashCommand ]: '''Get the slash command with the given name, or `None` if none was found. Unlike the default behavior in `lightbulb.BotApp`, this also searches for subcommands. Parameters ---------- name : str The command name to search. Returns ------- t.Optional[lightbulb.SlashCommand] The slash command with that name, or `None` if none was found. ''' # Reference: https://hikari-lightbulb.readthedocs.io/en/latest/_modules/lightbulb/app.html#BotApp.get_prefix_command parts = name . split () if len ( parts ) == 1 : return self . _slash_commands . get ( name ) maybe_group = self . _slash_commands . get ( parts . pop ( 0 )) if not isinstance ( maybe_group , lightbulb . SlashCommandGroup ): return None this : t . Optional [ t . Union [ lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup , lightbulb . SlashSubCommand ] ] = maybe_group for part in parts : if this is None or isinstance ( this , lightbulb . SlashSubCommand ): return None this = this . get_subcommand ( part ) return this","title":"models.py"},{"location":"dev/models/#utils.models.UserCache","text":"Represent a user data in the database. This contains one module: user_module : Represent the Users table. Source code in utils\\models.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class UserCache : ''' Represent a user data in the database. This contains one module: - `user_module`: Represent the `Users` table. ''' def __init__ ( self , user_module : dict = None ): if user_module is None : user_module = {} else : user_module . pop ( \"id\" , None ) self . user_module = user_module async def add_user_module ( self , conn , user : hikari . User ): ''' Add a user into the cache and the database. ''' await psql . Users . add_one ( conn , user . id , user . username ) user_info = await psql . Users . get_one ( conn , user . id ) self . user_module = user_info async def update_user_module ( self , conn , user_id : int , column : str , new_value ): ''' Edit a user data in the cache and the database. ''' await psql . Users . update_column ( conn , user_id , column , new_value ) self . user_module [ column ] = new_value async def force_sync ( self , conn , user_id : int ): ''' Force this object to update with database. If the method returns `None`, the entry for this user isn't on the database, thus you should use `add_user_module()` instead. Otherwise, it returns itself. ''' user = await psql . Users . get_one ( conn , user_id ) if user is None : return None else : user . pop ( \"id\" , None ) self . user_module = user return self","title":"UserCache"},{"location":"dev/models/#utils.models.UserCache.add_user_module","text":"Add a user into the cache and the database. Source code in utils\\models.py 32 33 34 35 36 37 38 async def add_user_module ( self , conn , user : hikari . User ): ''' Add a user into the cache and the database. ''' await psql . Users . add_one ( conn , user . id , user . username ) user_info = await psql . Users . get_one ( conn , user . id ) self . user_module = user_info","title":"add_user_module()"},{"location":"dev/models/#utils.models.UserCache.update_user_module","text":"Edit a user data in the cache and the database. Source code in utils\\models.py 39 40 41 42 43 44 async def update_user_module ( self , conn , user_id : int , column : str , new_value ): ''' Edit a user data in the cache and the database. ''' await psql . Users . update_column ( conn , user_id , column , new_value ) self . user_module [ column ] = new_value","title":"update_user_module()"},{"location":"dev/models/#utils.models.UserCache.force_sync","text":"Force this object to update with database. If the method returns None , the entry for this user isn't on the database, thus you should use add_user_module() instead. Otherwise, it returns itself. Source code in utils\\models.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 async def force_sync ( self , conn , user_id : int ): ''' Force this object to update with database. If the method returns `None`, the entry for this user isn't on the database, thus you should use `add_user_module()` instead. Otherwise, it returns itself. ''' user = await psql . Users . get_one ( conn , user_id ) if user is None : return None else : user . pop ( \"id\" , None ) self . user_module = user return self","title":"force_sync()"},{"location":"dev/models/#utils.models.GuildCache","text":"Represent a guild data in the database. This contains two module: guild_module : Represent the Guilds table. logging_module : Represent the GuildsLogs table. Source code in utils\\models.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 class GuildCache : ''' Represent a guild data in the database. This contains two module: - `guild_module`: Represent the `Guilds` table. - `logging_module`: Represent the `GuildsLogs` table. ''' def __init__ ( self , guild_module : dict = None , logging_module : dict = None ): if guild_module is None : guild_module = {} else : guild_module . pop ( \"id\" , None ) if logging_module is None : logging_module = {} else : logging_module . pop ( \"guild_id\" , None ) self . guild_module = guild_module self . logging_module = logging_module async def add_guild_module ( self , conn , guild : hikari . Guild ): ''' Add a guild module into the cache and the database. ''' await psql . Guilds . add_one ( conn , guild ) guild_info = await psql . Guilds . get_one ( conn , guild . id ) self . guild_module = guild_info async def update_guild_module ( self , conn , guild_id : int , column : str , new_value ): ''' Edit a guild module data in the cache and the database. ''' await psql . Guilds . update_column ( conn , guild_id , column , new_value ) self . guild_module [ column ] = new_value async def add_logging_module ( self , conn , guild : hikari . Guild ): ''' Add a logging module into the cache and the database. ''' await psql . GuildsLogs . add_one ( conn , guild ) logging_info = await psql . GuildsLogs . get_one ( conn , guild . id ) self . logging_module = logging_info async def update_logging_module ( self , conn , guild_id : int , column : str , new_value ): ''' Update a logging module in the cache and the database. ''' await psql . GuildsLogs . update_column ( conn , guild_id , column , new_value ) self . logging_module [ column ] = new_value async def force_sync ( self , conn , guild_id : int ): ''' Force this object to update with database. If the method returns `None`, the entry for this guild isn't on the database, thus you should use `add_guild_module()` instead. Otherwise, it returns itself. ''' guild = await psql . Guilds . get_one ( conn , guild_id ) if guild is None : return None else : guild . pop ( \"id\" , None ) guild_log = await psql . GuildsLogs . get_one ( conn , guild_id ) if guild_log is None : guild_log = {} else : guild_log . pop ( \"guild_id\" , None ) self . guild_module = guild self . logging_module = guild_log return self","title":"GuildCache"},{"location":"dev/models/#utils.models.GuildCache.add_guild_module","text":"Add a guild module into the cache and the database. Source code in utils\\models.py 85 86 87 88 89 90 91 async def add_guild_module ( self , conn , guild : hikari . Guild ): ''' Add a guild module into the cache and the database. ''' await psql . Guilds . add_one ( conn , guild ) guild_info = await psql . Guilds . get_one ( conn , guild . id ) self . guild_module = guild_info","title":"add_guild_module()"},{"location":"dev/models/#utils.models.GuildCache.update_guild_module","text":"Edit a guild module data in the cache and the database. Source code in utils\\models.py 93 94 95 96 97 98 async def update_guild_module ( self , conn , guild_id : int , column : str , new_value ): ''' Edit a guild module data in the cache and the database. ''' await psql . Guilds . update_column ( conn , guild_id , column , new_value ) self . guild_module [ column ] = new_value","title":"update_guild_module()"},{"location":"dev/models/#utils.models.GuildCache.add_logging_module","text":"Add a logging module into the cache and the database. Source code in utils\\models.py 100 101 102 103 104 105 106 async def add_logging_module ( self , conn , guild : hikari . Guild ): ''' Add a logging module into the cache and the database. ''' await psql . GuildsLogs . add_one ( conn , guild ) logging_info = await psql . GuildsLogs . get_one ( conn , guild . id ) self . logging_module = logging_info","title":"add_logging_module()"},{"location":"dev/models/#utils.models.GuildCache.update_logging_module","text":"Update a logging module in the cache and the database. Source code in utils\\models.py 108 109 110 111 112 113 async def update_logging_module ( self , conn , guild_id : int , column : str , new_value ): ''' Update a logging module in the cache and the database. ''' await psql . GuildsLogs . update_column ( conn , guild_id , column , new_value ) self . logging_module [ column ] = new_value","title":"update_logging_module()"},{"location":"dev/models/#utils.models.GuildCache.force_sync","text":"Force this object to update with database. If the method returns None , the entry for this guild isn't on the database, thus you should use add_guild_module() instead. Otherwise, it returns itself. Source code in utils\\models.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 async def force_sync ( self , conn , guild_id : int ): ''' Force this object to update with database. If the method returns `None`, the entry for this guild isn't on the database, thus you should use `add_guild_module()` instead. Otherwise, it returns itself. ''' guild = await psql . Guilds . get_one ( conn , guild_id ) if guild is None : return None else : guild . pop ( \"id\" , None ) guild_log = await psql . GuildsLogs . get_one ( conn , guild_id ) if guild_log is None : guild_log = {} else : guild_log . pop ( \"guild_id\" , None ) self . guild_module = guild self . logging_module = guild_log return self","title":"force_sync()"},{"location":"dev/models/#utils.models.DefaultColor","text":"Bases: Enum Store several default colors to use instantly. Source code in utils\\models.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 class DefaultColor ( Enum ): ''' Store several default colors to use instantly. ''' teal = hikari . Color ( 0x1abc9c ) dark_teal = hikari . Color ( 0x11806a ) brand_green = hikari . Color ( 0x57F287 ) green = hikari . Color ( 0x2ecc71 ) dark_green = hikari . Color ( 0x1f8b4c ) blue = hikari . Color ( 0x3498db ) dark_blue = hikari . Color ( 0x206694 ) purple = hikari . Color ( 0x9b59b6 ) dark_purple = hikari . Color ( 0x71368a ) magenta = hikari . Color ( 0xe91e63 ) dark_magenta = hikari . Color ( 0xad1457 ) gold = hikari . Color ( 0xf1c40f ) dark_gold = hikari . Color ( 0xc27c0e ) orange = hikari . Color ( 0xe67e22 ) dark_orange = hikari . Color ( 0xa84300 ) brand_red = hikari . Color ( 0xED4245 ) red = hikari . Color ( 0xe74c3c ) dark_red = hikari . Color ( 0x992d22 ) lighter_gray = hikari . Color ( 0x95a5a6 ) dark_gray = hikari . Color ( 0x607d8b ) light_gray = hikari . Color ( 0x979c9f ) darker_gray = hikari . Color ( 0x546e7a ) og_blurple = hikari . Color ( 0x7289da ) blurple = hikari . Color ( 0x5865F2 ) greyple = hikari . Color ( 0x5865F2 ) dark_theme = hikari . Color ( 0x36393F ) fuchsia = hikari . Color ( 0xEB459E ) yellow = hikari . Color ( 0xFEE75C ) black = hikari . Color ( 0x000000 ) white = hikari . Color ( 0xFFFFFF )","title":"DefaultColor"},{"location":"dev/models/#utils.models.NodeExtra","text":"A class to store extra data for the lavaplayer.Node Source code in utils\\models.py 175 176 177 178 179 @dataclass class NodeExtra : '''A class to store extra data for the `lavaplayer.Node`''' queue_loop : bool = False working_channel : int = 0","title":"NodeExtra"},{"location":"dev/models/#utils.models.MichaelBot","text":"Bases: lightbulb . BotApp A subclass of lightbulb.BotApp . This allows syntax highlight on many custom attributes. Source code in utils\\models.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 class MichaelBot ( lightbulb . BotApp ): '''A subclass of `lightbulb.BotApp`. This allows syntax highlight on many custom attributes.''' __slots__ = ( \"info\" , \"secrets\" , \"online_at\" , \"logging\" , \"pool\" , \"aio_session\" , \"guild_cache\" , \"user_cache\" , \"lavalink\" , \"node_extra\" ) def __init__ ( self , token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None : ''' Parameters ----------------- info : dict The bot info. Store the one in `config.json`. secrets : dict The bot's secrets such as token, database info, etc. ''' self . info : dict = kwargs . pop ( \"info\" ) self . secrets : dict = kwargs . pop ( \"secrets\" ) self . online_at : dt . datetime = None self . pool : t . Optional [ asyncpg . Pool ] = None self . aio_session : t . Optional [ aiohttp . ClientSession ] = None # Store some db info. This allows read-only operation much cheaper. self . guild_cache : dict [ int , GuildCache ] = {} self . user_cache : dict [ int , UserCache ] = {} self . lavalink : t . Optional [ lavaplayer . LavalinkClient ] = None # Currently lavaplayer doesn't support adding attr to lavaplayer.objects.Node # so we'll make a dictionary to manually track additional info. self . node_extra : dict [ int , NodeExtra ] = {} launch_options = self . info . get ( \"launch_options\" ) log_level = \"INFO\" if launch_options is None : launch_options = \"\" for option in launch_options . split (): if option in [ \"--debug\" , \"-d\" ]: default_enabled_guilds = self . info [ \"default_guilds\" ] log_level = \"DEBUG\" if option in [ \"--quiet\" , \"-q\" ]: log_level = \"\" super () . __init__ ( token , prefix , ignore_bots , owner_ids , default_enabled_guilds , help_class , help_slash_command , delete_unbound_commands , case_insensitive_prefix_commands , logs = log_level if bool ( log_level ) else None , ** kwargs ) def get_slash_command ( self , name : str ) -> t . Optional [ lightbulb . SlashCommand ]: '''Get the slash command with the given name, or `None` if none was found. Unlike the default behavior in `lightbulb.BotApp`, this also searches for subcommands. Parameters ---------- name : str The command name to search. Returns ------- t.Optional[lightbulb.SlashCommand] The slash command with that name, or `None` if none was found. ''' # Reference: https://hikari-lightbulb.readthedocs.io/en/latest/_modules/lightbulb/app.html#BotApp.get_prefix_command parts = name . split () if len ( parts ) == 1 : return self . _slash_commands . get ( name ) maybe_group = self . _slash_commands . get ( parts . pop ( 0 )) if not isinstance ( maybe_group , lightbulb . SlashCommandGroup ): return None this : t . Optional [ t . Union [ lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup , lightbulb . SlashSubCommand ] ] = maybe_group for part in parts : if this is None or isinstance ( this , lightbulb . SlashSubCommand ): return None this = this . get_subcommand ( part ) return this","title":"MichaelBot"},{"location":"dev/models/#utils.models.MichaelBot.__init__","text":"Parameters: Name Type Description Default info dict The bot info. Store the one in config.json . required secrets dict The bot's secrets such as token, database info, etc. required Source code in utils\\models.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def __init__ ( self , token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None : ''' Parameters ----------------- info : dict The bot info. Store the one in `config.json`. secrets : dict The bot's secrets such as token, database info, etc. ''' self . info : dict = kwargs . pop ( \"info\" ) self . secrets : dict = kwargs . pop ( \"secrets\" ) self . online_at : dt . datetime = None self . pool : t . Optional [ asyncpg . Pool ] = None self . aio_session : t . Optional [ aiohttp . ClientSession ] = None # Store some db info. This allows read-only operation much cheaper. self . guild_cache : dict [ int , GuildCache ] = {} self . user_cache : dict [ int , UserCache ] = {} self . lavalink : t . Optional [ lavaplayer . LavalinkClient ] = None # Currently lavaplayer doesn't support adding attr to lavaplayer.objects.Node # so we'll make a dictionary to manually track additional info. self . node_extra : dict [ int , NodeExtra ] = {} launch_options = self . info . get ( \"launch_options\" ) log_level = \"INFO\" if launch_options is None : launch_options = \"\" for option in launch_options . split (): if option in [ \"--debug\" , \"-d\" ]: default_enabled_guilds = self . info [ \"default_guilds\" ] log_level = \"DEBUG\" if option in [ \"--quiet\" , \"-q\" ]: log_level = \"\" super () . __init__ ( token , prefix , ignore_bots , owner_ids , default_enabled_guilds , help_class , help_slash_command , delete_unbound_commands , case_insensitive_prefix_commands , logs = log_level if bool ( log_level ) else None , ** kwargs )","title":"__init__()"},{"location":"dev/models/#utils.models.MichaelBot.get_slash_command","text":"Get the slash command with the given name, or None if none was found. Unlike the default behavior in lightbulb.BotApp , this also searches for subcommands. Parameters: Name Type Description Default name str The command name to search. required Returns: Type Description t . Optional [ lightbulb . SlashCommand ] The slash command with that name, or None if none was found. Source code in utils\\models.py 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 def get_slash_command ( self , name : str ) -> t . Optional [ lightbulb . SlashCommand ]: '''Get the slash command with the given name, or `None` if none was found. Unlike the default behavior in `lightbulb.BotApp`, this also searches for subcommands. Parameters ---------- name : str The command name to search. Returns ------- t.Optional[lightbulb.SlashCommand] The slash command with that name, or `None` if none was found. ''' # Reference: https://hikari-lightbulb.readthedocs.io/en/latest/_modules/lightbulb/app.html#BotApp.get_prefix_command parts = name . split () if len ( parts ) == 1 : return self . _slash_commands . get ( name ) maybe_group = self . _slash_commands . get ( parts . pop ( 0 )) if not isinstance ( maybe_group , lightbulb . SlashCommandGroup ): return None this : t . Optional [ t . Union [ lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup , lightbulb . SlashSubCommand ] ] = maybe_group for part in parts : if this is None or isinstance ( this , lightbulb . SlashSubCommand ): return None this = this . get_subcommand ( part ) return this","title":"get_slash_command()"},{"location":"user/bot/","text":"Bot Category Bot-related Commands changelog [option = stable] Show 10 latest stable changes to the bot. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: option : Additional options. Valid options are dev / development and stable . Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command. help [*name = None] Get help information for the bot. Type: Prefix Command , Slash Command Aliases: h Parameters: name : Category name or command name. Is case-sensitive. info Show information about the bot. Type: Prefix Command , Slash Command Aliases: about ping Check the bot if it's alive. Type: Prefix Command , Slash Command prefix [new_prefix = None] View or edit the bot prefix for the guild. This only affects Prefix Commands. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: new_prefix : The new prefix. Should not be longer than 5 characters or contain spaces. Additional Info: Author needs to have Manage Server permission. report <type> <*reason> Report a bug or suggest a feature for the bot. Please be constructive. Type: Prefix Command , Slash Command (recommended). Cooldown: 5 seconds after 1 use per user. Parameters: type : The type of report you're making. Either bug or suggest . reason : The content you're trying to send. Last updated on Apr 25, 2022","title":"Bot"},{"location":"user/bot/#bot-category","text":"Bot-related Commands","title":"Bot Category"},{"location":"user/bot/#changelog-option-stable","text":"Show 10 latest stable changes to the bot. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: option : Additional options. Valid options are dev / development and stable . Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command.","title":"changelog [option = stable]"},{"location":"user/bot/#help-name-none","text":"Get help information for the bot. Type: Prefix Command , Slash Command Aliases: h Parameters: name : Category name or command name. Is case-sensitive.","title":"help [*name = None]"},{"location":"user/bot/#info","text":"Show information about the bot. Type: Prefix Command , Slash Command Aliases: about","title":"info"},{"location":"user/bot/#ping","text":"Check the bot if it's alive. Type: Prefix Command , Slash Command","title":"ping"},{"location":"user/bot/#prefix-new_prefix-none","text":"View or edit the bot prefix for the guild. This only affects Prefix Commands. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: new_prefix : The new prefix. Should not be longer than 5 characters or contain spaces. Additional Info: Author needs to have Manage Server permission.","title":"prefix [new_prefix = None]"},{"location":"user/bot/#report-type-reason","text":"Report a bug or suggest a feature for the bot. Please be constructive. Type: Prefix Command , Slash Command (recommended). Cooldown: 5 seconds after 1 use per user. Parameters: type : The type of report you're making. Either bug or suggest . reason : The content you're trying to send. Last updated on Apr 25, 2022","title":"report &lt;type&gt; &lt;*reason&gt;"},{"location":"user/fun/","text":"Fun Category Fun Commands copypasta <type> My favorite copypasta. Type: Prefix Command Cooldown: 10 seconds after 1 use per user. Parameters: type : Which copypasta to show. Dig into the bot's code to see available options ;) dadjoke Give you a dad joke. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Aliases: ina-of-the-mountain-what-is-your-wisdom dice Roll a 6-face dice for you. Type: Prefix Command , Slash Command do <action_type> [*user] Perform an anime action. Type: Prefix Command , Slash Command (recommended) Cooldown: 5 seconds after 1 use per user. Parameters: action_type : The action to perform. Valid actions are: angry , cuddle , hug , pat , punch , slap , wink . user : The Discord user to perform the action on. Default to yourself. echo <content> Echo echo echo echo. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per user. Parameters: content : The string to echo. Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command. how <measure_unit> <*target> An ultimate measurement to measure everything. Type: Prefix Command , Slash Command (recommended) Parameters: measure_unit : The unit to measure. target : The target to measure. mock <*text> tuRn A teXT INtO MOCk teXt. Type: Prefix Command , Slash Command (recommended) Parameters: text : Text to mock. Additional Info: The text will be sent through DM if it exceeds 1500 characters. pekofy Pekofy a message peko. Type: Message Command Cooldown: 5 seconds after 1 use per user. speak <*content> Speak the message. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per user. Parameters: content : The string to speak. Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command. uwu <*text> Turn a text into uwu text. Type: Prefix Command , Slash Command , Message Command (recommended) Cooldown: 3 seconds after 1 use per user. Parameters: text : Text to uwuify. Last updated on Apr 10, 2022","title":"Fun"},{"location":"user/fun/#fun-category","text":"Fun Commands","title":"Fun Category"},{"location":"user/fun/#copypasta-type","text":"My favorite copypasta. Type: Prefix Command Cooldown: 10 seconds after 1 use per user. Parameters: type : Which copypasta to show. Dig into the bot's code to see available options ;)","title":"copypasta &lt;type&gt;"},{"location":"user/fun/#dadjoke","text":"Give you a dad joke. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Aliases: ina-of-the-mountain-what-is-your-wisdom","title":"dadjoke"},{"location":"user/fun/#dice","text":"Roll a 6-face dice for you. Type: Prefix Command , Slash Command","title":"dice"},{"location":"user/fun/#do-action_type-user","text":"Perform an anime action. Type: Prefix Command , Slash Command (recommended) Cooldown: 5 seconds after 1 use per user. Parameters: action_type : The action to perform. Valid actions are: angry , cuddle , hug , pat , punch , slap , wink . user : The Discord user to perform the action on. Default to yourself.","title":"do &lt;action_type&gt; [*user]"},{"location":"user/fun/#echo-content","text":"Echo echo echo echo. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per user. Parameters: content : The string to echo. Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command.","title":"echo &lt;content&gt;"},{"location":"user/fun/#how-measure_unit-target","text":"An ultimate measurement to measure everything. Type: Prefix Command , Slash Command (recommended) Parameters: measure_unit : The unit to measure. target : The target to measure.","title":"how &lt;measure_unit&gt; &lt;*target&gt;"},{"location":"user/fun/#mock-text","text":"tuRn A teXT INtO MOCk teXt. Type: Prefix Command , Slash Command (recommended) Parameters: text : Text to mock. Additional Info: The text will be sent through DM if it exceeds 1500 characters.","title":"mock &lt;*text&gt;"},{"location":"user/fun/#pekofy","text":"Pekofy a message peko. Type: Message Command Cooldown: 5 seconds after 1 use per user.","title":"pekofy"},{"location":"user/fun/#speak-content","text":"Speak the message. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per user. Parameters: content : The string to speak. Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command.","title":"speak &lt;*content&gt;"},{"location":"user/fun/#uwu-text","text":"Turn a text into uwu text. Type: Prefix Command , Slash Command , Message Command (recommended) Cooldown: 3 seconds after 1 use per user. Parameters: text : Text to uwuify. Last updated on Apr 10, 2022","title":"uwu &lt;*text&gt;"},{"location":"user/logger/","text":"Logs Category Logging commands. log-set Set a channel as a log channel. Type: Prefix Command Additional Info: This command doesn't do anything. Please use the subcommands. log-set all [channel = None] Set a channel to dump all the logs. This automatically enables logging system. Type: Prefix Command , Slash Command Parameters: channel : The Discord channel to dump all the logs. Default to current channel. Additional Info: Author needs to have Manage Server . log-set option <logging_option> Enable a logging option. Type: Prefix Command , Slash Command (recommended) Parameters: logging_option : Log type to turn on. Check log-view to see all options. Additional Info: Author needs to have Manage Server . It is recommended to use the Slash Command version of the command. log-disable Disable logging or part of the logging system. Type: Prefix Command Additional Info: This command doesn't do anything. Please use the subcommands. log-disable all Disable logging system. Type: Prefix Command , Slash Command log-disable option <logging_option> Disable a logging option. Type: Prefix Command , Slash Command (recommended) Parameters: logging_option : Log type to turn off. Check log-view to see all options. Additional Info: Author needs to have Manage Server . It is recommended to use the Slash Command version of the command. log-view View all log settings. Type: Prefix Command , Slash Command Additional Info: Author needs to have Manage Server . Last updated on Apr 1, 2022","title":"Logs"},{"location":"user/logger/#logs-category","text":"Logging commands.","title":"Logs Category"},{"location":"user/logger/#log-set","text":"Set a channel as a log channel. Type: Prefix Command Additional Info: This command doesn't do anything. Please use the subcommands.","title":"log-set"},{"location":"user/logger/#log-set-all-channel-none","text":"Set a channel to dump all the logs. This automatically enables logging system. Type: Prefix Command , Slash Command Parameters: channel : The Discord channel to dump all the logs. Default to current channel. Additional Info: Author needs to have Manage Server .","title":"log-set all [channel = None]"},{"location":"user/logger/#log-set-option-logging_option","text":"Enable a logging option. Type: Prefix Command , Slash Command (recommended) Parameters: logging_option : Log type to turn on. Check log-view to see all options. Additional Info: Author needs to have Manage Server . It is recommended to use the Slash Command version of the command.","title":"log-set option &lt;logging_option&gt;"},{"location":"user/logger/#log-disable","text":"Disable logging or part of the logging system. Type: Prefix Command Additional Info: This command doesn't do anything. Please use the subcommands.","title":"log-disable"},{"location":"user/logger/#log-disable-all","text":"Disable logging system. Type: Prefix Command , Slash Command","title":"log-disable all"},{"location":"user/logger/#log-disable-option-logging_option","text":"Disable a logging option. Type: Prefix Command , Slash Command (recommended) Parameters: logging_option : Log type to turn off. Check log-view to see all options. Additional Info: Author needs to have Manage Server . It is recommended to use the Slash Command version of the command.","title":"log-disable option &lt;logging_option&gt;"},{"location":"user/logger/#log-view","text":"View all log settings. Type: Prefix Command , Slash Command Additional Info: Author needs to have Manage Server . Last updated on Apr 1, 2022","title":"log-view"},{"location":"user/music/","text":"Music Category Music commands. join [voice_channel = None] Join a voice channel. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: voice_channel : The voice channel to join. Default to the VC you're in. Aliases: connect leave Leave the voice channel. Type: Prefix Command , Slash Command Aliases: dc (recommended), disconnect np Get info about the current track. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild. Aliases: now_playing play <*query> Play the query or add it to the queue. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 5 uses per guild. Parameters: query : The query to play (url, name, etc.) Aliases: p (recommended) pause Toggle pausing the player. Type: Prefix Command , Slash Command c search <*track> Search and return 10 relevant results. You can then copy the desired link into play . Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild. Parameters: track : Keywords to search. Example: blend w . seek <position> Jump to the provided timestamp. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild. Parameters: position : Timestamp to jump to. repeat Toggle repeating the track. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild. volume <vol> Set the volume of the player. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: vol : Volume to set (0-200). Additional Info: It's recommended to use the built-in feature User Volume instead of this command. queue Display the song queue. Type: Prefix Command Cooldown: 2 seconds after 1 use per guild. Aliases: q (recommended) queue view Display the song queue. This exists for Slash Commands. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild. queue clear Clear the entire queue but the current track. Type: Prefix Command , Slash Command queue shuffle Shuffle the queue. Type: Prefix Command , Slash Command queue loop Toggle queue loop. Type: Prefix Command , Slash Command queue move <from_index> <to_index> Move a track in queue to a new order index. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: from_index : The index in the queue to move. to_index : The index in the queue where you want the track to be. queue remove <index> Remove a track in the queue. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: index : The index in the queue to remove. skip Skip the current track. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild. Aliases: s (recommended) stop Stop the player. Type: Prefix Command , Slash Command Last updated on Apr 1, 2022","title":"Music"},{"location":"user/music/#music-category","text":"Music commands.","title":"Music Category"},{"location":"user/music/#join-voice_channel-none","text":"Join a voice channel. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: voice_channel : The voice channel to join. Default to the VC you're in. Aliases: connect","title":"join [voice_channel = None]"},{"location":"user/music/#leave","text":"Leave the voice channel. Type: Prefix Command , Slash Command Aliases: dc (recommended), disconnect","title":"leave"},{"location":"user/music/#np","text":"Get info about the current track. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild. Aliases: now_playing","title":"np"},{"location":"user/music/#play-query","text":"Play the query or add it to the queue. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 5 uses per guild. Parameters: query : The query to play (url, name, etc.) Aliases: p (recommended)","title":"play &lt;*query&gt;"},{"location":"user/music/#pause","text":"Toggle pausing the player. Type: Prefix Command , Slash Command c","title":"pause"},{"location":"user/music/#search-track","text":"Search and return 10 relevant results. You can then copy the desired link into play . Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild. Parameters: track : Keywords to search. Example: blend w .","title":"search &lt;*track&gt;"},{"location":"user/music/#seek-position","text":"Jump to the provided timestamp. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild. Parameters: position : Timestamp to jump to.","title":"seek &lt;position&gt;"},{"location":"user/music/#repeat","text":"Toggle repeating the track. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild.","title":"repeat"},{"location":"user/music/#volume-vol","text":"Set the volume of the player. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: vol : Volume to set (0-200). Additional Info: It's recommended to use the built-in feature User Volume instead of this command.","title":"volume &lt;vol&gt;"},{"location":"user/music/#queue","text":"Display the song queue. Type: Prefix Command Cooldown: 2 seconds after 1 use per guild. Aliases: q (recommended)","title":"queue"},{"location":"user/music/#queue-view","text":"Display the song queue. This exists for Slash Commands. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild.","title":"queue view"},{"location":"user/music/#queue-clear","text":"Clear the entire queue but the current track. Type: Prefix Command , Slash Command","title":"queue clear"},{"location":"user/music/#queue-shuffle","text":"Shuffle the queue. Type: Prefix Command , Slash Command","title":"queue shuffle"},{"location":"user/music/#queue-loop","text":"Toggle queue loop. Type: Prefix Command , Slash Command","title":"queue loop"},{"location":"user/music/#queue-move-from_index-to_index","text":"Move a track in queue to a new order index. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: from_index : The index in the queue to move. to_index : The index in the queue where you want the track to be.","title":"queue move &lt;from_index&gt; &lt;to_index&gt;"},{"location":"user/music/#queue-remove-index","text":"Remove a track in the queue. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: index : The index in the queue to remove.","title":"queue remove &lt;index&gt;"},{"location":"user/music/#skip","text":"Skip the current track. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild. Aliases: s (recommended)","title":"skip"},{"location":"user/music/#stop","text":"Stop the player. Type: Prefix Command , Slash Command Last updated on Apr 1, 2022","title":"stop"},{"location":"user/utilities/","text":"Utilities Category Utility Commands. calc <expression> Calculate a math expression. Type: Prefix Command , Slash Command Parameters: expression : The math expression. Additional Info: Rounding errors, along with other debatable values such as 0^0 is incorrect due to language limitation. embed Send an embed. Additional Info: This command only works with subcommands. embed from-json <raw_embed> Send an embed from a JSON object. Check out https://embedbuilder.nadekobot.me/ for easier time. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: raw_embed : The embed in JSON format. embed to-json <message_id> Take the embed from a message and convert it to a JSON object. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: message_id : The message ID. The bot can't get a message that's too old. Additional Info: This is useful when you want to change slightly from an existing embed. embed simple [title = None] [description = None] [color = green] [channel = None] Create and send a simple embed. Useful for quick embeds. Type: Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: title : The title of the embed. description : The description of the embed. color : Your choice of color. Default to green. channel : The channel to send this embed. Default to the current one. Additional Info: This is an alternative to embed interactive . Either title or description must be non-empty. embed interactive Create a simple embed with prompts. Type: Prefix Command Aliases: embed i Cooldown: 3 seconds after 1 use per user. Additional Info: Bot needs to have Manage Messages . This is an alternative to embed simple . profile [member = None] Information about yourself or another member. Type: Prefix Command , Slash Command Parameters: member : A Discord member. Default to you. remindme Create a reminder. Make sure your DM is open to the bot. Type: None Aliases: rmd , notify , timer Additional Info: This command only works with subcommands. remindme create <interval> <*message> Create a reminder. Make sure your DM is open to the bot. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: interval : How long until the bot reminds you. Must be between 1 minute and 30 days. Example: 3d2m1s message : The message the bot will send after the interval. Additional Info: An interval of less than 120 seconds is considered to be a \"short reminder\". remindme view View all your long reminders. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Additional Info: Due to optimization, this command won't display short reminders. remindme remove <remind_id> Remove a long reminder. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: remind_id : The reminder's id. You can find it in remindme view . Additional Info: Due to optimization, this command won't remove short reminders. role-info <role> Information about a role in this server. Type: Prefix Command , Slash Command Parameters: role : A Discord role. Aliases: roleinfo server-info Information about this server. Type: Prefix Command , Slash Command Aliases: serverinfo urban <*term> Search a term on urbandictionary. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: term : The term to search. Example: rickroll . weather <*city_name> Display weather information for a location. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: city_name : The city to check. Example: Paris . Last updated on Apr 27, 2022","title":"Utilities"},{"location":"user/utilities/#utilities-category","text":"Utility Commands.","title":"Utilities Category"},{"location":"user/utilities/#calc-expression","text":"Calculate a math expression. Type: Prefix Command , Slash Command Parameters: expression : The math expression. Additional Info: Rounding errors, along with other debatable values such as 0^0 is incorrect due to language limitation.","title":"calc &lt;expression&gt;"},{"location":"user/utilities/#embed","text":"Send an embed. Additional Info: This command only works with subcommands.","title":"embed"},{"location":"user/utilities/#embed-from-json-raw_embed","text":"Send an embed from a JSON object. Check out https://embedbuilder.nadekobot.me/ for easier time. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: raw_embed : The embed in JSON format.","title":"embed from-json &lt;raw_embed&gt;"},{"location":"user/utilities/#embed-to-json-message_id","text":"Take the embed from a message and convert it to a JSON object. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: message_id : The message ID. The bot can't get a message that's too old. Additional Info: This is useful when you want to change slightly from an existing embed.","title":"embed to-json &lt;message_id&gt;"},{"location":"user/utilities/#embed-simple-title-none-description-none-color-green-channel-none","text":"Create and send a simple embed. Useful for quick embeds. Type: Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: title : The title of the embed. description : The description of the embed. color : Your choice of color. Default to green. channel : The channel to send this embed. Default to the current one. Additional Info: This is an alternative to embed interactive . Either title or description must be non-empty.","title":"embed simple [title = None] [description = None] [color = green] [channel = None]"},{"location":"user/utilities/#embed-interactive","text":"Create a simple embed with prompts. Type: Prefix Command Aliases: embed i Cooldown: 3 seconds after 1 use per user. Additional Info: Bot needs to have Manage Messages . This is an alternative to embed simple .","title":"embed interactive"},{"location":"user/utilities/#profile-member-none","text":"Information about yourself or another member. Type: Prefix Command , Slash Command Parameters: member : A Discord member. Default to you.","title":"profile [member = None]"},{"location":"user/utilities/#remindme","text":"Create a reminder. Make sure your DM is open to the bot. Type: None Aliases: rmd , notify , timer Additional Info: This command only works with subcommands.","title":"remindme"},{"location":"user/utilities/#remindme-create-interval-message","text":"Create a reminder. Make sure your DM is open to the bot. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: interval : How long until the bot reminds you. Must be between 1 minute and 30 days. Example: 3d2m1s message : The message the bot will send after the interval. Additional Info: An interval of less than 120 seconds is considered to be a \"short reminder\".","title":"remindme create &lt;interval&gt; &lt;*message&gt;"},{"location":"user/utilities/#remindme-view","text":"View all your long reminders. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Additional Info: Due to optimization, this command won't display short reminders.","title":"remindme view"},{"location":"user/utilities/#remindme-remove-remind_id","text":"Remove a long reminder. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: remind_id : The reminder's id. You can find it in remindme view . Additional Info: Due to optimization, this command won't remove short reminders.","title":"remindme remove &lt;remind_id&gt;"},{"location":"user/utilities/#role-info-role","text":"Information about a role in this server. Type: Prefix Command , Slash Command Parameters: role : A Discord role. Aliases: roleinfo","title":"role-info &lt;role&gt;"},{"location":"user/utilities/#server-info","text":"Information about this server. Type: Prefix Command , Slash Command Aliases: serverinfo","title":"server-info"},{"location":"user/utilities/#urban-term","text":"Search a term on urbandictionary. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: term : The term to search. Example: rickroll .","title":"urban &lt;*term&gt;"},{"location":"user/utilities/#weather-city_name","text":"Display weather information for a location. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: city_name : The city to check. Example: Paris . Last updated on Apr 27, 2022","title":"weather &lt;*city_name&gt;"}]}