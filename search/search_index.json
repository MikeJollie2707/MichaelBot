{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MichaelBot Documentation Welcome to MichaelBot's documentation. This documents all the bot's commands along with its features. For general purposes, please refers to the Commands heading. For those who are interested in some of the more secret stuffs, feel free to look at the bot source code. Below are some of the topics that are might not obvious from a user perspective. Prefix vs Slash MichaelBot has 2 main types of command: prefix command and slash command. Prefix command is the OG \"command system\" that's been widely implemented for pretty much every single bot. Slash command is the official command system in Discord that's been implemented fairly recently. MichaelBot tries to balance these 2, but there are some pros and cons to them: Slash > Prefix: Is officially supported by Discord and is super newbie-friendly. Can use Tab to autocomplete. This makes it somewhat unnecessary for the user to remember the arguments. This is excellent when the user need to input some sort of choice into the command. Arguments are generally easier to deal with since Discord do all the necessary text parsing. Prefix commands don't work without verifying the bot after reaching 100 servers. This is technically not the case for slash commands. Prefix > Slash: Is familiar to a lot of people. Can alias commands. This allows users to smash commands super fast. Slash commands have a hard limit of 100 commands per bot. Prefix commands don't have such thing. Slash commands don't have hidden commands; all commands are public. Slash commands' parent can't be invoked ( queue cannot be invoked if a subcommand queue clear is registered). This is not the case for prefix commands. With these pros and cons, sometimes some commands are exclusive to slash or prefix only. This will be mentioned in each command entry. Besides slash commands, Discord also have user commands and message commands . However, the bot rarely uses them for important features, so you can safely ignore them for the most part. By default, I'll recommend you to use the Prefix version of the command. However, in some cases, Slash command might performs the job easier. I'll sometimes put my preferences if that's the case. Cooldown Some commands have cooldown. This is to ensure the bot has time to do things first before it is invoked again. This is quite common for commands that deal with heavy stuffs such as music or communicating with servers. Some cooldown are simply to avoid spamming potential. Cooldown is applied to a certain target. There are 4 targets a cooldown can apply: A user. This means the user can't execute the command within an interval. A channel. This means the command can't be executed in the same channel within an interval. A guild. This means the command can't be executed in the same guild within an interval. Everywhere. This means the command can't be executed by anyone within an interval. Technical: Most cooldown are soft; they can be reset by resetting the bot or use some commands to reset. Some cooldown are hard-coded; they're saved within the database and you might need to edit the table (and the cache) to remove it. Parameters Many commands require parameters to be passed in. Although the help command already provide a good amount of info, it is still limited because it is auto-generated. Note that these are mostly applied to Prefix Commands; Slash Commands is super user-friendly so you might not even need to care about most of these stuffs. Take the command signature foo <bar> [bar2 = bla] [bar3 = 1] [*baz = None] All parameters are separated by space. Which means if you invoke foo 1 2 3 , it'll store as bar = 1, bar2 = 2, bar3 = 3 and not bar = 1 2 3 . <parameter> means this parameter is required. That means bar is a required parameter. [parameter] or [parameter = None] means this parameter is optional. That means bar2 , bar3 , and baz are optional parameters. parameter = sth means the default value of a parameter is set to whatever sth is. This usually appears in optional parameters. *parameter means it'll consume all the remaining text. This means if you invoke foo 1 2 3 4 5 6 , it'll store as bar = 1, bar2 = 2, bar3 = 3, baz = 4 5 6 . Slash Commands have none of the above problem since parameters are separated by Tab, and they also have indication which parameters are required. Parameter Type There are several types the bot will work with. The most common one is plain text, followed by numbers. These are pretty straightforward. The less obvious types are such as a Discord User or a Discord Guild. There are several ways to pass in such types, which will be shown in this table. Type Pass into Prefix Commands Pass into Slash Commands Plain text Literally any text you type. Literally any text you type. Numbers Literally any numbers you type. Literally any numbers you type. Discord User/Member/Channel/Role ID > Mention > Name > Nickname Choose from the option (you might need to partially type the name for it to show up). Discord Guild ID ID Time 1d10h10m10s or hh:mm:ss 1d10h10m10s or hh:mm:ss","title":"Home"},{"location":"#welcome-to-michaelbot-documentation","text":"Welcome to MichaelBot's documentation. This documents all the bot's commands along with its features. For general purposes, please refers to the Commands heading. For those who are interested in some of the more secret stuffs, feel free to look at the bot source code. Below are some of the topics that are might not obvious from a user perspective.","title":"Welcome to MichaelBot Documentation"},{"location":"#prefix-vs-slash","text":"MichaelBot has 2 main types of command: prefix command and slash command. Prefix command is the OG \"command system\" that's been widely implemented for pretty much every single bot. Slash command is the official command system in Discord that's been implemented fairly recently. MichaelBot tries to balance these 2, but there are some pros and cons to them: Slash > Prefix: Is officially supported by Discord and is super newbie-friendly. Can use Tab to autocomplete. This makes it somewhat unnecessary for the user to remember the arguments. This is excellent when the user need to input some sort of choice into the command. Arguments are generally easier to deal with since Discord do all the necessary text parsing. Prefix commands don't work without verifying the bot after reaching 100 servers. This is technically not the case for slash commands. Prefix > Slash: Is familiar to a lot of people. Can alias commands. This allows users to smash commands super fast. Slash commands have a hard limit of 100 commands per bot. Prefix commands don't have such thing. Slash commands don't have hidden commands; all commands are public. Slash commands' parent can't be invoked ( queue cannot be invoked if a subcommand queue clear is registered). This is not the case for prefix commands. With these pros and cons, sometimes some commands are exclusive to slash or prefix only. This will be mentioned in each command entry. Besides slash commands, Discord also have user commands and message commands . However, the bot rarely uses them for important features, so you can safely ignore them for the most part. By default, I'll recommend you to use the Prefix version of the command. However, in some cases, Slash command might performs the job easier. I'll sometimes put my preferences if that's the case.","title":"Prefix vs Slash"},{"location":"#cooldown","text":"Some commands have cooldown. This is to ensure the bot has time to do things first before it is invoked again. This is quite common for commands that deal with heavy stuffs such as music or communicating with servers. Some cooldown are simply to avoid spamming potential. Cooldown is applied to a certain target. There are 4 targets a cooldown can apply: A user. This means the user can't execute the command within an interval. A channel. This means the command can't be executed in the same channel within an interval. A guild. This means the command can't be executed in the same guild within an interval. Everywhere. This means the command can't be executed by anyone within an interval. Technical: Most cooldown are soft; they can be reset by resetting the bot or use some commands to reset. Some cooldown are hard-coded; they're saved within the database and you might need to edit the table (and the cache) to remove it.","title":"Cooldown"},{"location":"#parameters","text":"Many commands require parameters to be passed in. Although the help command already provide a good amount of info, it is still limited because it is auto-generated. Note that these are mostly applied to Prefix Commands; Slash Commands is super user-friendly so you might not even need to care about most of these stuffs. Take the command signature foo <bar> [bar2 = bla] [bar3 = 1] [*baz = None] All parameters are separated by space. Which means if you invoke foo 1 2 3 , it'll store as bar = 1, bar2 = 2, bar3 = 3 and not bar = 1 2 3 . <parameter> means this parameter is required. That means bar is a required parameter. [parameter] or [parameter = None] means this parameter is optional. That means bar2 , bar3 , and baz are optional parameters. parameter = sth means the default value of a parameter is set to whatever sth is. This usually appears in optional parameters. *parameter means it'll consume all the remaining text. This means if you invoke foo 1 2 3 4 5 6 , it'll store as bar = 1, bar2 = 2, bar3 = 3, baz = 4 5 6 . Slash Commands have none of the above problem since parameters are separated by Tab, and they also have indication which parameters are required.","title":"Parameters"},{"location":"#parameter-type","text":"There are several types the bot will work with. The most common one is plain text, followed by numbers. These are pretty straightforward. The less obvious types are such as a Discord User or a Discord Guild. There are several ways to pass in such types, which will be shown in this table. Type Pass into Prefix Commands Pass into Slash Commands Plain text Literally any text you type. Literally any text you type. Numbers Literally any numbers you type. Literally any numbers you type. Discord User/Member/Channel/Role ID > Mention > Name > Nickname Choose from the option (you might need to partially type the name for it to show up). Discord Guild ID ID Time 1d10h10m10s or hh:mm:ss 1d10h10m10s or hh:mm:ss","title":"Parameter Type"},{"location":"INSTALLATION/","text":"Installation All instructions are geared towards Ubuntu (Kubuntu specifically) because that's what I use. Instructions for Windows is available, but be aware I don't test them often. Prerequisites Requires: Python 3.10+ (ideally latest), Git, pip , virtualenv / python3-venv under Python. Optional: Lavalink (more information below), Docker (for Lavalink), PostgreSQL (more information below). About Lavalink Lavalink is optional for the bot. If you don't plan to use the music functionality, you can simply edit main.py the EXTENSION variable to exclude categories.music . Then you can completely ignore this section and move on. Otherwise, you'll need to finish setting up Lavalink and get it running. There are 2 options to host Lavalink: you can host it directly using the .jar file or use Docker. I personally switched to Docker recently so I won't tell which one you should go. In either cases, you'll need a file application.yml to configure the server. An example is provided in ./lib/Lavalink . You'll also need Java 13+, which can be downloaded here or somewhere else (there are a billion places to download a billion java versions I'm not gonna even bother). Running Lavalink (.jar) Download Lavalink.jar , or use the one currently in ./lib/Lavalink/ . Run java -jar <path to Lavalink.jar> . Lavalink server should start running now. By default, it'll run on localhost:2333 unless you configure it in application.yml . Running Lavalink (Docker) This is not tested on Windows. Download Docker. Here is the guide for Ubuntu. Run docker pull fredboat/lavalink:master . This will pull the stable image. Run docker run --name <name> -p <port>:<port> -d -v <path-to-application.yml>:/opt/Lavalink/application.yml fredboat/lavalink:master , where <name> is the name of the process, <port> is the port the server is on, and <path-to-application.yml> is the absolute path to the config file. To stop the process, run docker stop <name> . About PostgreSQL PostgreSQL is optional for the bot, but is strongly recommended. Without a database, some features will be missing, such as prefix config, blacklisting, logging, etc. In addition to that, although the code can handle no database scenario on its own, it is not well-tested for such cases, so there might be some edge cases here and there. This is a pretty fine guide to install PostgreSQL on Ubuntu: https://linuxhint.com/postgresql_installation_guide_ubuntu_20-04/ After installing Postgres, create a database and check the connection info. You'll need this later. Build Instructions The following instructions has been tested with bash and Powershell . You'll need to replace the python command mentioned below with whatever your system has ( python3 or python3.x for Linux, python for Windows). Clone the repository into the current folder. git clone https://github.com/MikeJollie2707/MichaelBot.git . Activate virtual environment and install libraries. # Linux python -m pip venv venv source ./venv/bin/activate python -m pip install -r requirement.txt # Windows # From my experience, / still works, but if it doesn't, use \\ python -m pip venv venv ./venv/Scripts/Activate.ps1 # This is important; uvloop is not available on Windows. python -m pip install -r win_requirement.txt Configure the bot. Inside ./setup , create a .json file. I'll call it secret.json . // secret.json { \"token\": \"Bot token here\", \"host\": \"localhost\", \"port\": 5432, \"database\": \"database name\", \"user\": \"user name\", \"password\": \"password\", \"weather_api_key\": \"api key\" } If you don't have a database and/or weather_api_key , leave them as dummy values ( \"\" and 0 ). Within ./setup , there's also another file called config.json . The file has the following structure: // config.json { \"BotIndex\": { \"version\": \"Required\", \"description\": \"Required\", \"prefix\": \"Required\", \"launch_options\": \"Optional\", \"default_guilds\": [123456], \"secret\": \"secret.json\" } } BotIndex : the index you'll refer to the bot when you launch it from the terminal. Usually the bot name without space. version : the bot version. Just fake something up like 69.69beta if you don't really care about this. description : the bot's about me. Discord doesn't have a way to retrieve this so this is required for now. prefix : the bot's default prefix. launch_options : an optional string to pass into the bot when it launches. This mostly affects terminal logging. Acceptable options are: -d or --debug : Launch the bot in debug mode. This will set the log level to DEBUG but more importantly, it'll apply slash commands to default_guilds immediately (no need to wait at most 1 hour). If this is passed, default_guilds must also be non-empty. -q or --quiet : Launch the bot in quiet mode. This will disable terminal logging, but any uncaught exceptions will still spawn in stderr . default_guilds : a list of guilds' ids to apply slash commands immediately. This is required if the bot is launched in debug mode. secret : the file name that contains your bot's secret like token. You can view my bot config as an example. (Optional) If you have a database, you'll need to set up the tables beforehand. You only need to do this once. python dbsetup.py BotIndex Run the bot. python -OO main.py BotIndex What's next? For personal convenience, I also have a template script to run the bot in different modes. You can check it out at run.sh (Kubuntu) or run.ps1 (Windows). It'll only run the bot. You'll need to run Lavalink and PostgreSQL on your own.","title":"Installation"},{"location":"INSTALLATION/#installation","text":"All instructions are geared towards Ubuntu (Kubuntu specifically) because that's what I use. Instructions for Windows is available, but be aware I don't test them often.","title":"Installation"},{"location":"INSTALLATION/#prerequisites","text":"Requires: Python 3.10+ (ideally latest), Git, pip , virtualenv / python3-venv under Python. Optional: Lavalink (more information below), Docker (for Lavalink), PostgreSQL (more information below).","title":"Prerequisites"},{"location":"INSTALLATION/#about-lavalink","text":"Lavalink is optional for the bot. If you don't plan to use the music functionality, you can simply edit main.py the EXTENSION variable to exclude categories.music . Then you can completely ignore this section and move on. Otherwise, you'll need to finish setting up Lavalink and get it running. There are 2 options to host Lavalink: you can host it directly using the .jar file or use Docker. I personally switched to Docker recently so I won't tell which one you should go. In either cases, you'll need a file application.yml to configure the server. An example is provided in ./lib/Lavalink . You'll also need Java 13+, which can be downloaded here or somewhere else (there are a billion places to download a billion java versions I'm not gonna even bother).","title":"About Lavalink"},{"location":"INSTALLATION/#running-lavalink-jar","text":"Download Lavalink.jar , or use the one currently in ./lib/Lavalink/ . Run java -jar <path to Lavalink.jar> . Lavalink server should start running now. By default, it'll run on localhost:2333 unless you configure it in application.yml .","title":"Running Lavalink (.jar)"},{"location":"INSTALLATION/#running-lavalink-docker","text":"This is not tested on Windows. Download Docker. Here is the guide for Ubuntu. Run docker pull fredboat/lavalink:master . This will pull the stable image. Run docker run --name <name> -p <port>:<port> -d -v <path-to-application.yml>:/opt/Lavalink/application.yml fredboat/lavalink:master , where <name> is the name of the process, <port> is the port the server is on, and <path-to-application.yml> is the absolute path to the config file. To stop the process, run docker stop <name> .","title":"Running Lavalink (Docker)"},{"location":"INSTALLATION/#about-postgresql","text":"PostgreSQL is optional for the bot, but is strongly recommended. Without a database, some features will be missing, such as prefix config, blacklisting, logging, etc. In addition to that, although the code can handle no database scenario on its own, it is not well-tested for such cases, so there might be some edge cases here and there. This is a pretty fine guide to install PostgreSQL on Ubuntu: https://linuxhint.com/postgresql_installation_guide_ubuntu_20-04/ After installing Postgres, create a database and check the connection info. You'll need this later.","title":"About PostgreSQL"},{"location":"INSTALLATION/#build-instructions","text":"The following instructions has been tested with bash and Powershell . You'll need to replace the python command mentioned below with whatever your system has ( python3 or python3.x for Linux, python for Windows). Clone the repository into the current folder. git clone https://github.com/MikeJollie2707/MichaelBot.git . Activate virtual environment and install libraries. # Linux python -m pip venv venv source ./venv/bin/activate python -m pip install -r requirement.txt # Windows # From my experience, / still works, but if it doesn't, use \\ python -m pip venv venv ./venv/Scripts/Activate.ps1 # This is important; uvloop is not available on Windows. python -m pip install -r win_requirement.txt Configure the bot. Inside ./setup , create a .json file. I'll call it secret.json . // secret.json { \"token\": \"Bot token here\", \"host\": \"localhost\", \"port\": 5432, \"database\": \"database name\", \"user\": \"user name\", \"password\": \"password\", \"weather_api_key\": \"api key\" } If you don't have a database and/or weather_api_key , leave them as dummy values ( \"\" and 0 ). Within ./setup , there's also another file called config.json . The file has the following structure: // config.json { \"BotIndex\": { \"version\": \"Required\", \"description\": \"Required\", \"prefix\": \"Required\", \"launch_options\": \"Optional\", \"default_guilds\": [123456], \"secret\": \"secret.json\" } } BotIndex : the index you'll refer to the bot when you launch it from the terminal. Usually the bot name without space. version : the bot version. Just fake something up like 69.69beta if you don't really care about this. description : the bot's about me. Discord doesn't have a way to retrieve this so this is required for now. prefix : the bot's default prefix. launch_options : an optional string to pass into the bot when it launches. This mostly affects terminal logging. Acceptable options are: -d or --debug : Launch the bot in debug mode. This will set the log level to DEBUG but more importantly, it'll apply slash commands to default_guilds immediately (no need to wait at most 1 hour). If this is passed, default_guilds must also be non-empty. -q or --quiet : Launch the bot in quiet mode. This will disable terminal logging, but any uncaught exceptions will still spawn in stderr . default_guilds : a list of guilds' ids to apply slash commands immediately. This is required if the bot is launched in debug mode. secret : the file name that contains your bot's secret like token. You can view my bot config as an example. (Optional) If you have a database, you'll need to set up the tables beforehand. You only need to do this once. python dbsetup.py BotIndex Run the bot. python -OO main.py BotIndex","title":"Build Instructions"},{"location":"INSTALLATION/#whats-next","text":"For personal convenience, I also have a template script to run the bot in different modes. You can check it out at run.sh (Kubuntu) or run.ps1 (Windows). It'll only run the bot. You'll need to run Lavalink and PostgreSQL on your own.","title":"What's next?"},{"location":"dev/econ/","text":"econ/loot.py Define the loot tables for the economy system and a bunch of constants. RewardRNG Define the RNG to randomize. This emulate 2 RNGs. The first RNG will determine whether or not to roll the second RNG. The second RNG will generate a number between the defined range, with a custom RNG behavior taken into account. Attributes: Name Type Description rate float Define the rate at which the second RNG will roll. Must be between 0 and 1. min_amount int Define the minimum number for the second RNG. This should be positive. max_amount int Define the maximum number for the second RNG. This should be positive. amount_layout tuple [ int ], optional Define the rng distribution between min_amount and max_amount . This must satisfy len(amount_layout) == (max_amount - min_amount + 1) and sum(amount_layout) == 100 Source code in categories/econ/loot.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 class RewardRNG : '''Define the RNG to randomize. This emulate 2 RNGs. The first RNG will determine whether or not to roll the second RNG. The second RNG will generate a number between the defined range, with a custom RNG behavior taken into account. Attributes ---------- rate : float Define the rate at which the second RNG will roll. Must be between 0 and 1. min_amount : int Define the minimum number for the second RNG. This should be positive. max_amount : int Define the maximum number for the second RNG. This should be positive. amount_layout : tuple[int], optional Define the rng distribution between `min_amount` and `max_amount`. This must satisfy `len(amount_layout) == (max_amount - min_amount + 1) and sum(amount_layout) == 100` ''' __slots__ = ( \"rate\" , \"min_amount\" , \"max_amount\" , \"amount_layout\" ) def __init__ ( self , rate : float , min_amount : int , max_amount : int , * , amount_layout : tuple [ int ] = None ): if rate < 0 or rate > 1 : raise ValueError ( \"'rate' must be in [0, 1].\" ) if min_amount > max_amount : raise ValueError ( \"'min_amount' must be smaller than or equal to 'max_amount'.\" ) if amount_layout : if len ( amount_layout ) != ( max_amount - min_amount + 1 ): raise ValueError ( \"'amount_layout' must have the same amount of items as (max_amount - min_amount + 1).\" ) if sum ( amount_layout ) != 100 : print ( sum ( amount_layout )) raise ValueError ( \"'amount_layout' must sum up to 100.\" ) self . rate = rate self . min_amount = min_amount self . max_amount = max_amount self . amount_layout = amount_layout def shift_min_amount ( self , amount : int ): self . min_amount += amount self . max_amount += amount def roll ( self ) -> int : '''Roll the RNG based on the provided information. Returns ------- int The number after randomizing. ''' if self . rate < 1 : r = random . random () if r > self . rate : return 0 if self . min_amount == self . max_amount : return self . min_amount if not self . amount_layout : return random . choice ( range ( self . min_amount , self . max_amount + 1 )) r = random . random () rate = 0 for index , amount_rate in enumerate ( self . amount_layout ): rate += amount_rate / 100.0 if r <= rate : return min ( self . min_amount + index , self . max_amount ) return self . max_amount roll roll () -> int Roll the RNG based on the provided information. Returns: Type Description int The number after randomizing. Source code in categories/econ/loot.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def roll ( self ) -> int : '''Roll the RNG based on the provided information. Returns ------- int The number after randomizing. ''' if self . rate < 1 : r = random . random () if r > self . rate : return 0 if self . min_amount == self . max_amount : return self . min_amount if not self . amount_layout : return random . choice ( range ( self . min_amount , self . max_amount + 1 )) r = random . random () rate = 0 for index , amount_rate in enumerate ( self . amount_layout ): rate += amount_rate / 100.0 if r <= rate : return min ( self . min_amount + index , self . max_amount ) return self . max_amount get_daily_loot get_daily_loot ( streak : int ) -> dict [ str , int ] Return the daily loot based on the current streak. Parameters: Name Type Description Default streak int The current streak. required Returns: Type Description dict [ str , int ] A dict denoting the loot table. Source code in categories/econ/loot.py 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 def get_daily_loot ( streak : int ) -> dict [ str , int ]: '''Return the daily loot based on the current streak. Parameters ---------- streak : int The current streak. Returns ------- dict[str, int] A `dict` denoting the loot table. ''' if streak <= 1 : return { \"money\" : 50 , \"wood\" : 5 } if streak <= 6 : return { \"money\" : 10 , \"wood\" : random . randint ( 10 , 15 ) } if streak <= 13 : return { \"money\" : 100 , \"bonus\" : streak , \"wood\" : random . randint ( 10 , 15 ), \"leaf\" : random . randint ( 50 , 60 ), \"hibiscus\" : random . randint ( 10 , 12 ), \"tulip\" : random . randint ( 10 , 12 ), \"rose\" : random . randint ( 10 , 12 ), } if streak <= 27 : return { \"money\" : 200 , \"bonus\" : 5 * streak , \"wood\" : random . randint ( 20 , 25 ), \"leaf\" : random . randint ( 100 , 110 ), \"hibiscus\" : random . randint ( 20 , 22 ), \"tulip\" : random . randint ( 20 , 22 ), \"rose\" : random . randint ( 20 , 22 ), } if streak <= 60 : return { \"money\" : 1000 , \"bonus\" : 2 * streak , \"wood\" : random . randint ( 50 , 55 ), \"leaf\" : random . randint ( 210 , 220 ), \"hibiscus\" : random . randint ( 50 , 52 ), \"tulip\" : random . randint ( 50 , 52 ), \"rose\" : random . randint ( 50 , 52 ), \"lucky_clover\" : random . randint ( 1 , 5 ), } if streak <= 90 : return { \"money\" : 2000 , \"bonus\" : 5 * streak , \"wood\" : random . randint ( 190 , 210 ), \"leaf\" : random . randint ( 190 , 210 ), \"hibiscus\" : random . randint ( 190 , 210 ), \"tulip\" : random . randint ( 190 , 210 ), \"rose\" : random . randint ( 190 , 210 ), \"lucky_clover\" : random . randint ( 1 , 10 ), } return { \"money\" : 5000 , \"bonus\" : 10 * streak , \"wood\" : random . randint ( 500 , 1000 ), \"leaf\" : random . randint ( 1000 , 2000 ), \"hibiscus\" : random . randint ( 500 , 1000 ), \"tulip\" : random . randint ( 500 , 1000 ), \"rose\" : random . randint ( 500 , 1000 ), \"lucky_clover\" : random . randint ( 5 , 20 ), \"diamond\" : random . randint ( 10 , 20 ), \"debris\" : random . randint ( 0 , 4 ), } get_activity_loot get_activity_loot ( action_type : str , equipment_id : str , location : str , external_buffs : t . Sequence [ str ] = None ) -> t . Optional [ dict [ str , int ]] Return the loot generated by an equipment in a world. Parameters: Name Type Description Default action_type str The action's type. Either mine , explore , or chop . required equipment_id str The equipment's id. The function won't check for valid id. required location str The location's name. The function won't check for valid world. required external_buffs t . Sequence [ str ] A list of buffs' ids that can affect the drop. Example: ['luck_potion'] None Returns: Type Description t . Optional [ dict [ str , int ]] A dict denoting the loot table, or None if there's no matching loot table. Exceptions ValueError action_type value is invalid. Source code in categories/econ/loot.py 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 def get_activity_loot ( action_type : str , equipment_id : str , location : str , external_buffs : t . Sequence [ str ] = None ) -> t . Optional [ dict [ str , int ]]: '''Return the loot generated by an equipment in a world. Parameters ---------- action_type : str The action's type. Either `mine`, `explore`, or `chop`. equipment_id : str The equipment's id. The function won't check for valid id. location : str The location's name. The function won't check for valid world. external_buffs : t.Sequence[str] A list of buffs' ids that can affect the drop. Example: `['luck_potion']` Returns ------- t.Optional[dict[str, int]] A `dict` denoting the loot table, or `None` if there's no matching loot table. Exceptions ---------- ValueError `action_type` value is invalid. ''' if not external_buffs : external_buffs = [] reward : dict [ str , int ] = {} action_loot_table = None if action_type == \"mine\" : action_loot_table = __MINE_LOOT elif action_type == \"explore\" : action_loot_table = __EXPLORE_LOOT elif action_type == \"chop\" : action_loot_table = __CHOP_LOOT else : raise ValueError ( \"action_type argument must be either 'mine', 'explore', or 'chop'.\" ) world_loot = action_loot_table . get ( location ) if not world_loot : return None # Copy here cuz # - Can edit the rng. # - Copy world_loot is more expensive. equipment_loot = copy . deepcopy ( world_loot . get ( equipment_id )) if not equipment_loot : return None for item_id , rng in equipment_loot . items (): if item_id == \"raw_damage\" : reward [ item_id ] = rng . roll () continue if item_id == \"iron\" : if \"iron2\" in external_buffs : rng . rate += 0.10 elif item_id == \"diamond\" : if \"diamond1\" in external_buffs : rng . rate += 0.05 if \"diamond2\" in external_buffs : rng . rate += 0.10 rng . shift_min_amount ( 2 ) elif item_id == \"debris\" : if \"debris1\" in external_buffs : rng . rate += 0.025 if \"debris2\" in external_buffs : rng . rate += 0.05 rng . shift_min_amount ( 1 ) elif item_id == \"blaze_rod\" : if \"blaze1\" in external_buffs : rng . rate += 0.05 elif item_id == \"wood\" : if \"wood2\" in external_buffs : rng . shift_min_amount ( 2 ) reward [ item_id ] = rng . roll () if \"luck_potion\" in external_buffs : if reward [ item_id ] == 0 : reward [ item_id ] = rng . min_amount else : reward [ item_id ] = rng . max_amount return reward get_craft_recipe get_craft_recipe ( item_id : str ) -> t . Optional [ dict [ str , int ]] Return the crafting recipe for an item if existed. Notes The returning dict has a special key result , which denote how many items will be crafted out of the recipe. Parameters: Name Type Description Default item_id str The item's id. required Returns: Type Description t . Optional [ dict [ str , int ]] A dict denoting the crafting recipe, or None if no crafting recipe is found. Source code in categories/econ/loot.py 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 def get_craft_recipe ( item_id : str ) -> t . Optional [ dict [ str , int ]]: '''Return the crafting recipe for an item if existed. Notes ----- The returning `dict` has a special key `result`, which denote how many items will be crafted out of the recipe. Parameters ---------- item_id : str The item's id. Returns ------- t.Optional[dict[str, int]] A `dict` denoting the crafting recipe, or `None` if no crafting recipe is found. ''' return copy . deepcopy ( __CRAFT_RECIPE . get ( item_id )) get_brew_recipe get_brew_recipe ( potion_id : str ) -> t . Optional [ dict [ str , int ]] Return the brewing recipe for a potion if existed. Notes The returning dict has a special key result , which denote how many potions will be brewed out of the recipe. Parameters: Name Type Description Default potion_id str The potion's id. required Returns: Type Description t . Optional [ dict [ str , int ]] A dict denoting the brewing recipe, or None if no brewing recipe is found. Source code in categories/econ/loot.py 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 def get_brew_recipe ( potion_id : str ) -> t . Optional [ dict [ str , int ]]: '''Return the brewing recipe for a potion if existed. Notes ----- The returning `dict` has a special key `result`, which denote how many potions will be brewed out of the recipe. Parameters ---------- potion_id : str The potion's id. Returns ------- t.Optional[dict[str, int]] A `dict` denoting the brewing recipe, or `None` if no brewing recipe is found. ''' return copy . deepcopy ( __BREW_RECIPE . get ( potion_id )) roll_potion_activate roll_potion_activate ( potion_id : str ) -> bool Try to roll and see if the potion activated. Parameters: Name Type Description Default potion_id str The potion's id. required Returns: Type Description bool Whether the potion activated or not. Source code in categories/econ/loot.py 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 def roll_potion_activate ( potion_id : str ) -> bool : '''Try to roll and see if the potion activated. Parameters ---------- potion_id : str The potion's id. Returns ------- bool Whether the potion activated or not. ''' chance = __POTION_CHANCE . get ( potion_id , 0 ) if chance == 1 : return True return random . random () <= chance econ/trader.py generate_trades generate_trades ( item_cache : models . ItemCache , next_reset : dt . datetime , amount : int = 6 ) -> list [ psql . ActiveTrade ] Generate trades based on pre-determined rules. Parameters: Name Type Description Default item_cache models . ItemCache The bot's item cache. This is to get item's information. required next_reset dt . datetime When these trades will reset. required amount int , optional How many trade to generate, by default 6 6 Returns: Type Description list [ psql . ActiveTrade ] A list of trades to be added. Source code in categories/econ/trader.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def generate_trades ( item_cache : models . ItemCache , next_reset : dt . datetime , amount : int = 6 ) -> list [ psql . ActiveTrade ]: '''Generate trades based on pre-determined rules. Parameters ---------- item_cache : models.ItemCache The bot's item cache. This is to get item's information. next_reset : dt.datetime When these trades will reset. amount : int, optional How many trade to generate, by default 6 Returns ------- list[psql.ActiveTrade] A list of trades to be added. ''' trades = [] # Avoid duplicate trades. traded_item = [ \"money\" ] for i in range ( 1 , amount + 1 ): trade = psql . ActiveTrade ( i , \"trade\" , \"\" , 0 , \"\" , 0 , next_reset , 15 ) max_value_limit = random . randint ( 1 , 300 ) # item -> money if i == 1 : # Limit this, otherwise it'd be a free money maker strat. max_value_limit = random . randint ( 1 , 50 ) trade . hard_limit = 5 trade . item_dest = \"money\" trade . item_src = \"money\" while trade . item_src in traded_item : trade . item_src = random . choice ( __TRADE_WHITELIST ) traded_item . append ( trade . item_src ) # Get the item's value. item = item_cache [ trade . item_src ] src_price = item . sell_price # Force the current max to be at least the item's price so we can avoid amount = 0. max_value_limit = max ( max_value_limit , src_price ) # Get the max amount of item to not exceed the trade's current max value. src_max_amount = max_value_limit // src_price trade . amount_src = random . randint ( 1 , src_max_amount ) # Overvalue the item. trade . amount_dest = math . ceil ( trade . amount_src * src_price * ( 0.85 + random . random ())) # item -> item elif i == amount : # Select items so they don't go against each other. trade . item_src = \"money\" while trade . item_src in traded_item : trade . item_src = random . choice ( __TRADE_WHITELIST ) traded_item . append ( trade . item_src ) trade . item_dest = \"money\" while trade . item_dest in traded_item : trade . item_dest = random . choice ( __TRADE_WHITELIST ) traded_item . append ( trade . item_dest ) # Limit diamond trade. if trade . item_dest == \"diamond\" : trade . hard_limit = 5 if trade . item_dest == \"gold_apple\" : trade . hard_limit = 5 # Get the items' values. item_src = item_cache [ trade . item_src ] item_dest = item_cache [ trade . item_dest ] src_price = item_src . sell_price dest_price = item_dest . buy_price if not item_dest . buy_price : dest_price = item_dest . sell_price # Lower the limit if these are tools, otherwise you'll end up with super trash trades. if psql . Equipment . is_equipment ( item_src . id ) or psql . Equipment . is_equipment ( item_dest . id ): max_value_limit = 50 # Force the current max to be at least the item's price so we can avoid amount = 0. max_value_limit = max ( src_price , dest_price , max_value_limit ) # At this point we can guarantee the trade will have at least 1 on both side, we can safely get amount. src_max_amount = max_value_limit // src_price dest_max_amount = max_value_limit // dest_price if src_price > dest_price : trade . amount_src = random . randint ( 1 , src_max_amount ) trade . amount_dest = math . ceil (( trade . amount_src * src_price // dest_price ) * random . random ()) else : trade . amount_dest = random . randint ( 1 , dest_max_amount ) trade . amount_src = math . ceil (( trade . amount_dest * dest_price // src_price ) * random . random ()) # money -> item else : trade . item_src = \"money\" trade . item_dest = \"money\" while trade . item_dest in traded_item : trade . item_dest = random . choice ( __TRADE_WHITELIST ) traded_item . append ( trade . item_dest ) # Limit diamond trade. if trade . item_dest == \"diamond\" : trade . hard_limit = 5 if trade . item_dest == \"gold_apple\" : trade . hard_limit = 5 # Get the item's value. item = item_cache [ trade . item_dest ] dest_price = item . buy_price if not item . buy_price : dest_price = item . sell_price # Lower the limit if these are tools, otherwise you'll end up with super trash trades. if psql . Equipment . is_equipment ( item . id ): max_value_limit = 50 # Force the current max to be at least the item's price so we can avoid amount = 0. max_value_limit = max ( max_value_limit , dest_price ) # Get the max amount of item to not exceed the trade's current max value. dest_max_amount = max_value_limit // dest_price trade . amount_dest = random . randint ( 1 , dest_max_amount ) # Devalue the item, but also have a chance to overvalue the item. trade . amount_src = math . ceil ( trade . amount_dest * dest_price * ( 0.65 + random . random ())) trades . append ( trade ) return trades generate_barters generate_barters ( item_cache : models . ItemCache , next_reset : dt . datetime , amount : int = 9 ) -> list [ psql . ActiveTrade ] Generate barters based on pre-determined rules. Parameters: Name Type Description Default item_cache models . ItemCache The bot's item cache. This is to get item's information. required next_reset dt . datetime When these barters will reset. required amount int , optional How many barter to generate, by default 9 9 Returns: Type Description list [ psql . ActiveTrade ] A list of barters to be added. Source code in categories/econ/trader.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def generate_barters ( item_cache : models . ItemCache , next_reset : dt . datetime , amount : int = 9 ) -> list [ psql . ActiveTrade ]: '''Generate barters based on pre-determined rules. Parameters ---------- item_cache : models.ItemCache The bot's item cache. This is to get item's information. next_reset : dt.datetime When these barters will reset. amount : int, optional How many barter to generate, by default 9 Returns ------- list[psql.ActiveTrade] A list of barters to be added. ''' barters = [] # Avoid duplicate barters. bartered_items = [ \"gold\" ] for i in range ( 1 , amount + 1 ): barter = psql . ActiveTrade ( i , \"barter\" , \"\" , 0 , \"\" , 0 , next_reset , 20 ) max_value_limit = random . randint ( 1 , 600 ) if i == 1 : max_value_limit = random . randint ( 1 , 25 ) barter . hard_limit = 5 barter . item_dest = \"gold\" barter . item_src = \"gold\" while barter . item_src in bartered_items : barter . item_src = random . choice ( __BARTER_WHITELIST ) bartered_items . append ( barter . item_src ) else : barter . item_src = \"gold\" barter . item_dest = \"gold\" while barter . item_dest in bartered_items : barter . item_dest = random . choice ( __BARTER_WHITELIST ) bartered_items . append ( barter . item_dest ) # Get the items' values. item_src = item_cache [ barter . item_src ] item_dest = item_cache [ barter . item_dest ] src_price = item_src . sell_price dest_price = item_dest . buy_price if not item_dest . buy_price : dest_price = item_dest . sell_price # Avoid too overpower barter. if psql . Equipment . is_equipment ( barter . item_src ) or psql . Equipment . is_equipment ( barter . item_dest ): max_value_limit = 100 barter . hard_limit = 5 # Force the current max to be at least the item's price so we can avoid amount = 0. max_value_limit = max ( src_price , dest_price , max_value_limit ) # At this point we can guarantee the trade will have at least 1 on both side, we can safely get amount. src_max_amount = max_value_limit // src_price dest_max_amount = max_value_limit // dest_price if src_price > dest_price : barter . amount_src = random . randint ( 1 , src_max_amount ) barter . amount_dest = math . ceil (( barter . amount_src * src_price // dest_price ) * random . random ()) else : barter . amount_dest = random . randint ( 1 , dest_max_amount ) barter . amount_src = math . ceil (( barter . amount_dest * dest_price // src_price ) * random . random ()) barters . append ( barter ) return barters","title":"econ"},{"location":"dev/econ/#econlootpy","text":"Define the loot tables for the economy system and a bunch of constants.","title":"econ/loot.py"},{"location":"dev/econ/#categories.econ.loot.RewardRNG","text":"Define the RNG to randomize. This emulate 2 RNGs. The first RNG will determine whether or not to roll the second RNG. The second RNG will generate a number between the defined range, with a custom RNG behavior taken into account. Attributes: Name Type Description rate float Define the rate at which the second RNG will roll. Must be between 0 and 1. min_amount int Define the minimum number for the second RNG. This should be positive. max_amount int Define the maximum number for the second RNG. This should be positive. amount_layout tuple [ int ], optional Define the rng distribution between min_amount and max_amount . This must satisfy len(amount_layout) == (max_amount - min_amount + 1) and sum(amount_layout) == 100 Source code in categories/econ/loot.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 class RewardRNG : '''Define the RNG to randomize. This emulate 2 RNGs. The first RNG will determine whether or not to roll the second RNG. The second RNG will generate a number between the defined range, with a custom RNG behavior taken into account. Attributes ---------- rate : float Define the rate at which the second RNG will roll. Must be between 0 and 1. min_amount : int Define the minimum number for the second RNG. This should be positive. max_amount : int Define the maximum number for the second RNG. This should be positive. amount_layout : tuple[int], optional Define the rng distribution between `min_amount` and `max_amount`. This must satisfy `len(amount_layout) == (max_amount - min_amount + 1) and sum(amount_layout) == 100` ''' __slots__ = ( \"rate\" , \"min_amount\" , \"max_amount\" , \"amount_layout\" ) def __init__ ( self , rate : float , min_amount : int , max_amount : int , * , amount_layout : tuple [ int ] = None ): if rate < 0 or rate > 1 : raise ValueError ( \"'rate' must be in [0, 1].\" ) if min_amount > max_amount : raise ValueError ( \"'min_amount' must be smaller than or equal to 'max_amount'.\" ) if amount_layout : if len ( amount_layout ) != ( max_amount - min_amount + 1 ): raise ValueError ( \"'amount_layout' must have the same amount of items as (max_amount - min_amount + 1).\" ) if sum ( amount_layout ) != 100 : print ( sum ( amount_layout )) raise ValueError ( \"'amount_layout' must sum up to 100.\" ) self . rate = rate self . min_amount = min_amount self . max_amount = max_amount self . amount_layout = amount_layout def shift_min_amount ( self , amount : int ): self . min_amount += amount self . max_amount += amount def roll ( self ) -> int : '''Roll the RNG based on the provided information. Returns ------- int The number after randomizing. ''' if self . rate < 1 : r = random . random () if r > self . rate : return 0 if self . min_amount == self . max_amount : return self . min_amount if not self . amount_layout : return random . choice ( range ( self . min_amount , self . max_amount + 1 )) r = random . random () rate = 0 for index , amount_rate in enumerate ( self . amount_layout ): rate += amount_rate / 100.0 if r <= rate : return min ( self . min_amount + index , self . max_amount ) return self . max_amount","title":"RewardRNG"},{"location":"dev/econ/#categories.econ.loot.RewardRNG.roll","text":"roll () -> int Roll the RNG based on the provided information. Returns: Type Description int The number after randomizing. Source code in categories/econ/loot.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def roll ( self ) -> int : '''Roll the RNG based on the provided information. Returns ------- int The number after randomizing. ''' if self . rate < 1 : r = random . random () if r > self . rate : return 0 if self . min_amount == self . max_amount : return self . min_amount if not self . amount_layout : return random . choice ( range ( self . min_amount , self . max_amount + 1 )) r = random . random () rate = 0 for index , amount_rate in enumerate ( self . amount_layout ): rate += amount_rate / 100.0 if r <= rate : return min ( self . min_amount + index , self . max_amount ) return self . max_amount","title":"roll()"},{"location":"dev/econ/#categories.econ.loot.get_daily_loot","text":"get_daily_loot ( streak : int ) -> dict [ str , int ] Return the daily loot based on the current streak. Parameters: Name Type Description Default streak int The current streak. required Returns: Type Description dict [ str , int ] A dict denoting the loot table. Source code in categories/econ/loot.py 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 def get_daily_loot ( streak : int ) -> dict [ str , int ]: '''Return the daily loot based on the current streak. Parameters ---------- streak : int The current streak. Returns ------- dict[str, int] A `dict` denoting the loot table. ''' if streak <= 1 : return { \"money\" : 50 , \"wood\" : 5 } if streak <= 6 : return { \"money\" : 10 , \"wood\" : random . randint ( 10 , 15 ) } if streak <= 13 : return { \"money\" : 100 , \"bonus\" : streak , \"wood\" : random . randint ( 10 , 15 ), \"leaf\" : random . randint ( 50 , 60 ), \"hibiscus\" : random . randint ( 10 , 12 ), \"tulip\" : random . randint ( 10 , 12 ), \"rose\" : random . randint ( 10 , 12 ), } if streak <= 27 : return { \"money\" : 200 , \"bonus\" : 5 * streak , \"wood\" : random . randint ( 20 , 25 ), \"leaf\" : random . randint ( 100 , 110 ), \"hibiscus\" : random . randint ( 20 , 22 ), \"tulip\" : random . randint ( 20 , 22 ), \"rose\" : random . randint ( 20 , 22 ), } if streak <= 60 : return { \"money\" : 1000 , \"bonus\" : 2 * streak , \"wood\" : random . randint ( 50 , 55 ), \"leaf\" : random . randint ( 210 , 220 ), \"hibiscus\" : random . randint ( 50 , 52 ), \"tulip\" : random . randint ( 50 , 52 ), \"rose\" : random . randint ( 50 , 52 ), \"lucky_clover\" : random . randint ( 1 , 5 ), } if streak <= 90 : return { \"money\" : 2000 , \"bonus\" : 5 * streak , \"wood\" : random . randint ( 190 , 210 ), \"leaf\" : random . randint ( 190 , 210 ), \"hibiscus\" : random . randint ( 190 , 210 ), \"tulip\" : random . randint ( 190 , 210 ), \"rose\" : random . randint ( 190 , 210 ), \"lucky_clover\" : random . randint ( 1 , 10 ), } return { \"money\" : 5000 , \"bonus\" : 10 * streak , \"wood\" : random . randint ( 500 , 1000 ), \"leaf\" : random . randint ( 1000 , 2000 ), \"hibiscus\" : random . randint ( 500 , 1000 ), \"tulip\" : random . randint ( 500 , 1000 ), \"rose\" : random . randint ( 500 , 1000 ), \"lucky_clover\" : random . randint ( 5 , 20 ), \"diamond\" : random . randint ( 10 , 20 ), \"debris\" : random . randint ( 0 , 4 ), }","title":"get_daily_loot()"},{"location":"dev/econ/#categories.econ.loot.get_activity_loot","text":"get_activity_loot ( action_type : str , equipment_id : str , location : str , external_buffs : t . Sequence [ str ] = None ) -> t . Optional [ dict [ str , int ]] Return the loot generated by an equipment in a world. Parameters: Name Type Description Default action_type str The action's type. Either mine , explore , or chop . required equipment_id str The equipment's id. The function won't check for valid id. required location str The location's name. The function won't check for valid world. required external_buffs t . Sequence [ str ] A list of buffs' ids that can affect the drop. Example: ['luck_potion'] None Returns: Type Description t . Optional [ dict [ str , int ]] A dict denoting the loot table, or None if there's no matching loot table.","title":"get_activity_loot()"},{"location":"dev/econ/#categories.econ.loot.get_activity_loot--exceptions","text":"ValueError action_type value is invalid. Source code in categories/econ/loot.py 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 def get_activity_loot ( action_type : str , equipment_id : str , location : str , external_buffs : t . Sequence [ str ] = None ) -> t . Optional [ dict [ str , int ]]: '''Return the loot generated by an equipment in a world. Parameters ---------- action_type : str The action's type. Either `mine`, `explore`, or `chop`. equipment_id : str The equipment's id. The function won't check for valid id. location : str The location's name. The function won't check for valid world. external_buffs : t.Sequence[str] A list of buffs' ids that can affect the drop. Example: `['luck_potion']` Returns ------- t.Optional[dict[str, int]] A `dict` denoting the loot table, or `None` if there's no matching loot table. Exceptions ---------- ValueError `action_type` value is invalid. ''' if not external_buffs : external_buffs = [] reward : dict [ str , int ] = {} action_loot_table = None if action_type == \"mine\" : action_loot_table = __MINE_LOOT elif action_type == \"explore\" : action_loot_table = __EXPLORE_LOOT elif action_type == \"chop\" : action_loot_table = __CHOP_LOOT else : raise ValueError ( \"action_type argument must be either 'mine', 'explore', or 'chop'.\" ) world_loot = action_loot_table . get ( location ) if not world_loot : return None # Copy here cuz # - Can edit the rng. # - Copy world_loot is more expensive. equipment_loot = copy . deepcopy ( world_loot . get ( equipment_id )) if not equipment_loot : return None for item_id , rng in equipment_loot . items (): if item_id == \"raw_damage\" : reward [ item_id ] = rng . roll () continue if item_id == \"iron\" : if \"iron2\" in external_buffs : rng . rate += 0.10 elif item_id == \"diamond\" : if \"diamond1\" in external_buffs : rng . rate += 0.05 if \"diamond2\" in external_buffs : rng . rate += 0.10 rng . shift_min_amount ( 2 ) elif item_id == \"debris\" : if \"debris1\" in external_buffs : rng . rate += 0.025 if \"debris2\" in external_buffs : rng . rate += 0.05 rng . shift_min_amount ( 1 ) elif item_id == \"blaze_rod\" : if \"blaze1\" in external_buffs : rng . rate += 0.05 elif item_id == \"wood\" : if \"wood2\" in external_buffs : rng . shift_min_amount ( 2 ) reward [ item_id ] = rng . roll () if \"luck_potion\" in external_buffs : if reward [ item_id ] == 0 : reward [ item_id ] = rng . min_amount else : reward [ item_id ] = rng . max_amount return reward","title":"Exceptions"},{"location":"dev/econ/#categories.econ.loot.get_craft_recipe","text":"get_craft_recipe ( item_id : str ) -> t . Optional [ dict [ str , int ]] Return the crafting recipe for an item if existed.","title":"get_craft_recipe()"},{"location":"dev/econ/#categories.econ.loot.get_craft_recipe--notes","text":"The returning dict has a special key result , which denote how many items will be crafted out of the recipe. Parameters: Name Type Description Default item_id str The item's id. required Returns: Type Description t . Optional [ dict [ str , int ]] A dict denoting the crafting recipe, or None if no crafting recipe is found. Source code in categories/econ/loot.py 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 def get_craft_recipe ( item_id : str ) -> t . Optional [ dict [ str , int ]]: '''Return the crafting recipe for an item if existed. Notes ----- The returning `dict` has a special key `result`, which denote how many items will be crafted out of the recipe. Parameters ---------- item_id : str The item's id. Returns ------- t.Optional[dict[str, int]] A `dict` denoting the crafting recipe, or `None` if no crafting recipe is found. ''' return copy . deepcopy ( __CRAFT_RECIPE . get ( item_id ))","title":"Notes"},{"location":"dev/econ/#categories.econ.loot.get_brew_recipe","text":"get_brew_recipe ( potion_id : str ) -> t . Optional [ dict [ str , int ]] Return the brewing recipe for a potion if existed.","title":"get_brew_recipe()"},{"location":"dev/econ/#categories.econ.loot.get_brew_recipe--notes","text":"The returning dict has a special key result , which denote how many potions will be brewed out of the recipe. Parameters: Name Type Description Default potion_id str The potion's id. required Returns: Type Description t . Optional [ dict [ str , int ]] A dict denoting the brewing recipe, or None if no brewing recipe is found. Source code in categories/econ/loot.py 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 def get_brew_recipe ( potion_id : str ) -> t . Optional [ dict [ str , int ]]: '''Return the brewing recipe for a potion if existed. Notes ----- The returning `dict` has a special key `result`, which denote how many potions will be brewed out of the recipe. Parameters ---------- potion_id : str The potion's id. Returns ------- t.Optional[dict[str, int]] A `dict` denoting the brewing recipe, or `None` if no brewing recipe is found. ''' return copy . deepcopy ( __BREW_RECIPE . get ( potion_id ))","title":"Notes"},{"location":"dev/econ/#categories.econ.loot.roll_potion_activate","text":"roll_potion_activate ( potion_id : str ) -> bool Try to roll and see if the potion activated. Parameters: Name Type Description Default potion_id str The potion's id. required Returns: Type Description bool Whether the potion activated or not. Source code in categories/econ/loot.py 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 def roll_potion_activate ( potion_id : str ) -> bool : '''Try to roll and see if the potion activated. Parameters ---------- potion_id : str The potion's id. Returns ------- bool Whether the potion activated or not. ''' chance = __POTION_CHANCE . get ( potion_id , 0 ) if chance == 1 : return True return random . random () <= chance","title":"roll_potion_activate()"},{"location":"dev/econ/#econtraderpy","text":"","title":"econ/trader.py"},{"location":"dev/econ/#categories.econ.trader.generate_trades","text":"generate_trades ( item_cache : models . ItemCache , next_reset : dt . datetime , amount : int = 6 ) -> list [ psql . ActiveTrade ] Generate trades based on pre-determined rules. Parameters: Name Type Description Default item_cache models . ItemCache The bot's item cache. This is to get item's information. required next_reset dt . datetime When these trades will reset. required amount int , optional How many trade to generate, by default 6 6 Returns: Type Description list [ psql . ActiveTrade ] A list of trades to be added. Source code in categories/econ/trader.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def generate_trades ( item_cache : models . ItemCache , next_reset : dt . datetime , amount : int = 6 ) -> list [ psql . ActiveTrade ]: '''Generate trades based on pre-determined rules. Parameters ---------- item_cache : models.ItemCache The bot's item cache. This is to get item's information. next_reset : dt.datetime When these trades will reset. amount : int, optional How many trade to generate, by default 6 Returns ------- list[psql.ActiveTrade] A list of trades to be added. ''' trades = [] # Avoid duplicate trades. traded_item = [ \"money\" ] for i in range ( 1 , amount + 1 ): trade = psql . ActiveTrade ( i , \"trade\" , \"\" , 0 , \"\" , 0 , next_reset , 15 ) max_value_limit = random . randint ( 1 , 300 ) # item -> money if i == 1 : # Limit this, otherwise it'd be a free money maker strat. max_value_limit = random . randint ( 1 , 50 ) trade . hard_limit = 5 trade . item_dest = \"money\" trade . item_src = \"money\" while trade . item_src in traded_item : trade . item_src = random . choice ( __TRADE_WHITELIST ) traded_item . append ( trade . item_src ) # Get the item's value. item = item_cache [ trade . item_src ] src_price = item . sell_price # Force the current max to be at least the item's price so we can avoid amount = 0. max_value_limit = max ( max_value_limit , src_price ) # Get the max amount of item to not exceed the trade's current max value. src_max_amount = max_value_limit // src_price trade . amount_src = random . randint ( 1 , src_max_amount ) # Overvalue the item. trade . amount_dest = math . ceil ( trade . amount_src * src_price * ( 0.85 + random . random ())) # item -> item elif i == amount : # Select items so they don't go against each other. trade . item_src = \"money\" while trade . item_src in traded_item : trade . item_src = random . choice ( __TRADE_WHITELIST ) traded_item . append ( trade . item_src ) trade . item_dest = \"money\" while trade . item_dest in traded_item : trade . item_dest = random . choice ( __TRADE_WHITELIST ) traded_item . append ( trade . item_dest ) # Limit diamond trade. if trade . item_dest == \"diamond\" : trade . hard_limit = 5 if trade . item_dest == \"gold_apple\" : trade . hard_limit = 5 # Get the items' values. item_src = item_cache [ trade . item_src ] item_dest = item_cache [ trade . item_dest ] src_price = item_src . sell_price dest_price = item_dest . buy_price if not item_dest . buy_price : dest_price = item_dest . sell_price # Lower the limit if these are tools, otherwise you'll end up with super trash trades. if psql . Equipment . is_equipment ( item_src . id ) or psql . Equipment . is_equipment ( item_dest . id ): max_value_limit = 50 # Force the current max to be at least the item's price so we can avoid amount = 0. max_value_limit = max ( src_price , dest_price , max_value_limit ) # At this point we can guarantee the trade will have at least 1 on both side, we can safely get amount. src_max_amount = max_value_limit // src_price dest_max_amount = max_value_limit // dest_price if src_price > dest_price : trade . amount_src = random . randint ( 1 , src_max_amount ) trade . amount_dest = math . ceil (( trade . amount_src * src_price // dest_price ) * random . random ()) else : trade . amount_dest = random . randint ( 1 , dest_max_amount ) trade . amount_src = math . ceil (( trade . amount_dest * dest_price // src_price ) * random . random ()) # money -> item else : trade . item_src = \"money\" trade . item_dest = \"money\" while trade . item_dest in traded_item : trade . item_dest = random . choice ( __TRADE_WHITELIST ) traded_item . append ( trade . item_dest ) # Limit diamond trade. if trade . item_dest == \"diamond\" : trade . hard_limit = 5 if trade . item_dest == \"gold_apple\" : trade . hard_limit = 5 # Get the item's value. item = item_cache [ trade . item_dest ] dest_price = item . buy_price if not item . buy_price : dest_price = item . sell_price # Lower the limit if these are tools, otherwise you'll end up with super trash trades. if psql . Equipment . is_equipment ( item . id ): max_value_limit = 50 # Force the current max to be at least the item's price so we can avoid amount = 0. max_value_limit = max ( max_value_limit , dest_price ) # Get the max amount of item to not exceed the trade's current max value. dest_max_amount = max_value_limit // dest_price trade . amount_dest = random . randint ( 1 , dest_max_amount ) # Devalue the item, but also have a chance to overvalue the item. trade . amount_src = math . ceil ( trade . amount_dest * dest_price * ( 0.65 + random . random ())) trades . append ( trade ) return trades","title":"generate_trades()"},{"location":"dev/econ/#categories.econ.trader.generate_barters","text":"generate_barters ( item_cache : models . ItemCache , next_reset : dt . datetime , amount : int = 9 ) -> list [ psql . ActiveTrade ] Generate barters based on pre-determined rules. Parameters: Name Type Description Default item_cache models . ItemCache The bot's item cache. This is to get item's information. required next_reset dt . datetime When these barters will reset. required amount int , optional How many barter to generate, by default 9 9 Returns: Type Description list [ psql . ActiveTrade ] A list of barters to be added. Source code in categories/econ/trader.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def generate_barters ( item_cache : models . ItemCache , next_reset : dt . datetime , amount : int = 9 ) -> list [ psql . ActiveTrade ]: '''Generate barters based on pre-determined rules. Parameters ---------- item_cache : models.ItemCache The bot's item cache. This is to get item's information. next_reset : dt.datetime When these barters will reset. amount : int, optional How many barter to generate, by default 9 Returns ------- list[psql.ActiveTrade] A list of barters to be added. ''' barters = [] # Avoid duplicate barters. bartered_items = [ \"gold\" ] for i in range ( 1 , amount + 1 ): barter = psql . ActiveTrade ( i , \"barter\" , \"\" , 0 , \"\" , 0 , next_reset , 20 ) max_value_limit = random . randint ( 1 , 600 ) if i == 1 : max_value_limit = random . randint ( 1 , 25 ) barter . hard_limit = 5 barter . item_dest = \"gold\" barter . item_src = \"gold\" while barter . item_src in bartered_items : barter . item_src = random . choice ( __BARTER_WHITELIST ) bartered_items . append ( barter . item_src ) else : barter . item_src = \"gold\" barter . item_dest = \"gold\" while barter . item_dest in bartered_items : barter . item_dest = random . choice ( __BARTER_WHITELIST ) bartered_items . append ( barter . item_dest ) # Get the items' values. item_src = item_cache [ barter . item_src ] item_dest = item_cache [ barter . item_dest ] src_price = item_src . sell_price dest_price = item_dest . buy_price if not item_dest . buy_price : dest_price = item_dest . sell_price # Avoid too overpower barter. if psql . Equipment . is_equipment ( barter . item_src ) or psql . Equipment . is_equipment ( barter . item_dest ): max_value_limit = 100 barter . hard_limit = 5 # Force the current max to be at least the item's price so we can avoid amount = 0. max_value_limit = max ( src_price , dest_price , max_value_limit ) # At this point we can guarantee the trade will have at least 1 on both side, we can safely get amount. src_max_amount = max_value_limit // src_price dest_max_amount = max_value_limit // dest_price if src_price > dest_price : barter . amount_src = random . randint ( 1 , src_max_amount ) barter . amount_dest = math . ceil (( barter . amount_src * src_price // dest_price ) * random . random ()) else : barter . amount_dest = random . randint ( 1 , dest_max_amount ) barter . amount_src = math . ceil (( barter . amount_dest * dest_price // src_price ) * random . random ()) barters . append ( barter ) return barters","title":"generate_barters()"},{"location":"dev/errors/","text":"Custom exceptions (errors) to handle in global error handler. CustomAPIFailed Bases: hikari . HTTPError Exception raised when a third-party API call failed (not status 200). CustomCheckFailed Bases: lightbulb . CheckFailure Exception raised when a custom check (not lightbulb check) failed. NoDatabase Bases: CustomCheckFailed Exception raised when the bot doesn't have a database connection pool. NoHTTPClient Bases: CustomCheckFailed Exception raised when the bot doesn't have a http client. GuildDisabled Bases: CustomCheckFailed Exception raised when the guild disable the command. GuildBlacklisted Bases: CustomCheckFailed Exception raised when the guild is blacklisted by the bot's owner. UserBlacklisted Bases: CustomCheckFailed Exception raised when the user is blacklisted by the bot's owner.","title":"errors.py"},{"location":"dev/errors/#utils.errors.CustomAPIFailed","text":"Bases: hikari . HTTPError Exception raised when a third-party API call failed (not status 200).","title":"CustomAPIFailed"},{"location":"dev/errors/#utils.errors.CustomCheckFailed","text":"Bases: lightbulb . CheckFailure Exception raised when a custom check (not lightbulb check) failed.","title":"CustomCheckFailed"},{"location":"dev/errors/#utils.errors.NoDatabase","text":"Bases: CustomCheckFailed Exception raised when the bot doesn't have a database connection pool.","title":"NoDatabase"},{"location":"dev/errors/#utils.errors.NoHTTPClient","text":"Bases: CustomCheckFailed Exception raised when the bot doesn't have a http client.","title":"NoHTTPClient"},{"location":"dev/errors/#utils.errors.GuildDisabled","text":"Bases: CustomCheckFailed Exception raised when the guild disable the command.","title":"GuildDisabled"},{"location":"dev/errors/#utils.errors.GuildBlacklisted","text":"Bases: CustomCheckFailed Exception raised when the guild is blacklisted by the bot's owner.","title":"GuildBlacklisted"},{"location":"dev/errors/#utils.errors.UserBlacklisted","text":"Bases: CustomCheckFailed Exception raised when the user is blacklisted by the bot's owner.","title":"UserBlacklisted"},{"location":"dev/funtext/","text":"Contains funny text manipulations. pekofy pekofy ( text : str ) -> str A simple implementation of pekofy which simply adds peko at the end of a sentence. Parameters: Name Type Description Default text str The text to transform. required Returns: Type Description str The pekofy text. Source code in utils/funtext.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def pekofy ( text : str , / ) -> str : '''A simple implementation of `pekofy` which simply adds `peko` at the end of a sentence. Parameters ---------- text : str The text to transform. Returns ------- str The pekofy text. ''' words = text . split () for index , word in enumerate ( words ): for punc in [ '.' , '!' , '?' ]: if word . endswith ( punc ): words [ index ] = words [ index ][: - 1 ] + f \" peko { punc } \" if word == words [ - 1 ]: words [ index ] += \" peko\" return ' ' . join ( words ) uwuify uwuify ( text : str , / , * , allow_nyvowels = True , stutter_chance : float = 0.2 , emote_chance : float = 0.8 , action_chance : float = 0.05 ) -> str Transform a text into uwu text. Parameters: Name Type Description Default text str The text to transform. required allow_nyvowels bool , optional Whether or not to transform na , no , etc. into nya , nyo , etc. Default to True . True stutter_chance float , optional The chance to stutter a word. Must be [0, 1] . Default to 0.20 . 0.2 emote_chance float , optional The chance to put an emote after a punctuation like , or . Must be [0, 1] . Default to 0.8 . 0.8 action_chance float , optional The chance to put an action string after a word. Must be [0, 1] . Default to 0.05 . 0.05 Returns: Type Description str The uwu text. Source code in utils/funtext.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def uwuify ( text : str , / , * , allow_nyvowels = True , stutter_chance : float = 0.20 , emote_chance : float = 0.8 , action_chance : float = 0.05 ) -> str : '''Transform a text into uwu text. Parameters ---------- text : str The text to transform. allow_nyvowels : bool, optional Whether or not to transform `na`, `no`, etc. into `nya`, `nyo`, etc. Default to `True`. stutter_chance : float, optional The chance to stutter a word. Must be `[0, 1]`. Default to `0.20`. emote_chance : float, optional The chance to put an emote after a punctuation like `,` or `.` Must be `[0, 1]`. Default to `0.8`. action_chance : float, optional The chance to put an action string after a word. Must be `[0, 1]`. Default to `0.05`. Returns ------- str The uwu text. ''' words = text . split () for index , word in enumerate ( words ): words [ index ] = words [ index ] . replace ( 'l' , 'w' ) words [ index ] = words [ index ] . replace ( 'L' , 'W' ) words [ index ] = words [ index ] . replace ( 'r' , 'w' ) words [ index ] = words [ index ] . replace ( 'R' , 'W' ) if allow_nyvowels : words [ index ] = words [ index ] . replace ( \"na\" , \"nya\" ) words [ index ] = words [ index ] . replace ( \"Na\" , \"Nya\" ) words [ index ] = words [ index ] . replace ( \"NA\" , \"NyA\" ) words [ index ] = words [ index ] . replace ( \"ne\" , \"nye\" ) words [ index ] = words [ index ] . replace ( \"Ne\" , \"Nye\" ) words [ index ] = words [ index ] . replace ( \"NE\" , \"NyE\" ) words [ index ] = words [ index ] . replace ( \"no\" , \"nyo\" ) words [ index ] = words [ index ] . replace ( \"No\" , \"Nyo\" ) words [ index ] = words [ index ] . replace ( \"NO\" , \"NyO\" ) words [ index ] = words [ index ] . replace ( \"nu\" , \"yu\" ) words [ index ] = words [ index ] . replace ( \"Nu\" , \"Nyu\" ) words [ index ] = words [ index ] . replace ( \"NU\" , \"NyU\" ) if word in __REPLACE_WORDS : words [ index ] = __REPLACE_WORDS [ word ] is_stutter = random . random () if is_stutter <= stutter_chance : words [ index ] = f \" { words [ index ][ 0 ] } - { words [ index ] } \" is_emote = random . random () if is_emote <= emote_chance and words [ index ] . endswith (( '.' , '?' , '!' , ',' )): words [ index ] += random . choice ( __RANDOM_EMOTES ) is_action = random . random () if is_action <= action_chance : words [ index ] += random . choice ( __RANDOM_ACTIONS ) return ' ' . join ( words )","title":"funtext.py"},{"location":"dev/funtext/#utils.funtext.pekofy","text":"pekofy ( text : str ) -> str A simple implementation of pekofy which simply adds peko at the end of a sentence. Parameters: Name Type Description Default text str The text to transform. required Returns: Type Description str The pekofy text. Source code in utils/funtext.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def pekofy ( text : str , / ) -> str : '''A simple implementation of `pekofy` which simply adds `peko` at the end of a sentence. Parameters ---------- text : str The text to transform. Returns ------- str The pekofy text. ''' words = text . split () for index , word in enumerate ( words ): for punc in [ '.' , '!' , '?' ]: if word . endswith ( punc ): words [ index ] = words [ index ][: - 1 ] + f \" peko { punc } \" if word == words [ - 1 ]: words [ index ] += \" peko\" return ' ' . join ( words )","title":"pekofy()"},{"location":"dev/funtext/#utils.funtext.uwuify","text":"uwuify ( text : str , / , * , allow_nyvowels = True , stutter_chance : float = 0.2 , emote_chance : float = 0.8 , action_chance : float = 0.05 ) -> str Transform a text into uwu text. Parameters: Name Type Description Default text str The text to transform. required allow_nyvowels bool , optional Whether or not to transform na , no , etc. into nya , nyo , etc. Default to True . True stutter_chance float , optional The chance to stutter a word. Must be [0, 1] . Default to 0.20 . 0.2 emote_chance float , optional The chance to put an emote after a punctuation like , or . Must be [0, 1] . Default to 0.8 . 0.8 action_chance float , optional The chance to put an action string after a word. Must be [0, 1] . Default to 0.05 . 0.05 Returns: Type Description str The uwu text. Source code in utils/funtext.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def uwuify ( text : str , / , * , allow_nyvowels = True , stutter_chance : float = 0.20 , emote_chance : float = 0.8 , action_chance : float = 0.05 ) -> str : '''Transform a text into uwu text. Parameters ---------- text : str The text to transform. allow_nyvowels : bool, optional Whether or not to transform `na`, `no`, etc. into `nya`, `nyo`, etc. Default to `True`. stutter_chance : float, optional The chance to stutter a word. Must be `[0, 1]`. Default to `0.20`. emote_chance : float, optional The chance to put an emote after a punctuation like `,` or `.` Must be `[0, 1]`. Default to `0.8`. action_chance : float, optional The chance to put an action string after a word. Must be `[0, 1]`. Default to `0.05`. Returns ------- str The uwu text. ''' words = text . split () for index , word in enumerate ( words ): words [ index ] = words [ index ] . replace ( 'l' , 'w' ) words [ index ] = words [ index ] . replace ( 'L' , 'W' ) words [ index ] = words [ index ] . replace ( 'r' , 'w' ) words [ index ] = words [ index ] . replace ( 'R' , 'W' ) if allow_nyvowels : words [ index ] = words [ index ] . replace ( \"na\" , \"nya\" ) words [ index ] = words [ index ] . replace ( \"Na\" , \"Nya\" ) words [ index ] = words [ index ] . replace ( \"NA\" , \"NyA\" ) words [ index ] = words [ index ] . replace ( \"ne\" , \"nye\" ) words [ index ] = words [ index ] . replace ( \"Ne\" , \"Nye\" ) words [ index ] = words [ index ] . replace ( \"NE\" , \"NyE\" ) words [ index ] = words [ index ] . replace ( \"no\" , \"nyo\" ) words [ index ] = words [ index ] . replace ( \"No\" , \"Nyo\" ) words [ index ] = words [ index ] . replace ( \"NO\" , \"NyO\" ) words [ index ] = words [ index ] . replace ( \"nu\" , \"yu\" ) words [ index ] = words [ index ] . replace ( \"Nu\" , \"Nyu\" ) words [ index ] = words [ index ] . replace ( \"NU\" , \"NyU\" ) if word in __REPLACE_WORDS : words [ index ] = __REPLACE_WORDS [ word ] is_stutter = random . random () if is_stutter <= stutter_chance : words [ index ] = f \" { words [ index ][ 0 ] } - { words [ index ] } \" is_emote = random . random () if is_emote <= emote_chance and words [ index ] . endswith (( '.' , '?' , '!' , ',' )): words [ index ] += random . choice ( __RANDOM_EMOTES ) is_action = random . random () if is_action <= action_chance : words [ index ] += random . choice ( __RANDOM_ACTIONS ) return ' ' . join ( words )","title":"uwuify()"},{"location":"dev/help/","text":"Define the behavior of the 'help' command for the bot. Includes help-specific utilities. MenuLikeHelp Bases: lightbulb . DefaultHelpCommand A custom help command that's tailored for MichaelBot . Source code in categories/help.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 class MenuLikeHelp ( lightbulb . DefaultHelpCommand ): ''' A custom help command that's tailored for `MichaelBot`. ''' async def send_help ( self , ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None : ''' The main logic for the help command. ''' bot : models . MichaelBot = self . bot # Reference: https://github.com/tandemdude/hikari-lightbulb/blob/development/lightbulb/help_command.py#L100 if obj is None : await self . send_bot_help ( ctx ) return # Prioritize searching command based on context. if isinstance ( ctx , lightbulb . PrefixContext ): cmd = bot . get_prefix_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . PrefixCommandGroup , lightbulb . PrefixSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) if isinstance ( ctx , lightbulb . SlashContext ): cmd = bot . get_slash_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) # We don't have user/message commands yet. await super () . send_help ( ctx , obj ) async def send_bot_help ( self , ctx : lightbulb . Context ) -> None : ''' Send a generic help message. ''' if isinstance ( ctx , lightbulb . PrefixContext ): await ctx . event . message . delete () main_page = helpers . get_default_embed ( title = \"Help\" , description = \"\" , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) plugins = ctx . bot . plugins # {plugin_name: command_count} plugin_info : dict [ str , int ] = {} for plugin in plugins . values (): public_commands = [] if isinstance ( ctx , lightbulb . PrefixContext ): public_commands = filter_command_type ( plugin . all_commands , __PREFIX_COMMAND_TYPES__ , True ) else : public_commands = filter_command_type ( plugin . all_commands , __SLASH_COMMAND_TYPES__ , True ) public_commands_len = len ( public_commands ) if public_commands_len > 0 : embed_name = f \" { plugin . d . emote } { plugin . name } ( { public_commands_len } commands)\" embed_description = \"*No description provided*\" if bool ( plugin . description ): embed_description = plugin . description main_page . add_field ( name = embed_name , value = embed_description , inline = False ) plugin_info [ plugin . name ] = public_commands_len menu_root = nav . MenuComponent ( main_page ) for name in plugin_info : menu_root . add_list_options ( nav . MenuButton ( label = name , emoji = plugins [ name ] . d . emote , ), plugin_help_format ( ctx , plugins [ name ]) ) await nav . ComplexView ( menu_root , authors = ( ctx . author . id ,)) . run ( ctx ) async def send_plugin_help ( self , ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None : ''' Send a plugin help that contains all commands. ''' embeds = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ public_commands = filter_command_type ( plugin . all_commands , types , True ) for command in sorted ( public_commands , key = lambda cmd : cmd . name ): page = command_help_format ( ctx , command ) if page is not None : embeds . append ( page ) page_nav = nav . ButtonNavigator ( pages = embeds , authors = ( ctx . author . id ,)) await nav . run_view ( page_nav , ctx ) async def send_command_help ( self , ctx : lightbulb . Context , command : lightbulb . Command ) -> None : ''' Send a command help. ''' await ctx . respond ( embed = command_help_format ( ctx , command )) async def send_group_help ( self , ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None : ''' Send a group help. Internally, this does the same as `send_command_help()`. ''' await ctx . respond ( embed = command_help_format ( ctx , group )) send_help async send_help ( ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None The main logic for the help command. Source code in categories/help.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 async def send_help ( self , ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None : ''' The main logic for the help command. ''' bot : models . MichaelBot = self . bot # Reference: https://github.com/tandemdude/hikari-lightbulb/blob/development/lightbulb/help_command.py#L100 if obj is None : await self . send_bot_help ( ctx ) return # Prioritize searching command based on context. if isinstance ( ctx , lightbulb . PrefixContext ): cmd = bot . get_prefix_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . PrefixCommandGroup , lightbulb . PrefixSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) if isinstance ( ctx , lightbulb . SlashContext ): cmd = bot . get_slash_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) # We don't have user/message commands yet. await super () . send_help ( ctx , obj ) send_bot_help async send_bot_help ( ctx : lightbulb . Context ) -> None Send a generic help message. Source code in categories/help.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 async def send_bot_help ( self , ctx : lightbulb . Context ) -> None : ''' Send a generic help message. ''' if isinstance ( ctx , lightbulb . PrefixContext ): await ctx . event . message . delete () main_page = helpers . get_default_embed ( title = \"Help\" , description = \"\" , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) plugins = ctx . bot . plugins # {plugin_name: command_count} plugin_info : dict [ str , int ] = {} for plugin in plugins . values (): public_commands = [] if isinstance ( ctx , lightbulb . PrefixContext ): public_commands = filter_command_type ( plugin . all_commands , __PREFIX_COMMAND_TYPES__ , True ) else : public_commands = filter_command_type ( plugin . all_commands , __SLASH_COMMAND_TYPES__ , True ) public_commands_len = len ( public_commands ) if public_commands_len > 0 : embed_name = f \" { plugin . d . emote } { plugin . name } ( { public_commands_len } commands)\" embed_description = \"*No description provided*\" if bool ( plugin . description ): embed_description = plugin . description main_page . add_field ( name = embed_name , value = embed_description , inline = False ) plugin_info [ plugin . name ] = public_commands_len menu_root = nav . MenuComponent ( main_page ) for name in plugin_info : menu_root . add_list_options ( nav . MenuButton ( label = name , emoji = plugins [ name ] . d . emote , ), plugin_help_format ( ctx , plugins [ name ]) ) await nav . ComplexView ( menu_root , authors = ( ctx . author . id ,)) . run ( ctx ) send_plugin_help async send_plugin_help ( ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None Send a plugin help that contains all commands. Source code in categories/help.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 async def send_plugin_help ( self , ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None : ''' Send a plugin help that contains all commands. ''' embeds = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ public_commands = filter_command_type ( plugin . all_commands , types , True ) for command in sorted ( public_commands , key = lambda cmd : cmd . name ): page = command_help_format ( ctx , command ) if page is not None : embeds . append ( page ) page_nav = nav . ButtonNavigator ( pages = embeds , authors = ( ctx . author . id ,)) await nav . run_view ( page_nav , ctx ) send_command_help async send_command_help ( ctx : lightbulb . Context , command : lightbulb . Command ) -> None Send a command help. Source code in categories/help.py 319 320 321 322 323 async def send_command_help ( self , ctx : lightbulb . Context , command : lightbulb . Command ) -> None : ''' Send a command help. ''' await ctx . respond ( embed = command_help_format ( ctx , command )) send_group_help async send_group_help ( ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None Send a group help. Internally, this does the same as send_command_help() . Source code in categories/help.py 324 325 326 327 328 329 330 async def send_group_help ( self , ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None : ''' Send a group help. Internally, this does the same as `send_command_help()`. ''' await ctx . respond ( embed = command_help_format ( ctx , group )) filter_command_type filter_command_type ( commands : t . Sequence [ lightbulb . Command ], types : t . Sequence [ t . Type ], remove_hidden : bool = False ) -> t . List [ lightbulb . Command ] Filter commands with one of the type mentioned in types . Parameters: Name Type Description Default commands t . Sequence [ lightbulb . Command ] A sequence of commands. required types t . Sequence [ t . Type ] A sequence of command's types to filter. Example: (lightbulb.PrefixCommand, lightbulb.SlashCommand) . required remove_hidden bool , optional Whether or not to remove hidden commands. Default to False . False Returns: Type Description t . List [ lightbulb . Command ] A list of commands filtered out by types. Source code in categories/help.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def filter_command_type ( commands : t . Sequence [ lightbulb . Command ], types : t . Sequence [ t . Type ], remove_hidden : bool = False ) -> t . List [ lightbulb . Command ]: '''Filter commands with one of the type mentioned in `types`. Parameters ---------- commands : t.Sequence[lightbulb.Command] A sequence of commands. types : t.Sequence[t.Type] A sequence of command's types to filter. Example: `(lightbulb.PrefixCommand, lightbulb.SlashCommand)`. remove_hidden : bool, optional Whether or not to remove hidden commands. Default to `False`. Returns ------- t.List[lightbulb.Command] A list of commands filtered out by types. ''' l = [] for command in commands : if isinstance ( command , types ): if ( not remove_hidden ) or ( remove_hidden and not command . hidden ): l . append ( command ) return l plugin_help_format plugin_help_format ( ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> t . List [ hikari . Embed ] Return a list of formatted embed for a plugin help. This list can be passed into a paginator to display. Parameters: Name Type Description Default ctx lightbulb . Context The context. required plugin lightbulb . Plugin The plugin to display the help. required Returns: Type Description t . List [ hikari . Embed ] A list of formatted embed for a plugin help. Source code in categories/help.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def plugin_help_format ( ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> t . List [ hikari . Embed ]: '''Return a list of formatted embed for a plugin help. This list can be passed into a paginator to display. Parameters ---------- ctx : lightbulb.Context The context. plugin : lightbulb.Plugin The plugin to display the help. Returns ------- t.List[hikari.Embed] A list of formatted embed for a plugin help. ''' MAX_COMMANDS = 10 display = \"\" plugins = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ commands : t . List [ lightbulb . Command ] = filter_command_type ( plugin . all_commands , types , True ) commands . sort ( key = lambda command : command . name ) for index , command in enumerate ( commands ): # Signature includes command name. command_title = command . signature . replace ( '=' , ' = ' ) display += f \"** { command_title } :** \\n \" # Strip the first word of the description, which is the category's name. description = ' ' . join ( command . description . split ()[ 1 :]) if not description : description = \"*No help provided*\" display += f \"- { description } \\n\\n \" if index == MAX_COMMANDS - 1 or index == len ( commands ) - 1 : title = f \" { plugin . name } ( { len ( commands ) } commands):\" embed = helpers . get_default_embed ( title = title , description = display , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) . set_thumbnail ( ctx . bot . get_me () . avatar_url ) plugins . append ( embed ) display = \"\" return plugins command_help_format command_help_format ( ctx : lightbulb . Context , command : lightbulb . Command ) -> hikari . Embed Return a formatted embed for a command help. Notes For command group, the embed will also include all subcommands. Parameters: Name Type Description Default ctx lightbulb . Context The context. required command lightbulb . Command The command to display the help. Can also be a command group/subcommand/... required Returns: Type Description hikari . Embed The formatted embed for a command help. Source code in categories/help.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def command_help_format ( ctx : lightbulb . Context , command : lightbulb . Command ) -> hikari . Embed : '''Return a formatted embed for a command help. Notes ----- For command group, the embed will also include all subcommands. Parameters ---------- ctx : lightbulb.Context The context. command : lightbulb.Command The command to display the help. Can also be a command group/subcommand/... Returns ------- hikari.Embed The formatted embed for a command help. ''' bot : models . MichaelBot = ctx . bot # Signature includes full command name. embed_title = command . signature . replace ( '=' , ' = ' ) embed_description = \"*No help provided*\" if command . description != \"\" : # Strip the first word of the description, which is the category's name. embed_description = ' ' . join ( command . description . split ()[ 1 :]) + ' \\n ' embed = helpers . get_default_embed ( title = embed_title , description = embed_description , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) command_type = [] p_cmd = bot . get_prefix_command ( command . qualname ) s_cmd = bot . get_slash_command ( command . qualname ) m_cmd = bot . get_message_command ( command . qualname ) u_cmd = bot . get_user_command ( command . qualname ) if p_cmd is not None : command_type . append ( \"`Prefix Command`\" ) if s_cmd is not None and not isinstance ( s_cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): command_type . append ( \"`Slash Command`\" ) if m_cmd is not None : command_type . append ( \"`Message Command`\" ) if u_cmd is not None : command_type . append ( \"`User Command`\" ) embed . add_field ( name = \"Type\" , value = ' ' . join ( command_type ) ) if len ( command . options ) > 0 : option_field = \"\" for option in command . options . values (): option_field += f \"- ` { option . name } `: { option . description } \\n \" embed . add_field ( name = \"Parameters\" , value = option_field ) if len ( command . aliases ) > 0 and isinstance ( command , __PREFIX_COMMAND_TYPES__ ): embed . add_field ( name = \"Aliases (Prefix Command only)\" , value = \"- \" + ', ' . join ( f \"` { alias } `\" for alias in command . aliases ) ) if bool ( command . get_help ( ctx )): embed . add_field ( name = \"Note\" , value = dedent ( command . get_help ( ctx )) ) if isinstance ( command , __COMMAND_GROUPS_TYPES__ ): field_value = \"\" subcommands = command . subcommands . values () types = __PREFIX_COMMAND_TYPES__ # Can't check with ctx, since SlashContext can call a PrefixCommandGroup. if isinstance ( command , __SLASH_COMMAND_TYPES__ ): types = __SLASH_COMMAND_TYPES__ for subcommand in sorted ( filter_command_type ( subcommands , types , True ), key = lambda cmd : cmd . name ): field_value += f \"- ` { subcommand . name } `: { ' ' . join ( subcommand . description . split ()[ 1 :]) } \\n \" if len ( command . subcommands ) > 0 : embed . add_field ( name = \"**Subcommands:**\" , value = field_value , inline = False ) return embed","title":"help.py"},{"location":"dev/help/#categories.help.MenuLikeHelp","text":"Bases: lightbulb . DefaultHelpCommand A custom help command that's tailored for MichaelBot . Source code in categories/help.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 class MenuLikeHelp ( lightbulb . DefaultHelpCommand ): ''' A custom help command that's tailored for `MichaelBot`. ''' async def send_help ( self , ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None : ''' The main logic for the help command. ''' bot : models . MichaelBot = self . bot # Reference: https://github.com/tandemdude/hikari-lightbulb/blob/development/lightbulb/help_command.py#L100 if obj is None : await self . send_bot_help ( ctx ) return # Prioritize searching command based on context. if isinstance ( ctx , lightbulb . PrefixContext ): cmd = bot . get_prefix_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . PrefixCommandGroup , lightbulb . PrefixSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) if isinstance ( ctx , lightbulb . SlashContext ): cmd = bot . get_slash_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) # We don't have user/message commands yet. await super () . send_help ( ctx , obj ) async def send_bot_help ( self , ctx : lightbulb . Context ) -> None : ''' Send a generic help message. ''' if isinstance ( ctx , lightbulb . PrefixContext ): await ctx . event . message . delete () main_page = helpers . get_default_embed ( title = \"Help\" , description = \"\" , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) plugins = ctx . bot . plugins # {plugin_name: command_count} plugin_info : dict [ str , int ] = {} for plugin in plugins . values (): public_commands = [] if isinstance ( ctx , lightbulb . PrefixContext ): public_commands = filter_command_type ( plugin . all_commands , __PREFIX_COMMAND_TYPES__ , True ) else : public_commands = filter_command_type ( plugin . all_commands , __SLASH_COMMAND_TYPES__ , True ) public_commands_len = len ( public_commands ) if public_commands_len > 0 : embed_name = f \" { plugin . d . emote } { plugin . name } ( { public_commands_len } commands)\" embed_description = \"*No description provided*\" if bool ( plugin . description ): embed_description = plugin . description main_page . add_field ( name = embed_name , value = embed_description , inline = False ) plugin_info [ plugin . name ] = public_commands_len menu_root = nav . MenuComponent ( main_page ) for name in plugin_info : menu_root . add_list_options ( nav . MenuButton ( label = name , emoji = plugins [ name ] . d . emote , ), plugin_help_format ( ctx , plugins [ name ]) ) await nav . ComplexView ( menu_root , authors = ( ctx . author . id ,)) . run ( ctx ) async def send_plugin_help ( self , ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None : ''' Send a plugin help that contains all commands. ''' embeds = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ public_commands = filter_command_type ( plugin . all_commands , types , True ) for command in sorted ( public_commands , key = lambda cmd : cmd . name ): page = command_help_format ( ctx , command ) if page is not None : embeds . append ( page ) page_nav = nav . ButtonNavigator ( pages = embeds , authors = ( ctx . author . id ,)) await nav . run_view ( page_nav , ctx ) async def send_command_help ( self , ctx : lightbulb . Context , command : lightbulb . Command ) -> None : ''' Send a command help. ''' await ctx . respond ( embed = command_help_format ( ctx , command )) async def send_group_help ( self , ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None : ''' Send a group help. Internally, this does the same as `send_command_help()`. ''' await ctx . respond ( embed = command_help_format ( ctx , group ))","title":"MenuLikeHelp"},{"location":"dev/help/#categories.help.MenuLikeHelp.send_help","text":"send_help ( ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None The main logic for the help command. Source code in categories/help.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 async def send_help ( self , ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None : ''' The main logic for the help command. ''' bot : models . MichaelBot = self . bot # Reference: https://github.com/tandemdude/hikari-lightbulb/blob/development/lightbulb/help_command.py#L100 if obj is None : await self . send_bot_help ( ctx ) return # Prioritize searching command based on context. if isinstance ( ctx , lightbulb . PrefixContext ): cmd = bot . get_prefix_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . PrefixCommandGroup , lightbulb . PrefixSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) if isinstance ( ctx , lightbulb . SlashContext ): cmd = bot . get_slash_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) # We don't have user/message commands yet. await super () . send_help ( ctx , obj )","title":"send_help()"},{"location":"dev/help/#categories.help.MenuLikeHelp.send_bot_help","text":"send_bot_help ( ctx : lightbulb . Context ) -> None Send a generic help message. Source code in categories/help.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 async def send_bot_help ( self , ctx : lightbulb . Context ) -> None : ''' Send a generic help message. ''' if isinstance ( ctx , lightbulb . PrefixContext ): await ctx . event . message . delete () main_page = helpers . get_default_embed ( title = \"Help\" , description = \"\" , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) plugins = ctx . bot . plugins # {plugin_name: command_count} plugin_info : dict [ str , int ] = {} for plugin in plugins . values (): public_commands = [] if isinstance ( ctx , lightbulb . PrefixContext ): public_commands = filter_command_type ( plugin . all_commands , __PREFIX_COMMAND_TYPES__ , True ) else : public_commands = filter_command_type ( plugin . all_commands , __SLASH_COMMAND_TYPES__ , True ) public_commands_len = len ( public_commands ) if public_commands_len > 0 : embed_name = f \" { plugin . d . emote } { plugin . name } ( { public_commands_len } commands)\" embed_description = \"*No description provided*\" if bool ( plugin . description ): embed_description = plugin . description main_page . add_field ( name = embed_name , value = embed_description , inline = False ) plugin_info [ plugin . name ] = public_commands_len menu_root = nav . MenuComponent ( main_page ) for name in plugin_info : menu_root . add_list_options ( nav . MenuButton ( label = name , emoji = plugins [ name ] . d . emote , ), plugin_help_format ( ctx , plugins [ name ]) ) await nav . ComplexView ( menu_root , authors = ( ctx . author . id ,)) . run ( ctx )","title":"send_bot_help()"},{"location":"dev/help/#categories.help.MenuLikeHelp.send_plugin_help","text":"send_plugin_help ( ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None Send a plugin help that contains all commands. Source code in categories/help.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 async def send_plugin_help ( self , ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None : ''' Send a plugin help that contains all commands. ''' embeds = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ public_commands = filter_command_type ( plugin . all_commands , types , True ) for command in sorted ( public_commands , key = lambda cmd : cmd . name ): page = command_help_format ( ctx , command ) if page is not None : embeds . append ( page ) page_nav = nav . ButtonNavigator ( pages = embeds , authors = ( ctx . author . id ,)) await nav . run_view ( page_nav , ctx )","title":"send_plugin_help()"},{"location":"dev/help/#categories.help.MenuLikeHelp.send_command_help","text":"send_command_help ( ctx : lightbulb . Context , command : lightbulb . Command ) -> None Send a command help. Source code in categories/help.py 319 320 321 322 323 async def send_command_help ( self , ctx : lightbulb . Context , command : lightbulb . Command ) -> None : ''' Send a command help. ''' await ctx . respond ( embed = command_help_format ( ctx , command ))","title":"send_command_help()"},{"location":"dev/help/#categories.help.MenuLikeHelp.send_group_help","text":"send_group_help ( ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None Send a group help. Internally, this does the same as send_command_help() . Source code in categories/help.py 324 325 326 327 328 329 330 async def send_group_help ( self , ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None : ''' Send a group help. Internally, this does the same as `send_command_help()`. ''' await ctx . respond ( embed = command_help_format ( ctx , group ))","title":"send_group_help()"},{"location":"dev/help/#categories.help.filter_command_type","text":"filter_command_type ( commands : t . Sequence [ lightbulb . Command ], types : t . Sequence [ t . Type ], remove_hidden : bool = False ) -> t . List [ lightbulb . Command ] Filter commands with one of the type mentioned in types . Parameters: Name Type Description Default commands t . Sequence [ lightbulb . Command ] A sequence of commands. required types t . Sequence [ t . Type ] A sequence of command's types to filter. Example: (lightbulb.PrefixCommand, lightbulb.SlashCommand) . required remove_hidden bool , optional Whether or not to remove hidden commands. Default to False . False Returns: Type Description t . List [ lightbulb . Command ] A list of commands filtered out by types. Source code in categories/help.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def filter_command_type ( commands : t . Sequence [ lightbulb . Command ], types : t . Sequence [ t . Type ], remove_hidden : bool = False ) -> t . List [ lightbulb . Command ]: '''Filter commands with one of the type mentioned in `types`. Parameters ---------- commands : t.Sequence[lightbulb.Command] A sequence of commands. types : t.Sequence[t.Type] A sequence of command's types to filter. Example: `(lightbulb.PrefixCommand, lightbulb.SlashCommand)`. remove_hidden : bool, optional Whether or not to remove hidden commands. Default to `False`. Returns ------- t.List[lightbulb.Command] A list of commands filtered out by types. ''' l = [] for command in commands : if isinstance ( command , types ): if ( not remove_hidden ) or ( remove_hidden and not command . hidden ): l . append ( command ) return l","title":"filter_command_type()"},{"location":"dev/help/#categories.help.plugin_help_format","text":"plugin_help_format ( ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> t . List [ hikari . Embed ] Return a list of formatted embed for a plugin help. This list can be passed into a paginator to display. Parameters: Name Type Description Default ctx lightbulb . Context The context. required plugin lightbulb . Plugin The plugin to display the help. required Returns: Type Description t . List [ hikari . Embed ] A list of formatted embed for a plugin help. Source code in categories/help.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def plugin_help_format ( ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> t . List [ hikari . Embed ]: '''Return a list of formatted embed for a plugin help. This list can be passed into a paginator to display. Parameters ---------- ctx : lightbulb.Context The context. plugin : lightbulb.Plugin The plugin to display the help. Returns ------- t.List[hikari.Embed] A list of formatted embed for a plugin help. ''' MAX_COMMANDS = 10 display = \"\" plugins = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ commands : t . List [ lightbulb . Command ] = filter_command_type ( plugin . all_commands , types , True ) commands . sort ( key = lambda command : command . name ) for index , command in enumerate ( commands ): # Signature includes command name. command_title = command . signature . replace ( '=' , ' = ' ) display += f \"** { command_title } :** \\n \" # Strip the first word of the description, which is the category's name. description = ' ' . join ( command . description . split ()[ 1 :]) if not description : description = \"*No help provided*\" display += f \"- { description } \\n\\n \" if index == MAX_COMMANDS - 1 or index == len ( commands ) - 1 : title = f \" { plugin . name } ( { len ( commands ) } commands):\" embed = helpers . get_default_embed ( title = title , description = display , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) . set_thumbnail ( ctx . bot . get_me () . avatar_url ) plugins . append ( embed ) display = \"\" return plugins","title":"plugin_help_format()"},{"location":"dev/help/#categories.help.command_help_format","text":"command_help_format ( ctx : lightbulb . Context , command : lightbulb . Command ) -> hikari . Embed Return a formatted embed for a command help.","title":"command_help_format()"},{"location":"dev/help/#categories.help.command_help_format--notes","text":"For command group, the embed will also include all subcommands. Parameters: Name Type Description Default ctx lightbulb . Context The context. required command lightbulb . Command The command to display the help. Can also be a command group/subcommand/... required Returns: Type Description hikari . Embed The formatted embed for a command help. Source code in categories/help.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def command_help_format ( ctx : lightbulb . Context , command : lightbulb . Command ) -> hikari . Embed : '''Return a formatted embed for a command help. Notes ----- For command group, the embed will also include all subcommands. Parameters ---------- ctx : lightbulb.Context The context. command : lightbulb.Command The command to display the help. Can also be a command group/subcommand/... Returns ------- hikari.Embed The formatted embed for a command help. ''' bot : models . MichaelBot = ctx . bot # Signature includes full command name. embed_title = command . signature . replace ( '=' , ' = ' ) embed_description = \"*No help provided*\" if command . description != \"\" : # Strip the first word of the description, which is the category's name. embed_description = ' ' . join ( command . description . split ()[ 1 :]) + ' \\n ' embed = helpers . get_default_embed ( title = embed_title , description = embed_description , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) command_type = [] p_cmd = bot . get_prefix_command ( command . qualname ) s_cmd = bot . get_slash_command ( command . qualname ) m_cmd = bot . get_message_command ( command . qualname ) u_cmd = bot . get_user_command ( command . qualname ) if p_cmd is not None : command_type . append ( \"`Prefix Command`\" ) if s_cmd is not None and not isinstance ( s_cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): command_type . append ( \"`Slash Command`\" ) if m_cmd is not None : command_type . append ( \"`Message Command`\" ) if u_cmd is not None : command_type . append ( \"`User Command`\" ) embed . add_field ( name = \"Type\" , value = ' ' . join ( command_type ) ) if len ( command . options ) > 0 : option_field = \"\" for option in command . options . values (): option_field += f \"- ` { option . name } `: { option . description } \\n \" embed . add_field ( name = \"Parameters\" , value = option_field ) if len ( command . aliases ) > 0 and isinstance ( command , __PREFIX_COMMAND_TYPES__ ): embed . add_field ( name = \"Aliases (Prefix Command only)\" , value = \"- \" + ', ' . join ( f \"` { alias } `\" for alias in command . aliases ) ) if bool ( command . get_help ( ctx )): embed . add_field ( name = \"Note\" , value = dedent ( command . get_help ( ctx )) ) if isinstance ( command , __COMMAND_GROUPS_TYPES__ ): field_value = \"\" subcommands = command . subcommands . values () types = __PREFIX_COMMAND_TYPES__ # Can't check with ctx, since SlashContext can call a PrefixCommandGroup. if isinstance ( command , __SLASH_COMMAND_TYPES__ ): types = __SLASH_COMMAND_TYPES__ for subcommand in sorted ( filter_command_type ( subcommands , types , True ), key = lambda cmd : cmd . name ): field_value += f \"- ` { subcommand . name } `: { ' ' . join ( subcommand . description . split ()[ 1 :]) } \\n \" if len ( command . subcommands ) > 0 : embed . add_field ( name = \"**Subcommands:**\" , value = field_value , inline = False ) return embed","title":"Notes"},{"location":"dev/helpers/","text":"Contains many useful constants and functions. get_emote get_emote ( discord_text : str ) -> str Return the Unicode emoji based on the name provided. Parameters: Name Type Description Default discord_text str Discord/Twitter name of the emoji including : . Example: :grin: . required Returns: Type Description str The Unicode emoji matching the text. Raises: Type Description KeyError Cannot find the emoji based on the text. Source code in utils/helpers.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def get_emote ( discord_text : str , / ) -> str : '''Return the Unicode emoji based on the name provided. Parameters ---------- discord_text : str Discord/Twitter name of the emoji including `:`. Example: `:grin:`. Returns ------- str The Unicode emoji matching the text. Raises ------ KeyError Cannot find the emoji based on the text. ''' ret = emoji . emojize ( discord_text , language = \"alias\" ) if ret == discord_text : raise KeyError ( f \"Emoji { discord_text } cannot be found.\" ) return ret get_friendly_permissions get_friendly_permissions ( permissions : hikari . Permissions ) -> t . List [ str ] Return a list of highlighted permissions string presented in the permission provided. This returns the exact Discord's string of the permission. Parameters: Name Type Description Default permissions hikari . Permissions A permission object. required Returns: Type Description t . List [ str ] A list of highlighted permissions string represented in the permission provided. Notes Manage Events cannot be found in Hikari's documentation. Therefore, it is not included. Source code in utils/helpers.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def get_friendly_permissions ( permissions : hikari . Permissions , / ) -> t . List [ str ]: '''Return a list of highlighted permissions string presented in the permission provided. This returns the exact Discord's string of the permission. Parameters ---------- permissions : hikari.Permissions A permission object. Returns ------- t.List[str] A list of highlighted permissions string represented in the permission provided. Notes ----- `Manage Events` cannot be found in Hikari's documentation. Therefore, it is not included. ''' l = [] for permission , text in __PERMISSIONS_MAPPING__ . items (): if permissions & permission : l . append ( f \"` { text } `\" ) return l get_default_embed get_default_embed ( * , author : hikari . Member = None , ** kwargs ) -> hikari . Embed Return a default embed to work with for consistency. Args: author: The author to set in the footer. **kwargs: hikari.Embed constructor. Parameters: Name Type Description Default author hikari . Member , optional The author to set in the footer. If not provided, the footer will not be edited. None **kwargs dict The options passed into hikari.Embed() . {} Returns: Type Description hikari . Embed The default embed. Source code in utils/helpers.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def get_default_embed ( * , author : hikari . Member = None , ** kwargs ) -> hikari . Embed : '''Return a default embed to work with for consistency. Args: author: The author to set in the footer. **kwargs: `hikari.Embed` constructor. Parameters ---------- author : hikari.Member, optional The author to set in the footer. If not provided, the footer will not be edited. **kwargs : dict The options passed into `hikari.Embed()`. Returns ------- hikari.Embed The default embed. ''' title = kwargs . get ( \"title\" ) url = kwargs . get ( \"url\" ) description = kwargs . get ( \"description\" ) color = kwargs . get ( \"color\" ) if kwargs . get ( \"color\" ) is not None else models . DefaultColor . green timestamp = kwargs . get ( \"timestamp\" ) embed = hikari . Embed ( title = title , url = url , description = description , color = color , timestamp = timestamp ) if author is not None : embed . set_footer ( text = f \"Requested by { author . username } \" , icon = author . avatar_url ) return embed mention mention ( mentionable_object : t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ]) -> str Return the appropriate mention string for a mentionable object. Parameters: Name Type Description Default mentionable_object t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ] The object to mention. required Returns: Type Description str The object's default mention string. Notes If the object is a hikari.PartialRole and it has the name @everyone , it'll return the name directly. Source code in utils/helpers.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def mention ( mentionable_object : t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ], / ) -> str : '''Return the appropriate mention string for a mentionable object. Parameters ---------- mentionable_object : t.Union[hikari.PartialUser, hikari.PartialRole, hikari.TextableGuildChannel] The object to mention. Returns ------- str The object's default mention string. Notes ----- If the object is a `hikari.PartialRole` and it has the name `@everyone`, it'll return the name directly. ''' if isinstance ( mentionable_object , hikari . PartialRole ): if mentionable_object . name == \"@everyone\" : return mentionable_object . name return mentionable_object . mention sleep_until async sleep_until ( when : dt . datetime ) Wait until the specified time. Parameters: Name Type Description Default when dt . datetime The time to resume. Must be tz aware and in utc. required Source code in utils/helpers.py 203 204 205 206 207 208 209 210 211 212 213 async def sleep_until ( when : dt . datetime , / ): '''Wait until the specified time. Parameters ---------- when : dt.datetime The time to resume. Must be tz aware and in utc. ''' time = when - dt . datetime . now () . astimezone () if time . total_seconds () > 0 : await asyncio . sleep ( time . total_seconds ())","title":"helpers.py"},{"location":"dev/helpers/#utils.helpers.get_emote","text":"get_emote ( discord_text : str ) -> str Return the Unicode emoji based on the name provided. Parameters: Name Type Description Default discord_text str Discord/Twitter name of the emoji including : . Example: :grin: . required Returns: Type Description str The Unicode emoji matching the text. Raises: Type Description KeyError Cannot find the emoji based on the text. Source code in utils/helpers.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def get_emote ( discord_text : str , / ) -> str : '''Return the Unicode emoji based on the name provided. Parameters ---------- discord_text : str Discord/Twitter name of the emoji including `:`. Example: `:grin:`. Returns ------- str The Unicode emoji matching the text. Raises ------ KeyError Cannot find the emoji based on the text. ''' ret = emoji . emojize ( discord_text , language = \"alias\" ) if ret == discord_text : raise KeyError ( f \"Emoji { discord_text } cannot be found.\" ) return ret","title":"get_emote()"},{"location":"dev/helpers/#utils.helpers.get_friendly_permissions","text":"get_friendly_permissions ( permissions : hikari . Permissions ) -> t . List [ str ] Return a list of highlighted permissions string presented in the permission provided. This returns the exact Discord's string of the permission. Parameters: Name Type Description Default permissions hikari . Permissions A permission object. required Returns: Type Description t . List [ str ] A list of highlighted permissions string represented in the permission provided.","title":"get_friendly_permissions()"},{"location":"dev/helpers/#utils.helpers.get_friendly_permissions--notes","text":"Manage Events cannot be found in Hikari's documentation. Therefore, it is not included. Source code in utils/helpers.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def get_friendly_permissions ( permissions : hikari . Permissions , / ) -> t . List [ str ]: '''Return a list of highlighted permissions string presented in the permission provided. This returns the exact Discord's string of the permission. Parameters ---------- permissions : hikari.Permissions A permission object. Returns ------- t.List[str] A list of highlighted permissions string represented in the permission provided. Notes ----- `Manage Events` cannot be found in Hikari's documentation. Therefore, it is not included. ''' l = [] for permission , text in __PERMISSIONS_MAPPING__ . items (): if permissions & permission : l . append ( f \"` { text } `\" ) return l","title":"Notes"},{"location":"dev/helpers/#utils.helpers.get_default_embed","text":"get_default_embed ( * , author : hikari . Member = None , ** kwargs ) -> hikari . Embed Return a default embed to work with for consistency. Args: author: The author to set in the footer. **kwargs: hikari.Embed constructor. Parameters: Name Type Description Default author hikari . Member , optional The author to set in the footer. If not provided, the footer will not be edited. None **kwargs dict The options passed into hikari.Embed() . {} Returns: Type Description hikari . Embed The default embed. Source code in utils/helpers.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def get_default_embed ( * , author : hikari . Member = None , ** kwargs ) -> hikari . Embed : '''Return a default embed to work with for consistency. Args: author: The author to set in the footer. **kwargs: `hikari.Embed` constructor. Parameters ---------- author : hikari.Member, optional The author to set in the footer. If not provided, the footer will not be edited. **kwargs : dict The options passed into `hikari.Embed()`. Returns ------- hikari.Embed The default embed. ''' title = kwargs . get ( \"title\" ) url = kwargs . get ( \"url\" ) description = kwargs . get ( \"description\" ) color = kwargs . get ( \"color\" ) if kwargs . get ( \"color\" ) is not None else models . DefaultColor . green timestamp = kwargs . get ( \"timestamp\" ) embed = hikari . Embed ( title = title , url = url , description = description , color = color , timestamp = timestamp ) if author is not None : embed . set_footer ( text = f \"Requested by { author . username } \" , icon = author . avatar_url ) return embed","title":"get_default_embed()"},{"location":"dev/helpers/#utils.helpers.mention","text":"mention ( mentionable_object : t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ]) -> str Return the appropriate mention string for a mentionable object. Parameters: Name Type Description Default mentionable_object t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ] The object to mention. required Returns: Type Description str The object's default mention string.","title":"mention()"},{"location":"dev/helpers/#utils.helpers.mention--notes","text":"If the object is a hikari.PartialRole and it has the name @everyone , it'll return the name directly. Source code in utils/helpers.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def mention ( mentionable_object : t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ], / ) -> str : '''Return the appropriate mention string for a mentionable object. Parameters ---------- mentionable_object : t.Union[hikari.PartialUser, hikari.PartialRole, hikari.TextableGuildChannel] The object to mention. Returns ------- str The object's default mention string. Notes ----- If the object is a `hikari.PartialRole` and it has the name `@everyone`, it'll return the name directly. ''' if isinstance ( mentionable_object , hikari . PartialRole ): if mentionable_object . name == \"@everyone\" : return mentionable_object . name return mentionable_object . mention","title":"Notes"},{"location":"dev/helpers/#utils.helpers.sleep_until","text":"sleep_until ( when : dt . datetime ) Wait until the specified time. Parameters: Name Type Description Default when dt . datetime The time to resume. Must be tz aware and in utc. required Source code in utils/helpers.py 203 204 205 206 207 208 209 210 211 212 213 async def sleep_until ( when : dt . datetime , / ): '''Wait until the specified time. Parameters ---------- when : dt.datetime The time to resume. Must be tz aware and in utc. ''' time = when - dt . datetime . now () . astimezone () if time . total_seconds () > 0 : await asyncio . sleep ( time . total_seconds ())","title":"sleep_until()"},{"location":"dev/menu/","text":"nav/navigator.py Contains common forms of menu navigator. StopButtonDelete Bases: nav . StopButton A custom button to stop the navigator AND delete the message. This button should only be used in nav.NavigatorView . Source code in utils/nav/navigator.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class StopButtonDelete ( nav . StopButton ): ''' A custom button to stop the navigator AND delete the message. This button should only be used in `nav.NavigatorView`. ''' async def callback ( self , context : miru . Context ) -> None : # Reference: https://github.com/HyperGH/hikari-miru/blob/main/miru/ext/nav/buttons.py#L239 #pylint: disable=protected-access view : nav . NavigatorView = self . view if not view . message and not view . _inter : return if view . _inter and view . ephemeral : await view . _inter . delete_initial_response () elif view . message : await view . message . delete () #pylint: enable=protected-access view . stop () ButtonNavigator Bases: nav . NavigatorView The default navigator. Source code in utils/nav/navigator.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 class ButtonNavigator ( nav . NavigatorView ): ''' The default navigator. ''' def __init__ ( self , * args , ** kwargs ) -> None : '''Construct a default navigator. Parameters ---------- pages : list[str | hikari.Embed] A list of content to be displayed. buttons : list[nav.NavButton], optional A list of buttons to display. It is safe to ignore this parameter for most use cases. timeout : float, optional The amount of seconds before the view time out. Default to `120.0`. autodefer : bool, optional Whether the view will handle deferred response. It is safe to ignore this parameter for most use cases. Default to `True`. authors : t.Sequence[int], optional A list of ids that are allowed to interact with this view. Default to `None`. ''' self . _author_ids : t . Optional [ t . Sequence [ int ]] = kwargs . pop ( \"authors\" , None ) super () . __init__ ( * args , ** kwargs ) for index , item in enumerate ( self . pages ): if isinstance ( item , hikari . Embed ): item . set_footer ( f \"Page { index + 1 } / { len ( self . pages ) } \" ) def get_default_buttons ( self ) -> t . List [ nav . NavButton [ nav . NavigatorView ]]: ''' Returns a list of default buttons. These are `FirstButton()`, `PrevButton()`, `NextButton()`, `LastButton()`, and `StopButtonDelete()`. Returns ------- t.List[nav.NavButton[nav.NavigatorView]] A list of default buttons. ''' return [ nav . FirstButton (), nav . PrevButton (), nav . NextButton (), nav . LastButton (), StopButtonDelete ()] async def view_check ( self , context : miru . Context ) -> bool : if not self . _author_ids : return True if context . user . id not in self . _author_ids : await context . respond ( \"You're not allowed to interact with this menu!\" , flags = hikari . MessageFlag . EPHEMERAL ) return context . user . id in self . _author_ids async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout () __init__ __init__ ( * args , ** kwargs ) -> None Construct a default navigator. Parameters: Name Type Description Default pages list [ str | hikari . Embed ] A list of content to be displayed. required buttons list [ nav . NavButton ], optional A list of buttons to display. It is safe to ignore this parameter for most use cases. required timeout float , optional The amount of seconds before the view time out. Default to 120.0 . required autodefer bool , optional Whether the view will handle deferred response. It is safe to ignore this parameter for most use cases. Default to True . required authors t . Sequence [ int ], optional A list of ids that are allowed to interact with this view. Default to None . required Source code in utils/nav/navigator.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def __init__ ( self , * args , ** kwargs ) -> None : '''Construct a default navigator. Parameters ---------- pages : list[str | hikari.Embed] A list of content to be displayed. buttons : list[nav.NavButton], optional A list of buttons to display. It is safe to ignore this parameter for most use cases. timeout : float, optional The amount of seconds before the view time out. Default to `120.0`. autodefer : bool, optional Whether the view will handle deferred response. It is safe to ignore this parameter for most use cases. Default to `True`. authors : t.Sequence[int], optional A list of ids that are allowed to interact with this view. Default to `None`. ''' self . _author_ids : t . Optional [ t . Sequence [ int ]] = kwargs . pop ( \"authors\" , None ) super () . __init__ ( * args , ** kwargs ) for index , item in enumerate ( self . pages ): if isinstance ( item , hikari . Embed ): item . set_footer ( f \"Page { index + 1 } / { len ( self . pages ) } \" ) get_default_buttons get_default_buttons () -> t . List [ nav . NavButton [ nav . NavigatorView ]] Returns a list of default buttons. These are FirstButton() , PrevButton() , NextButton() , LastButton() , and StopButtonDelete() . Returns: Type Description t . List [ nav . NavButton [ nav . NavigatorView ]] A list of default buttons. Source code in utils/nav/navigator.py 117 118 119 120 121 122 123 124 125 126 127 128 def get_default_buttons ( self ) -> t . List [ nav . NavButton [ nav . NavigatorView ]]: ''' Returns a list of default buttons. These are `FirstButton()`, `PrevButton()`, `NextButton()`, `LastButton()`, and `StopButtonDelete()`. Returns ------- t.List[nav.NavButton[nav.NavigatorView]] A list of default buttons. ''' return [ nav . FirstButton (), nav . PrevButton (), nav . NextButton (), nav . LastButton (), StopButtonDelete ()] on_timeout async on_timeout () -> None Called when the view times out. Notes This adds the timeout button into the menu. Source code in utils/nav/navigator.py 139 140 141 142 143 144 145 146 147 148 async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout () ItemListBuilder A builder to fit a list of item into a navigator appropriately. (This is experimental and can be removed at any time). Source code in utils/nav/navigator.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 class ItemListBuilder : '''A builder to fit a list of item into a navigator appropriately. (This is experimental and can be removed at any time).''' def __init__ ( self , items : list [ T ], max_item_per_page : int ): '''Construct the builder. Parameters ---------- items : list[T] A list of items. max_item_per_page : int The max amount of item to display before moving to a new page. ''' self . items = items self . max_item = max_item_per_page self . page_start_formatter : t . Callable [[ int , T ], hikari . Embed ] = None self . entry_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = None self . page_end_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = lambda embed , index , item : None def set_page_start_formatter ( self , callback : t . Callable [[ int , T ], hikari . Embed ], / ): '''Set this callback as the formatter to run whenever a new page is requested to be created. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[int, T], hikari.Embed] The callback to use. It must accept an `int` (index of the item), the item itself, and return a `hikari.Embed`. ''' self . page_start_formatter = callback def set_entry_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run while iterating through the item list. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . entry_formatter = callback def set_page_end_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run once adding items to a page is finished. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . page_end_formatter = callback def build ( self , * , page_type = ButtonNavigator , authors : t . Sequence [ int ] = None ): '''Start the formatting process and return an object of `page_type`. Warnings -------- The builder must provide at least `page_start_formatter` and either `entry_formatter` or `page_end_formatter` before this method is called. Parameters ---------- page_type : t.Type, optional The type of navigator to use, by default ButtonNavigator. This must have a `pages` argument accepting a list of `hikari.Embed` and a `authors` argument accepting a list of ids. authors : t.Sequence[int], optional The ids of people that are allowed to interact with the navigator. Default to `None`. Returns ------- t.Any The type passed into the constructor, by default ButtonNavigator. Raises ------ NotImplementedError `page_start_formatter` is empty or both `entry_formatter` and `page_end_formatter` are empty. ''' if self . page_start_formatter is None or ( self . entry_formatter is None and self . page_end_formatter is None ): raise NotImplementedError ( \"Not enough formatters are defined.\" ) embeds : list [ hikari . Embed ] = [] embed : hikari . Embed = None for index , item in enumerate ( self . items ): if embed is None : embed = self . page_start_formatter ( index , item ) self . entry_formatter ( embed , index , item ) if index % self . max_item == self . max_item - 1 : self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) embed = None if embed is not None : # TODO: Fix undefined-loop-variable self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) return page_type ( pages = embeds , authors = authors ) __init__ __init__ ( items : list [ T ], max_item_per_page : int ) Construct the builder. Parameters: Name Type Description Default items list [ T ] A list of items. required max_item_per_page int The max amount of item to display before moving to a new page. required Source code in utils/nav/navigator.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def __init__ ( self , items : list [ T ], max_item_per_page : int ): '''Construct the builder. Parameters ---------- items : list[T] A list of items. max_item_per_page : int The max amount of item to display before moving to a new page. ''' self . items = items self . max_item = max_item_per_page self . page_start_formatter : t . Callable [[ int , T ], hikari . Embed ] = None self . entry_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = None self . page_end_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = lambda embed , index , item : None set_page_start_formatter set_page_start_formatter ( callback : t . Callable [[ int , T ], hikari . Embed ]) Set this callback as the formatter to run whenever a new page is requested to be created. Notes This is recommended to use as a decorator. Parameters: Name Type Description Default callback t . Callable [[ int , T ], hikari . Embed ] The callback to use. It must accept an int (index of the item), the item itself, and return a hikari.Embed . required Source code in utils/nav/navigator.py 170 171 172 173 174 175 176 177 178 179 180 181 182 def set_page_start_formatter ( self , callback : t . Callable [[ int , T ], hikari . Embed ], / ): '''Set this callback as the formatter to run whenever a new page is requested to be created. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[int, T], hikari.Embed] The callback to use. It must accept an `int` (index of the item), the item itself, and return a `hikari.Embed`. ''' self . page_start_formatter = callback set_entry_formatter set_entry_formatter ( callback : t . Callable [[ hikari . Embed , int , T ], None ]) Set this callback as the formatter to run while iterating through the item list. Notes This is recommended to use as a decorator. Parameters: Name Type Description Default callback t . Callable [[ hikari . Embed , int , T ], None] The callback to use. It must accept a hikari.Embed (the page it's editing), an int (index of the item), and the item itself. required Source code in utils/nav/navigator.py 183 184 185 186 187 188 189 190 191 192 193 194 195 def set_entry_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run while iterating through the item list. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . entry_formatter = callback set_page_end_formatter set_page_end_formatter ( callback : t . Callable [[ hikari . Embed , int , T ], None ]) Set this callback as the formatter to run once adding items to a page is finished. Notes This is recommended to use as a decorator. Parameters: Name Type Description Default callback t . Callable [[ hikari . Embed , int , T ], None] The callback to use. It must accept a hikari.Embed (the page it's editing), an int (index of the item), and the item itself. required Source code in utils/nav/navigator.py 196 197 198 199 200 201 202 203 204 205 206 207 208 def set_page_end_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run once adding items to a page is finished. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . page_end_formatter = callback build build ( * , page_type = ButtonNavigator , authors : t . Sequence [ int ] = None ) Start the formatting process and return an object of page_type . Warnings The builder must provide at least page_start_formatter and either entry_formatter or page_end_formatter before this method is called. Parameters: Name Type Description Default page_type t . Type , optional The type of navigator to use, by default ButtonNavigator. This must have a pages argument accepting a list of hikari.Embed and a authors argument accepting a list of ids. ButtonNavigator authors t . Sequence [ int ], optional The ids of people that are allowed to interact with the navigator. Default to None . None Returns: Type Description t . Any The type passed into the constructor, by default ButtonNavigator. Raises: Type Description NotImplementedError page_start_formatter is empty or both entry_formatter and page_end_formatter are empty. Source code in utils/nav/navigator.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def build ( self , * , page_type = ButtonNavigator , authors : t . Sequence [ int ] = None ): '''Start the formatting process and return an object of `page_type`. Warnings -------- The builder must provide at least `page_start_formatter` and either `entry_formatter` or `page_end_formatter` before this method is called. Parameters ---------- page_type : t.Type, optional The type of navigator to use, by default ButtonNavigator. This must have a `pages` argument accepting a list of `hikari.Embed` and a `authors` argument accepting a list of ids. authors : t.Sequence[int], optional The ids of people that are allowed to interact with the navigator. Default to `None`. Returns ------- t.Any The type passed into the constructor, by default ButtonNavigator. Raises ------ NotImplementedError `page_start_formatter` is empty or both `entry_formatter` and `page_end_formatter` are empty. ''' if self . page_start_formatter is None or ( self . entry_formatter is None and self . page_end_formatter is None ): raise NotImplementedError ( \"Not enough formatters are defined.\" ) embeds : list [ hikari . Embed ] = [] embed : hikari . Embed = None for index , item in enumerate ( self . items ): if embed is None : embed = self . page_start_formatter ( index , item ) self . entry_formatter ( embed , index , item ) if index % self . max_item == self . max_item - 1 : self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) embed = None if embed is not None : # TODO: Fix undefined-loop-variable self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) return page_type ( pages = embeds , authors = authors ) run_view async run_view ( view : miru . View , ctx : lightbulb . Context , initial_content : t . Union [ str , hikari . Embed ] = None ) -> None A simplified way to run a miru.View . Parameters: Name Type Description Default view miru . View A miru.View or its subclasses. required ctx lightbulb . Context A context to send the view. required initial_content t . Union [ str , hikari . Embed ], optional The content to first display. This is optional for nav.NavigatorView and its subclasses. None Raises: Type Description TypeError initial_content is not provided, but view is not type nav.NavigatorView . hikari . BadRequestError Maybe ctx is deferred. Source code in utils/nav/navigator.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 async def run_view ( view : miru . View , ctx : lightbulb . Context , initial_content : t . Union [ str , hikari . Embed ] = None ) -> None : '''A simplified way to run a `miru.View`. Parameters ---------- view : miru.View A `miru.View` or its subclasses. ctx : lightbulb.Context A context to send the view. initial_content : t.Union[str, hikari.Embed], optional The content to first display. This is optional for `nav.NavigatorView` and its subclasses. Raises ------ TypeError `initial_content` is not provided, but `view` is not type `nav.NavigatorView`. hikari.BadRequestError Maybe `ctx` is deferred. ''' if initial_content is None : if isinstance ( view , nav . NavigatorView ): # nav.NavigatorView cannot be run on an interaction with a response already (typically deferring) # so we have to do things manually here. # Reference: https://github.com/HyperGH/hikari-miru/blob/main/miru/ext/nav/navigator.py#L227 for button in view . children : if isinstance ( button , nav . NavButton ): await button . before_page_change () initial_content = view . pages [ view . current_page ] #await view.send(ctx.interaction) #return else : raise TypeError ( \"'initial_content' must be provided if 'view' is not type 'NavigatorView'.\" ) resp_proxy = await ctx . respond ( initial_content , components = view . build ()) view . start ( await resp_proxy . message ()) await view . wait () timeout_button timeout_button () -> nav . NavButton Return a nav.NavButton to be use in nav.NavigatorView . This button is safe to use in miru.View . Returns: Type Description nav . NavButton The default timeout button. Source code in utils/nav/navigator.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def timeout_button () -> nav . NavButton : '''Return a `nav.NavButton` to be use in `nav.NavigatorView`. This button is safe to use in `miru.View`. Returns ------- nav.NavButton The default timeout button. ''' return nav . NavButton ( style = hikari . ButtonStyle . SECONDARY , emoji = helpers . get_emote ( \":clock12:\" ), custom_id = \"timeout_button\" , disabled = True ) nav/confirm.py Contains a confirmation menu. ConfirmView Bases: miru . View A confirmation menu. Source code in utils/nav/confirm.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class ConfirmView ( miru . View ): ''' A confirmation menu. ''' def __init__ ( self , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True , authors : t . Sequence [ int ] = None ) -> None : self . _author_ids = authors super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . result : t . Optional [ bool ] = None async def view_check ( self , context : miru . Context ) -> bool : if not self . _author_ids : return True if context . user . id not in self . _author_ids : await context . respond ( \"You're not allowed to interact with this menu!\" , flags = hikari . MessageFlag . EPHEMERAL ) return context . user . id in self . _author_ids @miru . button ( label = \"Yes\" , emoji = helpers . get_emote ( \":white_check_mark:\" ), style = hikari . ButtonStyle . SUCCESS , custom_id = \"yes_button\" ) async def yes_button ( self , _ : miru . Button , __ : miru . Context ): self . result = True self . stop () @miru . button ( label = \"No\" , emoji = helpers . get_emote ( \":negative_squared_cross_mark:\" ), style = hikari . ButtonStyle . DANGER , custom_id = \"no_button\" ) async def no_button ( self , _ : miru . Button , __ : miru . Context ): self . result = False self . stop () async def wait ( self ) -> t . Optional [ bool ]: ''' Wait until the view times out or stops manually. Return the result of the confirmation, or `None` if it times out. ''' await super () . wait () await self . message . delete () return self . result wait async wait () -> t . Optional [ bool ] Wait until the view times out or stops manually. Return the result of the confirmation, or None if it times out. Source code in utils/nav/confirm.py 39 40 41 42 43 44 45 46 47 48 async def wait ( self ) -> t . Optional [ bool ]: ''' Wait until the view times out or stops manually. Return the result of the confirmation, or `None` if it times out. ''' await super () . wait () await self . message . delete () return self . result nav/menu.py Contains everything needed to build a complex menu. MenuComponent A tree-like node that represents the menu's option structure. The node has two \"states\": a regular node state and a fake node. A regular node state is when the options is a dictionary, which will determine the child nodes. A fake node state is when the options is a list of contents to display. In this case, the node's content is set to None , and no further child nodes can be created from this node. The child nodes can be accessed using dictionary notation IF there are child nodes. Source code in utils/nav/menu.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class MenuComponent : ''' A tree-like node that represents the menu's option structure. The node has two \"states\": a regular node state and a fake node. A regular node state is when the `options` is a dictionary, which will determine the child nodes. A fake node state is when the `options` is a list of contents to display. In this case, the node's content is set to `None`, and no further child nodes can be created from this node. The child nodes can be accessed using dictionary notation IF there are child nodes. ''' def __init__ ( self , content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ): ''' Create a node that stores the content and optionally, its options. The `options` can be a list, which will set the content to `None` regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a `dict` through `options`, but instead, use `.add_options()`. ''' self . content = content self . options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = options self . __parent__ : t . Optional [ MenuComponent ] = None if isinstance ( self . options , list ): self . content = None def add_option ( self , key : MenuButton , content : PageLike ) -> MenuComponent : '''Add an option into the current node. Return the newly added node to further add more layers. Warnings -------- The returned object is the newly added object, not the current object. Parameters ---------- key : MenuButton The button for the new option. content : PageLike The content of the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. ''' if isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) if self . options is None : self . options = { key : MenuComponent ( content )} self . options [ key ] . __parent__ = self return self . options [ key ] elif self . options . get ( key ) is None : component = MenuComponent ( content ) component . __parent__ = self self . options [ key ] = component return self . options [ key ] else : raise LookupError ( \"Duplicated keys.\" ) def add_options ( self , options : t . Dict [ MenuButton , PageLike ]): '''Add multiple options into the current node. Warnings -------- This will overwrite any possible duplicate keys. Parameters ---------- options : t.Dict[MenuButton, PageLike] A mapping of {button: content}. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) for key in options : self . options [ key ] = MenuComponent ( options [ key ]) self . options [ key ] . __parent__ = self def add_list_options ( self , key : str , contents : t . List [ PageLike ]) -> MenuComponent : '''Append a fake node to this node. Return the newly added node to do whatever you want. Parameters ---------- key : str The button for the new option. contents : t.List[PageLike] A list of content for the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) component = None if len ( contents ) == 1 : component = MenuComponent ( content = contents [ 0 ]) else : component = MenuComponent ( content = None , options = contents ) component . __parent__ = self self . options [ key ] = component return component def force_add_list_options ( self , contents : t . List [ PageLike ]): '''Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters ---------- contents : t.List[PageLike] A list of content for the option. ''' if self . options is None : self . options = [] for content in contents : self . options . append ( content ) self . content = None def __getitem__ ( self , key : MenuButton ) -> t . Optional [ MenuComponent ]: '''Return the MenuComponent with the matching key, or `None` if none was found. Parameters ---------- key : MenuButton The option you're retrieving. Returns ------- t.Optional[MenuComponent] The option with matching key, or `None` if none was found. Raises ------ IndexError The current MenuComponent is already a fake node. ''' if isinstance ( self . options , dict ): return self . options . get ( key ) raise IndexError ( \"Index doesn't exist.\" ) __init__ __init__ ( content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ) Create a node that stores the content and optionally, its options. The options can be a list, which will set the content to None regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a dict through options , but instead, use .add_options() . Source code in utils/nav/menu.py 26 27 28 29 30 31 32 33 34 35 36 37 38 def __init__ ( self , content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ): ''' Create a node that stores the content and optionally, its options. The `options` can be a list, which will set the content to `None` regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a `dict` through `options`, but instead, use `.add_options()`. ''' self . content = content self . options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = options self . __parent__ : t . Optional [ MenuComponent ] = None if isinstance ( self . options , list ): self . content = None add_option add_option ( key : MenuButton , content : PageLike ) -> MenuComponent Add an option into the current node. Return the newly added node to further add more layers. Warnings The returned object is the newly added object, not the current object. Parameters: Name Type Description Default key MenuButton The button for the new option. required content PageLike The content of the new option. required Returns: Type Description MenuComponent The newly added option. Raises: Type Description KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. Source code in utils/nav/menu.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def add_option ( self , key : MenuButton , content : PageLike ) -> MenuComponent : '''Add an option into the current node. Return the newly added node to further add more layers. Warnings -------- The returned object is the newly added object, not the current object. Parameters ---------- key : MenuButton The button for the new option. content : PageLike The content of the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. ''' if isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) if self . options is None : self . options = { key : MenuComponent ( content )} self . options [ key ] . __parent__ = self return self . options [ key ] elif self . options . get ( key ) is None : component = MenuComponent ( content ) component . __parent__ = self self . options [ key ] = component return self . options [ key ] else : raise LookupError ( \"Duplicated keys.\" ) add_options add_options ( options : t . Dict [ MenuButton , PageLike ]) Add multiple options into the current node. Warnings This will overwrite any possible duplicate keys. Parameters: Name Type Description Default options t . Dict [ MenuButton , PageLike ] A mapping of {button: content}. required Raises: Type Description KeyError The current MenuComponent is already a fake node. Source code in utils/nav/menu.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def add_options ( self , options : t . Dict [ MenuButton , PageLike ]): '''Add multiple options into the current node. Warnings -------- This will overwrite any possible duplicate keys. Parameters ---------- options : t.Dict[MenuButton, PageLike] A mapping of {button: content}. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) for key in options : self . options [ key ] = MenuComponent ( options [ key ]) self . options [ key ] . __parent__ = self add_list_options add_list_options ( key : str , contents : t . List [ PageLike ]) -> MenuComponent Append a fake node to this node. Return the newly added node to do whatever you want. Parameters: Name Type Description Default key str The button for the new option. required contents t . List [ PageLike ] A list of content for the new option. required Returns: Type Description MenuComponent The newly added option. Raises: Type Description KeyError The current MenuComponent is already a fake node. Source code in utils/nav/menu.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def add_list_options ( self , key : str , contents : t . List [ PageLike ]) -> MenuComponent : '''Append a fake node to this node. Return the newly added node to do whatever you want. Parameters ---------- key : str The button for the new option. contents : t.List[PageLike] A list of content for the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) component = None if len ( contents ) == 1 : component = MenuComponent ( content = contents [ 0 ]) else : component = MenuComponent ( content = None , options = contents ) component . __parent__ = self self . options [ key ] = component return component force_add_list_options force_add_list_options ( contents : t . List [ PageLike ]) Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters: Name Type Description Default contents t . List [ PageLike ] A list of content for the option. required Source code in utils/nav/menu.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def force_add_list_options ( self , contents : t . List [ PageLike ]): '''Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters ---------- contents : t.List[PageLike] A list of content for the option. ''' if self . options is None : self . options = [] for content in contents : self . options . append ( content ) self . content = None __getitem__ __getitem__ ( key : MenuButton ) -> t . Optional [ MenuComponent ] Return the MenuComponent with the matching key, or None if none was found. Parameters: Name Type Description Default key MenuButton The option you're retrieving. required Returns: Type Description t . Optional [ MenuComponent ] The option with matching key, or None if none was found. Raises: Type Description IndexError The current MenuComponent is already a fake node. Source code in utils/nav/menu.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def __getitem__ ( self , key : MenuButton ) -> t . Optional [ MenuComponent ]: '''Return the MenuComponent with the matching key, or `None` if none was found. Parameters ---------- key : MenuButton The option you're retrieving. Returns ------- t.Optional[MenuComponent] The option with matching key, or `None` if none was found. Raises ------ IndexError The current MenuComponent is already a fake node. ''' if isinstance ( self . options , dict ): return self . options . get ( key ) raise IndexError ( \"Index doesn't exist.\" ) MenuButton Bases: miru . Button Represents a generic button inside ComplexView . This should only be used in ComplexView . Source code in utils/nav/menu.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 class MenuButton ( miru . Button ): '''Represents a generic button inside `ComplexView`. This should only be used in `ComplexView`.''' async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the option if the current `MenuComponent` is not a fake node. ''' view : ComplexView = self . view if isinstance ( view . menu . options , dict ): view . menu = view . menu . options [ self ] await view . update () callback async callback ( _ : miru . Context ) -> None Calls when the button is pressed. It'll move to the option if the current MenuComponent is not a fake node. Source code in utils/nav/menu.py 186 187 188 189 190 191 192 193 194 195 196 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the option if the current `MenuComponent` is not a fake node. ''' view : ComplexView = self . view if isinstance ( view . menu . options , dict ): view . menu = view . menu . options [ self ] await view . update () ReturnMenuButton Bases: MenuButton Represents a return button. Source code in utils/nav/menu.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 class ReturnMenuButton ( MenuButton ): '''Represents a return button.''' def __init__ ( self ) -> None : super () . __init__ ( style = hikari . ButtonStyle . SECONDARY , emoji = helpers . get_emote ( \":arrow_up_small:\" ), custom_id = \"return_button\" ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the parent node if it is not `None`. Raises ------ RuntimeError The return button is in the root menu. ''' view : ComplexView = self . view if view . menu . __parent__ is not None : view . menu = view . menu . __parent__ view . current_page = 0 else : raise RuntimeError ( \"A return button is available in the root menu.\" ) await view . update () callback async callback ( _ : miru . Context ) -> None Calls when the button is pressed. It'll move to the parent node if it is not None . Raises: Type Description RuntimeError The return button is in the root menu. Source code in utils/nav/menu.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the parent node if it is not `None`. Raises ------ RuntimeError The return button is in the root menu. ''' view : ComplexView = self . view if view . menu . __parent__ is not None : view . menu = view . menu . __parent__ view . current_page = 0 else : raise RuntimeError ( \"A return button is available in the root menu.\" ) await view . update () StopMenuButton Bases: MenuButton Represents a terminate button. Source code in utils/nav/menu.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 class StopMenuButton ( MenuButton ): '''Represents a terminate button.''' def __init__ ( self ) -> None : super () . __init__ ( style = hikari . ButtonStyle . DANGER , emoji = helpers . get_emote ( \":stop_button:\" ), custom_id = \"stop_button\" ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll stop the `ComplexView` and delete the menu. ''' view : ComplexView = self . view view . stop () if view . message : await view . message . delete () callback async callback ( _ : miru . Context ) -> None Calls when the button is pressed. It'll stop the ComplexView and delete the menu. Source code in utils/nav/menu.py 236 237 238 239 240 241 242 243 244 245 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll stop the `ComplexView` and delete the menu. ''' view : ComplexView = self . view view . stop () if view . message : await view . message . delete () NextMenuButton Bases: MenuButton A button to move to the next page list. This behaves similarly to nav.NextButton() . Source code in utils/nav/menu.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 class NextMenuButton ( MenuButton ): '''A button to move to the next page list. This behaves similarly to `nav.NextButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"next_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":arrow_forward:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. ''' view : ComplexView = self . view view . current_page += 1 if view . current_page > len ( view . menu . options ) - 1 : view . current_page = 0 await view . update () callback async callback ( _ : miru . Context ) -> None Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. Source code in utils/nav/menu.py 262 263 264 265 266 267 268 269 270 271 272 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. ''' view : ComplexView = self . view view . current_page += 1 if view . current_page > len ( view . menu . options ) - 1 : view . current_page = 0 await view . update () PrevMenuButton Bases: MenuButton A button to move to the previous page list. This behaves similarly to nav.PrevButton() . Source code in utils/nav/menu.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 class PrevMenuButton ( MenuButton ): '''A button to move to the previous page list. This behaves similarly to `nav.PrevButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"prev_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":arrow_backward:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. ''' view : ComplexView = self . view view . current_page -= 1 if view . current_page < 0 : view . current_page = len ( view . menu . options ) - 1 await view . update () callback async callback ( _ : miru . Context ) -> None Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. Source code in utils/nav/menu.py 289 290 291 292 293 294 295 296 297 298 299 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. ''' view : ComplexView = self . view view . current_page -= 1 if view . current_page < 0 : view . current_page = len ( view . menu . options ) - 1 await view . update () FirstMenuButton Bases: MenuButton A button to move to the first page list. This behaves similarly to nav.FirstButton() . Source code in utils/nav/menu.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 class FirstMenuButton ( MenuButton ): '''A button to move to the first page list. This behaves similarly to `nav.FirstButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"first_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":last_track_button:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the first page. ''' view : ComplexView = self . view view . current_page = 0 await view . update () callback async callback ( _ : miru . Context ) -> None Calls when the button is pressed. Move to the first page. Source code in utils/nav/menu.py 316 317 318 319 320 321 322 323 324 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the first page. ''' view : ComplexView = self . view view . current_page = 0 await view . update () LastMenuButton Bases: MenuButton A button to move to the last page list. This behaves similarly to nav.LastButton() . Source code in utils/nav/menu.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 class LastMenuButton ( MenuButton ): '''A button to move to the last page list. This behaves similarly to `nav.LastButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"last_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":next_track_button:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the last page. ''' view : ComplexView = self . view view . current_page = len ( view . menu . options ) - 1 await view . update () callback async callback ( _ : miru . Context ) -> None Calls when the button is pressed. Move to the last page. Source code in utils/nav/menu.py 341 342 343 344 345 346 347 348 349 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the last page. ''' view : ComplexView = self . view view . current_page = len ( view . menu . options ) - 1 await view . update () ComplexView Bases: miru . View A complex menu. Source code in utils/nav/menu.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 class ComplexView ( miru . View ): '''A complex menu.''' def __init__ ( self , menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True , authors : t . Sequence [ int ] = None ) -> None : '''Construct a complex menu. Parameters ---------- menu : MenuComponent A `MenuComponent` tree. This must be a root node. timeout : t.Optional[float], optional How long (in seconds) the menu should accept interactions. Default to `120`. autodefer : bool, optional Whether or not the menu should defer when possible. Default to `True`. authors : t.Sequence[int], optional A list of ids that are allowed to interact with this view. Default to `None`. ''' super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . menu = menu self . _author_ids = authors # For list menu self . current_page : int = 0 async def view_check ( self , context : miru . Context ) -> bool : if not self . _author_ids : return True if context . user . id not in self . _author_ids : await context . respond ( \"You're not allowed to interact with this menu!\" , flags = hikari . MessageFlag . EPHEMERAL ) return context . user . id in self . _author_ids def _update_button ( self ) -> None : ''' Update the button based on the current menu state. ''' self . clear_items () if isinstance ( self . menu . options , dict ): for button in self . menu . options : self . add_item ( button ) elif isinstance ( self . menu . options , list ): # TODO: Might optimize this so it wouldn't reset the buttons. self . add_item ( FirstMenuButton ()) self . add_item ( PrevMenuButton ()) self . add_item ( NextMenuButton ()) self . add_item ( LastMenuButton ()) for index , item in enumerate ( self . menu . options ): if isinstance ( item , hikari . Embed ): item . set_footer ( f \"Page { index + 1 } / { len ( self . menu . options ) } \" ) if self . menu . __parent__ is None : self . add_item ( StopMenuButton ()) else : self . add_item ( ReturnMenuButton ()) async def update ( self ) -> None : '''Update the menu. This shouldn't be called by the user. Raises ------ RuntimeError The message is not found (for unknown reasons). Notes ----- All `MenuButton` should call this method inside their callbacks once it's done with everything. ''' self . _update_button () content = self . menu . content # If view is in a list menu. Can also check if menu.content is None instead. if isinstance ( self . menu . options , list ): content = self . menu . options [ self . current_page ] if self . message : await self . message . edit ( content , components = self . build ()) else : raise RuntimeError ( \"Oops ComplexView.update() failed.\" ) async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout () async def run ( self , ctx : lightbulb . Context ) -> None : '''Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters ---------- ctx : lightbulb.Context A `lightbulb` context. ''' self . _update_button () await run_view ( self , ctx , self . menu . content ) __init__ __init__ ( menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True , authors : t . Sequence [ int ] = None ) -> None Construct a complex menu. Parameters: Name Type Description Default menu MenuComponent A MenuComponent tree. This must be a root node. required timeout t . Optional [ float ], optional How long (in seconds) the menu should accept interactions. Default to 120 . 120 autodefer bool , optional Whether or not the menu should defer when possible. Default to True . True authors t . Sequence [ int ], optional A list of ids that are allowed to interact with this view. Default to None . None Source code in utils/nav/menu.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 def __init__ ( self , menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True , authors : t . Sequence [ int ] = None ) -> None : '''Construct a complex menu. Parameters ---------- menu : MenuComponent A `MenuComponent` tree. This must be a root node. timeout : t.Optional[float], optional How long (in seconds) the menu should accept interactions. Default to `120`. autodefer : bool, optional Whether or not the menu should defer when possible. Default to `True`. authors : t.Sequence[int], optional A list of ids that are allowed to interact with this view. Default to `None`. ''' super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . menu = menu self . _author_ids = authors # For list menu self . current_page : int = 0 update async update () -> None Update the menu. This shouldn't be called by the user. Raises: Type Description RuntimeError The message is not found (for unknown reasons). Notes All MenuButton should call this method inside their callbacks once it's done with everything. Source code in utils/nav/menu.py 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 async def update ( self ) -> None : '''Update the menu. This shouldn't be called by the user. Raises ------ RuntimeError The message is not found (for unknown reasons). Notes ----- All `MenuButton` should call this method inside their callbacks once it's done with everything. ''' self . _update_button () content = self . menu . content # If view is in a list menu. Can also check if menu.content is None instead. if isinstance ( self . menu . options , list ): content = self . menu . options [ self . current_page ] if self . message : await self . message . edit ( content , components = self . build ()) else : raise RuntimeError ( \"Oops ComplexView.update() failed.\" ) on_timeout async on_timeout () -> None Called when the view times out. Notes This adds the timeout button into the menu. Source code in utils/nav/menu.py 433 434 435 436 437 438 439 440 441 442 async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout () run async run ( ctx : lightbulb . Context ) -> None Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters: Name Type Description Default ctx lightbulb . Context A lightbulb context. required Source code in utils/nav/menu.py 444 445 446 447 448 449 450 451 452 453 454 455 456 async def run ( self , ctx : lightbulb . Context ) -> None : '''Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters ---------- ctx : lightbulb.Context A `lightbulb` context. ''' self . _update_button () await run_view ( self , ctx , self . menu . content )","title":"nav"},{"location":"dev/menu/#navnavigatorpy","text":"Contains common forms of menu navigator.","title":"nav/navigator.py"},{"location":"dev/menu/#utils.nav.navigator.StopButtonDelete","text":"Bases: nav . StopButton A custom button to stop the navigator AND delete the message. This button should only be used in nav.NavigatorView . Source code in utils/nav/navigator.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class StopButtonDelete ( nav . StopButton ): ''' A custom button to stop the navigator AND delete the message. This button should only be used in `nav.NavigatorView`. ''' async def callback ( self , context : miru . Context ) -> None : # Reference: https://github.com/HyperGH/hikari-miru/blob/main/miru/ext/nav/buttons.py#L239 #pylint: disable=protected-access view : nav . NavigatorView = self . view if not view . message and not view . _inter : return if view . _inter and view . ephemeral : await view . _inter . delete_initial_response () elif view . message : await view . message . delete () #pylint: enable=protected-access view . stop ()","title":"StopButtonDelete"},{"location":"dev/menu/#utils.nav.navigator.ButtonNavigator","text":"Bases: nav . NavigatorView The default navigator. Source code in utils/nav/navigator.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 class ButtonNavigator ( nav . NavigatorView ): ''' The default navigator. ''' def __init__ ( self , * args , ** kwargs ) -> None : '''Construct a default navigator. Parameters ---------- pages : list[str | hikari.Embed] A list of content to be displayed. buttons : list[nav.NavButton], optional A list of buttons to display. It is safe to ignore this parameter for most use cases. timeout : float, optional The amount of seconds before the view time out. Default to `120.0`. autodefer : bool, optional Whether the view will handle deferred response. It is safe to ignore this parameter for most use cases. Default to `True`. authors : t.Sequence[int], optional A list of ids that are allowed to interact with this view. Default to `None`. ''' self . _author_ids : t . Optional [ t . Sequence [ int ]] = kwargs . pop ( \"authors\" , None ) super () . __init__ ( * args , ** kwargs ) for index , item in enumerate ( self . pages ): if isinstance ( item , hikari . Embed ): item . set_footer ( f \"Page { index + 1 } / { len ( self . pages ) } \" ) def get_default_buttons ( self ) -> t . List [ nav . NavButton [ nav . NavigatorView ]]: ''' Returns a list of default buttons. These are `FirstButton()`, `PrevButton()`, `NextButton()`, `LastButton()`, and `StopButtonDelete()`. Returns ------- t.List[nav.NavButton[nav.NavigatorView]] A list of default buttons. ''' return [ nav . FirstButton (), nav . PrevButton (), nav . NextButton (), nav . LastButton (), StopButtonDelete ()] async def view_check ( self , context : miru . Context ) -> bool : if not self . _author_ids : return True if context . user . id not in self . _author_ids : await context . respond ( \"You're not allowed to interact with this menu!\" , flags = hikari . MessageFlag . EPHEMERAL ) return context . user . id in self . _author_ids async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout ()","title":"ButtonNavigator"},{"location":"dev/menu/#utils.nav.navigator.ButtonNavigator.__init__","text":"__init__ ( * args , ** kwargs ) -> None Construct a default navigator. Parameters: Name Type Description Default pages list [ str | hikari . Embed ] A list of content to be displayed. required buttons list [ nav . NavButton ], optional A list of buttons to display. It is safe to ignore this parameter for most use cases. required timeout float , optional The amount of seconds before the view time out. Default to 120.0 . required autodefer bool , optional Whether the view will handle deferred response. It is safe to ignore this parameter for most use cases. Default to True . required authors t . Sequence [ int ], optional A list of ids that are allowed to interact with this view. Default to None . required Source code in utils/nav/navigator.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def __init__ ( self , * args , ** kwargs ) -> None : '''Construct a default navigator. Parameters ---------- pages : list[str | hikari.Embed] A list of content to be displayed. buttons : list[nav.NavButton], optional A list of buttons to display. It is safe to ignore this parameter for most use cases. timeout : float, optional The amount of seconds before the view time out. Default to `120.0`. autodefer : bool, optional Whether the view will handle deferred response. It is safe to ignore this parameter for most use cases. Default to `True`. authors : t.Sequence[int], optional A list of ids that are allowed to interact with this view. Default to `None`. ''' self . _author_ids : t . Optional [ t . Sequence [ int ]] = kwargs . pop ( \"authors\" , None ) super () . __init__ ( * args , ** kwargs ) for index , item in enumerate ( self . pages ): if isinstance ( item , hikari . Embed ): item . set_footer ( f \"Page { index + 1 } / { len ( self . pages ) } \" )","title":"__init__()"},{"location":"dev/menu/#utils.nav.navigator.ButtonNavigator.get_default_buttons","text":"get_default_buttons () -> t . List [ nav . NavButton [ nav . NavigatorView ]] Returns a list of default buttons. These are FirstButton() , PrevButton() , NextButton() , LastButton() , and StopButtonDelete() . Returns: Type Description t . List [ nav . NavButton [ nav . NavigatorView ]] A list of default buttons. Source code in utils/nav/navigator.py 117 118 119 120 121 122 123 124 125 126 127 128 def get_default_buttons ( self ) -> t . List [ nav . NavButton [ nav . NavigatorView ]]: ''' Returns a list of default buttons. These are `FirstButton()`, `PrevButton()`, `NextButton()`, `LastButton()`, and `StopButtonDelete()`. Returns ------- t.List[nav.NavButton[nav.NavigatorView]] A list of default buttons. ''' return [ nav . FirstButton (), nav . PrevButton (), nav . NextButton (), nav . LastButton (), StopButtonDelete ()]","title":"get_default_buttons()"},{"location":"dev/menu/#utils.nav.navigator.ButtonNavigator.on_timeout","text":"on_timeout () -> None Called when the view times out.","title":"on_timeout()"},{"location":"dev/menu/#utils.nav.navigator.ButtonNavigator.on_timeout--notes","text":"This adds the timeout button into the menu. Source code in utils/nav/navigator.py 139 140 141 142 143 144 145 146 147 148 async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout ()","title":"Notes"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder","text":"A builder to fit a list of item into a navigator appropriately. (This is experimental and can be removed at any time). Source code in utils/nav/navigator.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 class ItemListBuilder : '''A builder to fit a list of item into a navigator appropriately. (This is experimental and can be removed at any time).''' def __init__ ( self , items : list [ T ], max_item_per_page : int ): '''Construct the builder. Parameters ---------- items : list[T] A list of items. max_item_per_page : int The max amount of item to display before moving to a new page. ''' self . items = items self . max_item = max_item_per_page self . page_start_formatter : t . Callable [[ int , T ], hikari . Embed ] = None self . entry_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = None self . page_end_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = lambda embed , index , item : None def set_page_start_formatter ( self , callback : t . Callable [[ int , T ], hikari . Embed ], / ): '''Set this callback as the formatter to run whenever a new page is requested to be created. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[int, T], hikari.Embed] The callback to use. It must accept an `int` (index of the item), the item itself, and return a `hikari.Embed`. ''' self . page_start_formatter = callback def set_entry_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run while iterating through the item list. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . entry_formatter = callback def set_page_end_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run once adding items to a page is finished. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . page_end_formatter = callback def build ( self , * , page_type = ButtonNavigator , authors : t . Sequence [ int ] = None ): '''Start the formatting process and return an object of `page_type`. Warnings -------- The builder must provide at least `page_start_formatter` and either `entry_formatter` or `page_end_formatter` before this method is called. Parameters ---------- page_type : t.Type, optional The type of navigator to use, by default ButtonNavigator. This must have a `pages` argument accepting a list of `hikari.Embed` and a `authors` argument accepting a list of ids. authors : t.Sequence[int], optional The ids of people that are allowed to interact with the navigator. Default to `None`. Returns ------- t.Any The type passed into the constructor, by default ButtonNavigator. Raises ------ NotImplementedError `page_start_formatter` is empty or both `entry_formatter` and `page_end_formatter` are empty. ''' if self . page_start_formatter is None or ( self . entry_formatter is None and self . page_end_formatter is None ): raise NotImplementedError ( \"Not enough formatters are defined.\" ) embeds : list [ hikari . Embed ] = [] embed : hikari . Embed = None for index , item in enumerate ( self . items ): if embed is None : embed = self . page_start_formatter ( index , item ) self . entry_formatter ( embed , index , item ) if index % self . max_item == self . max_item - 1 : self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) embed = None if embed is not None : # TODO: Fix undefined-loop-variable self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) return page_type ( pages = embeds , authors = authors )","title":"ItemListBuilder"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.__init__","text":"__init__ ( items : list [ T ], max_item_per_page : int ) Construct the builder. Parameters: Name Type Description Default items list [ T ] A list of items. required max_item_per_page int The max amount of item to display before moving to a new page. required Source code in utils/nav/navigator.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def __init__ ( self , items : list [ T ], max_item_per_page : int ): '''Construct the builder. Parameters ---------- items : list[T] A list of items. max_item_per_page : int The max amount of item to display before moving to a new page. ''' self . items = items self . max_item = max_item_per_page self . page_start_formatter : t . Callable [[ int , T ], hikari . Embed ] = None self . entry_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = None self . page_end_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = lambda embed , index , item : None","title":"__init__()"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.set_page_start_formatter","text":"set_page_start_formatter ( callback : t . Callable [[ int , T ], hikari . Embed ]) Set this callback as the formatter to run whenever a new page is requested to be created.","title":"set_page_start_formatter()"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.set_page_start_formatter--notes","text":"This is recommended to use as a decorator. Parameters: Name Type Description Default callback t . Callable [[ int , T ], hikari . Embed ] The callback to use. It must accept an int (index of the item), the item itself, and return a hikari.Embed . required Source code in utils/nav/navigator.py 170 171 172 173 174 175 176 177 178 179 180 181 182 def set_page_start_formatter ( self , callback : t . Callable [[ int , T ], hikari . Embed ], / ): '''Set this callback as the formatter to run whenever a new page is requested to be created. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[int, T], hikari.Embed] The callback to use. It must accept an `int` (index of the item), the item itself, and return a `hikari.Embed`. ''' self . page_start_formatter = callback","title":"Notes"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.set_entry_formatter","text":"set_entry_formatter ( callback : t . Callable [[ hikari . Embed , int , T ], None ]) Set this callback as the formatter to run while iterating through the item list.","title":"set_entry_formatter()"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.set_entry_formatter--notes","text":"This is recommended to use as a decorator. Parameters: Name Type Description Default callback t . Callable [[ hikari . Embed , int , T ], None] The callback to use. It must accept a hikari.Embed (the page it's editing), an int (index of the item), and the item itself. required Source code in utils/nav/navigator.py 183 184 185 186 187 188 189 190 191 192 193 194 195 def set_entry_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run while iterating through the item list. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . entry_formatter = callback","title":"Notes"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.set_page_end_formatter","text":"set_page_end_formatter ( callback : t . Callable [[ hikari . Embed , int , T ], None ]) Set this callback as the formatter to run once adding items to a page is finished.","title":"set_page_end_formatter()"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.set_page_end_formatter--notes","text":"This is recommended to use as a decorator. Parameters: Name Type Description Default callback t . Callable [[ hikari . Embed , int , T ], None] The callback to use. It must accept a hikari.Embed (the page it's editing), an int (index of the item), and the item itself. required Source code in utils/nav/navigator.py 196 197 198 199 200 201 202 203 204 205 206 207 208 def set_page_end_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run once adding items to a page is finished. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . page_end_formatter = callback","title":"Notes"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.build","text":"build ( * , page_type = ButtonNavigator , authors : t . Sequence [ int ] = None ) Start the formatting process and return an object of page_type .","title":"build()"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.build--warnings","text":"The builder must provide at least page_start_formatter and either entry_formatter or page_end_formatter before this method is called. Parameters: Name Type Description Default page_type t . Type , optional The type of navigator to use, by default ButtonNavigator. This must have a pages argument accepting a list of hikari.Embed and a authors argument accepting a list of ids. ButtonNavigator authors t . Sequence [ int ], optional The ids of people that are allowed to interact with the navigator. Default to None . None Returns: Type Description t . Any The type passed into the constructor, by default ButtonNavigator. Raises: Type Description NotImplementedError page_start_formatter is empty or both entry_formatter and page_end_formatter are empty. Source code in utils/nav/navigator.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def build ( self , * , page_type = ButtonNavigator , authors : t . Sequence [ int ] = None ): '''Start the formatting process and return an object of `page_type`. Warnings -------- The builder must provide at least `page_start_formatter` and either `entry_formatter` or `page_end_formatter` before this method is called. Parameters ---------- page_type : t.Type, optional The type of navigator to use, by default ButtonNavigator. This must have a `pages` argument accepting a list of `hikari.Embed` and a `authors` argument accepting a list of ids. authors : t.Sequence[int], optional The ids of people that are allowed to interact with the navigator. Default to `None`. Returns ------- t.Any The type passed into the constructor, by default ButtonNavigator. Raises ------ NotImplementedError `page_start_formatter` is empty or both `entry_formatter` and `page_end_formatter` are empty. ''' if self . page_start_formatter is None or ( self . entry_formatter is None and self . page_end_formatter is None ): raise NotImplementedError ( \"Not enough formatters are defined.\" ) embeds : list [ hikari . Embed ] = [] embed : hikari . Embed = None for index , item in enumerate ( self . items ): if embed is None : embed = self . page_start_formatter ( index , item ) self . entry_formatter ( embed , index , item ) if index % self . max_item == self . max_item - 1 : self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) embed = None if embed is not None : # TODO: Fix undefined-loop-variable self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) return page_type ( pages = embeds , authors = authors )","title":"Warnings"},{"location":"dev/menu/#utils.nav.navigator.run_view","text":"run_view ( view : miru . View , ctx : lightbulb . Context , initial_content : t . Union [ str , hikari . Embed ] = None ) -> None A simplified way to run a miru.View . Parameters: Name Type Description Default view miru . View A miru.View or its subclasses. required ctx lightbulb . Context A context to send the view. required initial_content t . Union [ str , hikari . Embed ], optional The content to first display. This is optional for nav.NavigatorView and its subclasses. None Raises: Type Description TypeError initial_content is not provided, but view is not type nav.NavigatorView . hikari . BadRequestError Maybe ctx is deferred. Source code in utils/nav/navigator.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 async def run_view ( view : miru . View , ctx : lightbulb . Context , initial_content : t . Union [ str , hikari . Embed ] = None ) -> None : '''A simplified way to run a `miru.View`. Parameters ---------- view : miru.View A `miru.View` or its subclasses. ctx : lightbulb.Context A context to send the view. initial_content : t.Union[str, hikari.Embed], optional The content to first display. This is optional for `nav.NavigatorView` and its subclasses. Raises ------ TypeError `initial_content` is not provided, but `view` is not type `nav.NavigatorView`. hikari.BadRequestError Maybe `ctx` is deferred. ''' if initial_content is None : if isinstance ( view , nav . NavigatorView ): # nav.NavigatorView cannot be run on an interaction with a response already (typically deferring) # so we have to do things manually here. # Reference: https://github.com/HyperGH/hikari-miru/blob/main/miru/ext/nav/navigator.py#L227 for button in view . children : if isinstance ( button , nav . NavButton ): await button . before_page_change () initial_content = view . pages [ view . current_page ] #await view.send(ctx.interaction) #return else : raise TypeError ( \"'initial_content' must be provided if 'view' is not type 'NavigatorView'.\" ) resp_proxy = await ctx . respond ( initial_content , components = view . build ()) view . start ( await resp_proxy . message ()) await view . wait ()","title":"run_view()"},{"location":"dev/menu/#utils.nav.navigator.timeout_button","text":"timeout_button () -> nav . NavButton Return a nav.NavButton to be use in nav.NavigatorView . This button is safe to use in miru.View . Returns: Type Description nav . NavButton The default timeout button. Source code in utils/nav/navigator.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def timeout_button () -> nav . NavButton : '''Return a `nav.NavButton` to be use in `nav.NavigatorView`. This button is safe to use in `miru.View`. Returns ------- nav.NavButton The default timeout button. ''' return nav . NavButton ( style = hikari . ButtonStyle . SECONDARY , emoji = helpers . get_emote ( \":clock12:\" ), custom_id = \"timeout_button\" , disabled = True )","title":"timeout_button()"},{"location":"dev/menu/#navconfirmpy","text":"Contains a confirmation menu.","title":"nav/confirm.py"},{"location":"dev/menu/#utils.nav.confirm.ConfirmView","text":"Bases: miru . View A confirmation menu. Source code in utils/nav/confirm.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class ConfirmView ( miru . View ): ''' A confirmation menu. ''' def __init__ ( self , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True , authors : t . Sequence [ int ] = None ) -> None : self . _author_ids = authors super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . result : t . Optional [ bool ] = None async def view_check ( self , context : miru . Context ) -> bool : if not self . _author_ids : return True if context . user . id not in self . _author_ids : await context . respond ( \"You're not allowed to interact with this menu!\" , flags = hikari . MessageFlag . EPHEMERAL ) return context . user . id in self . _author_ids @miru . button ( label = \"Yes\" , emoji = helpers . get_emote ( \":white_check_mark:\" ), style = hikari . ButtonStyle . SUCCESS , custom_id = \"yes_button\" ) async def yes_button ( self , _ : miru . Button , __ : miru . Context ): self . result = True self . stop () @miru . button ( label = \"No\" , emoji = helpers . get_emote ( \":negative_squared_cross_mark:\" ), style = hikari . ButtonStyle . DANGER , custom_id = \"no_button\" ) async def no_button ( self , _ : miru . Button , __ : miru . Context ): self . result = False self . stop () async def wait ( self ) -> t . Optional [ bool ]: ''' Wait until the view times out or stops manually. Return the result of the confirmation, or `None` if it times out. ''' await super () . wait () await self . message . delete () return self . result","title":"ConfirmView"},{"location":"dev/menu/#utils.nav.confirm.ConfirmView.wait","text":"wait () -> t . Optional [ bool ] Wait until the view times out or stops manually. Return the result of the confirmation, or None if it times out. Source code in utils/nav/confirm.py 39 40 41 42 43 44 45 46 47 48 async def wait ( self ) -> t . Optional [ bool ]: ''' Wait until the view times out or stops manually. Return the result of the confirmation, or `None` if it times out. ''' await super () . wait () await self . message . delete () return self . result","title":"wait()"},{"location":"dev/menu/#navmenupy","text":"Contains everything needed to build a complex menu.","title":"nav/menu.py"},{"location":"dev/menu/#utils.nav.menu.MenuComponent","text":"A tree-like node that represents the menu's option structure. The node has two \"states\": a regular node state and a fake node. A regular node state is when the options is a dictionary, which will determine the child nodes. A fake node state is when the options is a list of contents to display. In this case, the node's content is set to None , and no further child nodes can be created from this node. The child nodes can be accessed using dictionary notation IF there are child nodes. Source code in utils/nav/menu.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class MenuComponent : ''' A tree-like node that represents the menu's option structure. The node has two \"states\": a regular node state and a fake node. A regular node state is when the `options` is a dictionary, which will determine the child nodes. A fake node state is when the `options` is a list of contents to display. In this case, the node's content is set to `None`, and no further child nodes can be created from this node. The child nodes can be accessed using dictionary notation IF there are child nodes. ''' def __init__ ( self , content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ): ''' Create a node that stores the content and optionally, its options. The `options` can be a list, which will set the content to `None` regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a `dict` through `options`, but instead, use `.add_options()`. ''' self . content = content self . options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = options self . __parent__ : t . Optional [ MenuComponent ] = None if isinstance ( self . options , list ): self . content = None def add_option ( self , key : MenuButton , content : PageLike ) -> MenuComponent : '''Add an option into the current node. Return the newly added node to further add more layers. Warnings -------- The returned object is the newly added object, not the current object. Parameters ---------- key : MenuButton The button for the new option. content : PageLike The content of the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. ''' if isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) if self . options is None : self . options = { key : MenuComponent ( content )} self . options [ key ] . __parent__ = self return self . options [ key ] elif self . options . get ( key ) is None : component = MenuComponent ( content ) component . __parent__ = self self . options [ key ] = component return self . options [ key ] else : raise LookupError ( \"Duplicated keys.\" ) def add_options ( self , options : t . Dict [ MenuButton , PageLike ]): '''Add multiple options into the current node. Warnings -------- This will overwrite any possible duplicate keys. Parameters ---------- options : t.Dict[MenuButton, PageLike] A mapping of {button: content}. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) for key in options : self . options [ key ] = MenuComponent ( options [ key ]) self . options [ key ] . __parent__ = self def add_list_options ( self , key : str , contents : t . List [ PageLike ]) -> MenuComponent : '''Append a fake node to this node. Return the newly added node to do whatever you want. Parameters ---------- key : str The button for the new option. contents : t.List[PageLike] A list of content for the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) component = None if len ( contents ) == 1 : component = MenuComponent ( content = contents [ 0 ]) else : component = MenuComponent ( content = None , options = contents ) component . __parent__ = self self . options [ key ] = component return component def force_add_list_options ( self , contents : t . List [ PageLike ]): '''Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters ---------- contents : t.List[PageLike] A list of content for the option. ''' if self . options is None : self . options = [] for content in contents : self . options . append ( content ) self . content = None def __getitem__ ( self , key : MenuButton ) -> t . Optional [ MenuComponent ]: '''Return the MenuComponent with the matching key, or `None` if none was found. Parameters ---------- key : MenuButton The option you're retrieving. Returns ------- t.Optional[MenuComponent] The option with matching key, or `None` if none was found. Raises ------ IndexError The current MenuComponent is already a fake node. ''' if isinstance ( self . options , dict ): return self . options . get ( key ) raise IndexError ( \"Index doesn't exist.\" )","title":"MenuComponent"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.__init__","text":"__init__ ( content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ) Create a node that stores the content and optionally, its options. The options can be a list, which will set the content to None regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a dict through options , but instead, use .add_options() . Source code in utils/nav/menu.py 26 27 28 29 30 31 32 33 34 35 36 37 38 def __init__ ( self , content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ): ''' Create a node that stores the content and optionally, its options. The `options` can be a list, which will set the content to `None` regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a `dict` through `options`, but instead, use `.add_options()`. ''' self . content = content self . options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = options self . __parent__ : t . Optional [ MenuComponent ] = None if isinstance ( self . options , list ): self . content = None","title":"__init__()"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.add_option","text":"add_option ( key : MenuButton , content : PageLike ) -> MenuComponent Add an option into the current node. Return the newly added node to further add more layers.","title":"add_option()"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.add_option--warnings","text":"The returned object is the newly added object, not the current object. Parameters: Name Type Description Default key MenuButton The button for the new option. required content PageLike The content of the new option. required Returns: Type Description MenuComponent The newly added option. Raises: Type Description KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. Source code in utils/nav/menu.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def add_option ( self , key : MenuButton , content : PageLike ) -> MenuComponent : '''Add an option into the current node. Return the newly added node to further add more layers. Warnings -------- The returned object is the newly added object, not the current object. Parameters ---------- key : MenuButton The button for the new option. content : PageLike The content of the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. ''' if isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) if self . options is None : self . options = { key : MenuComponent ( content )} self . options [ key ] . __parent__ = self return self . options [ key ] elif self . options . get ( key ) is None : component = MenuComponent ( content ) component . __parent__ = self self . options [ key ] = component return self . options [ key ] else : raise LookupError ( \"Duplicated keys.\" )","title":"Warnings"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.add_options","text":"add_options ( options : t . Dict [ MenuButton , PageLike ]) Add multiple options into the current node.","title":"add_options()"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.add_options--warnings","text":"This will overwrite any possible duplicate keys. Parameters: Name Type Description Default options t . Dict [ MenuButton , PageLike ] A mapping of {button: content}. required Raises: Type Description KeyError The current MenuComponent is already a fake node. Source code in utils/nav/menu.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def add_options ( self , options : t . Dict [ MenuButton , PageLike ]): '''Add multiple options into the current node. Warnings -------- This will overwrite any possible duplicate keys. Parameters ---------- options : t.Dict[MenuButton, PageLike] A mapping of {button: content}. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) for key in options : self . options [ key ] = MenuComponent ( options [ key ]) self . options [ key ] . __parent__ = self","title":"Warnings"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.add_list_options","text":"add_list_options ( key : str , contents : t . List [ PageLike ]) -> MenuComponent Append a fake node to this node. Return the newly added node to do whatever you want. Parameters: Name Type Description Default key str The button for the new option. required contents t . List [ PageLike ] A list of content for the new option. required Returns: Type Description MenuComponent The newly added option. Raises: Type Description KeyError The current MenuComponent is already a fake node. Source code in utils/nav/menu.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def add_list_options ( self , key : str , contents : t . List [ PageLike ]) -> MenuComponent : '''Append a fake node to this node. Return the newly added node to do whatever you want. Parameters ---------- key : str The button for the new option. contents : t.List[PageLike] A list of content for the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) component = None if len ( contents ) == 1 : component = MenuComponent ( content = contents [ 0 ]) else : component = MenuComponent ( content = None , options = contents ) component . __parent__ = self self . options [ key ] = component return component","title":"add_list_options()"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.force_add_list_options","text":"force_add_list_options ( contents : t . List [ PageLike ]) Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters: Name Type Description Default contents t . List [ PageLike ] A list of content for the option. required Source code in utils/nav/menu.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def force_add_list_options ( self , contents : t . List [ PageLike ]): '''Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters ---------- contents : t.List[PageLike] A list of content for the option. ''' if self . options is None : self . options = [] for content in contents : self . options . append ( content ) self . content = None","title":"force_add_list_options()"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.__getitem__","text":"__getitem__ ( key : MenuButton ) -> t . Optional [ MenuComponent ] Return the MenuComponent with the matching key, or None if none was found. Parameters: Name Type Description Default key MenuButton The option you're retrieving. required Returns: Type Description t . Optional [ MenuComponent ] The option with matching key, or None if none was found. Raises: Type Description IndexError The current MenuComponent is already a fake node. Source code in utils/nav/menu.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def __getitem__ ( self , key : MenuButton ) -> t . Optional [ MenuComponent ]: '''Return the MenuComponent with the matching key, or `None` if none was found. Parameters ---------- key : MenuButton The option you're retrieving. Returns ------- t.Optional[MenuComponent] The option with matching key, or `None` if none was found. Raises ------ IndexError The current MenuComponent is already a fake node. ''' if isinstance ( self . options , dict ): return self . options . get ( key ) raise IndexError ( \"Index doesn't exist.\" )","title":"__getitem__()"},{"location":"dev/menu/#utils.nav.menu.MenuButton","text":"Bases: miru . Button Represents a generic button inside ComplexView . This should only be used in ComplexView . Source code in utils/nav/menu.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 class MenuButton ( miru . Button ): '''Represents a generic button inside `ComplexView`. This should only be used in `ComplexView`.''' async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the option if the current `MenuComponent` is not a fake node. ''' view : ComplexView = self . view if isinstance ( view . menu . options , dict ): view . menu = view . menu . options [ self ] await view . update ()","title":"MenuButton"},{"location":"dev/menu/#utils.nav.menu.MenuButton.callback","text":"callback ( _ : miru . Context ) -> None Calls when the button is pressed. It'll move to the option if the current MenuComponent is not a fake node. Source code in utils/nav/menu.py 186 187 188 189 190 191 192 193 194 195 196 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the option if the current `MenuComponent` is not a fake node. ''' view : ComplexView = self . view if isinstance ( view . menu . options , dict ): view . menu = view . menu . options [ self ] await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.ReturnMenuButton","text":"Bases: MenuButton Represents a return button. Source code in utils/nav/menu.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 class ReturnMenuButton ( MenuButton ): '''Represents a return button.''' def __init__ ( self ) -> None : super () . __init__ ( style = hikari . ButtonStyle . SECONDARY , emoji = helpers . get_emote ( \":arrow_up_small:\" ), custom_id = \"return_button\" ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the parent node if it is not `None`. Raises ------ RuntimeError The return button is in the root menu. ''' view : ComplexView = self . view if view . menu . __parent__ is not None : view . menu = view . menu . __parent__ view . current_page = 0 else : raise RuntimeError ( \"A return button is available in the root menu.\" ) await view . update ()","title":"ReturnMenuButton"},{"location":"dev/menu/#utils.nav.menu.ReturnMenuButton.callback","text":"callback ( _ : miru . Context ) -> None Calls when the button is pressed. It'll move to the parent node if it is not None . Raises: Type Description RuntimeError The return button is in the root menu. Source code in utils/nav/menu.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the parent node if it is not `None`. Raises ------ RuntimeError The return button is in the root menu. ''' view : ComplexView = self . view if view . menu . __parent__ is not None : view . menu = view . menu . __parent__ view . current_page = 0 else : raise RuntimeError ( \"A return button is available in the root menu.\" ) await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.StopMenuButton","text":"Bases: MenuButton Represents a terminate button. Source code in utils/nav/menu.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 class StopMenuButton ( MenuButton ): '''Represents a terminate button.''' def __init__ ( self ) -> None : super () . __init__ ( style = hikari . ButtonStyle . DANGER , emoji = helpers . get_emote ( \":stop_button:\" ), custom_id = \"stop_button\" ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll stop the `ComplexView` and delete the menu. ''' view : ComplexView = self . view view . stop () if view . message : await view . message . delete ()","title":"StopMenuButton"},{"location":"dev/menu/#utils.nav.menu.StopMenuButton.callback","text":"callback ( _ : miru . Context ) -> None Calls when the button is pressed. It'll stop the ComplexView and delete the menu. Source code in utils/nav/menu.py 236 237 238 239 240 241 242 243 244 245 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll stop the `ComplexView` and delete the menu. ''' view : ComplexView = self . view view . stop () if view . message : await view . message . delete ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.NextMenuButton","text":"Bases: MenuButton A button to move to the next page list. This behaves similarly to nav.NextButton() . Source code in utils/nav/menu.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 class NextMenuButton ( MenuButton ): '''A button to move to the next page list. This behaves similarly to `nav.NextButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"next_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":arrow_forward:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. ''' view : ComplexView = self . view view . current_page += 1 if view . current_page > len ( view . menu . options ) - 1 : view . current_page = 0 await view . update ()","title":"NextMenuButton"},{"location":"dev/menu/#utils.nav.menu.NextMenuButton.callback","text":"callback ( _ : miru . Context ) -> None Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. Source code in utils/nav/menu.py 262 263 264 265 266 267 268 269 270 271 272 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. ''' view : ComplexView = self . view view . current_page += 1 if view . current_page > len ( view . menu . options ) - 1 : view . current_page = 0 await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.PrevMenuButton","text":"Bases: MenuButton A button to move to the previous page list. This behaves similarly to nav.PrevButton() . Source code in utils/nav/menu.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 class PrevMenuButton ( MenuButton ): '''A button to move to the previous page list. This behaves similarly to `nav.PrevButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"prev_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":arrow_backward:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. ''' view : ComplexView = self . view view . current_page -= 1 if view . current_page < 0 : view . current_page = len ( view . menu . options ) - 1 await view . update ()","title":"PrevMenuButton"},{"location":"dev/menu/#utils.nav.menu.PrevMenuButton.callback","text":"callback ( _ : miru . Context ) -> None Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. Source code in utils/nav/menu.py 289 290 291 292 293 294 295 296 297 298 299 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. ''' view : ComplexView = self . view view . current_page -= 1 if view . current_page < 0 : view . current_page = len ( view . menu . options ) - 1 await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.FirstMenuButton","text":"Bases: MenuButton A button to move to the first page list. This behaves similarly to nav.FirstButton() . Source code in utils/nav/menu.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 class FirstMenuButton ( MenuButton ): '''A button to move to the first page list. This behaves similarly to `nav.FirstButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"first_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":last_track_button:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the first page. ''' view : ComplexView = self . view view . current_page = 0 await view . update ()","title":"FirstMenuButton"},{"location":"dev/menu/#utils.nav.menu.FirstMenuButton.callback","text":"callback ( _ : miru . Context ) -> None Calls when the button is pressed. Move to the first page. Source code in utils/nav/menu.py 316 317 318 319 320 321 322 323 324 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the first page. ''' view : ComplexView = self . view view . current_page = 0 await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.LastMenuButton","text":"Bases: MenuButton A button to move to the last page list. This behaves similarly to nav.LastButton() . Source code in utils/nav/menu.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 class LastMenuButton ( MenuButton ): '''A button to move to the last page list. This behaves similarly to `nav.LastButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"last_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":next_track_button:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the last page. ''' view : ComplexView = self . view view . current_page = len ( view . menu . options ) - 1 await view . update ()","title":"LastMenuButton"},{"location":"dev/menu/#utils.nav.menu.LastMenuButton.callback","text":"callback ( _ : miru . Context ) -> None Calls when the button is pressed. Move to the last page. Source code in utils/nav/menu.py 341 342 343 344 345 346 347 348 349 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the last page. ''' view : ComplexView = self . view view . current_page = len ( view . menu . options ) - 1 await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.ComplexView","text":"Bases: miru . View A complex menu. Source code in utils/nav/menu.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 class ComplexView ( miru . View ): '''A complex menu.''' def __init__ ( self , menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True , authors : t . Sequence [ int ] = None ) -> None : '''Construct a complex menu. Parameters ---------- menu : MenuComponent A `MenuComponent` tree. This must be a root node. timeout : t.Optional[float], optional How long (in seconds) the menu should accept interactions. Default to `120`. autodefer : bool, optional Whether or not the menu should defer when possible. Default to `True`. authors : t.Sequence[int], optional A list of ids that are allowed to interact with this view. Default to `None`. ''' super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . menu = menu self . _author_ids = authors # For list menu self . current_page : int = 0 async def view_check ( self , context : miru . Context ) -> bool : if not self . _author_ids : return True if context . user . id not in self . _author_ids : await context . respond ( \"You're not allowed to interact with this menu!\" , flags = hikari . MessageFlag . EPHEMERAL ) return context . user . id in self . _author_ids def _update_button ( self ) -> None : ''' Update the button based on the current menu state. ''' self . clear_items () if isinstance ( self . menu . options , dict ): for button in self . menu . options : self . add_item ( button ) elif isinstance ( self . menu . options , list ): # TODO: Might optimize this so it wouldn't reset the buttons. self . add_item ( FirstMenuButton ()) self . add_item ( PrevMenuButton ()) self . add_item ( NextMenuButton ()) self . add_item ( LastMenuButton ()) for index , item in enumerate ( self . menu . options ): if isinstance ( item , hikari . Embed ): item . set_footer ( f \"Page { index + 1 } / { len ( self . menu . options ) } \" ) if self . menu . __parent__ is None : self . add_item ( StopMenuButton ()) else : self . add_item ( ReturnMenuButton ()) async def update ( self ) -> None : '''Update the menu. This shouldn't be called by the user. Raises ------ RuntimeError The message is not found (for unknown reasons). Notes ----- All `MenuButton` should call this method inside their callbacks once it's done with everything. ''' self . _update_button () content = self . menu . content # If view is in a list menu. Can also check if menu.content is None instead. if isinstance ( self . menu . options , list ): content = self . menu . options [ self . current_page ] if self . message : await self . message . edit ( content , components = self . build ()) else : raise RuntimeError ( \"Oops ComplexView.update() failed.\" ) async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout () async def run ( self , ctx : lightbulb . Context ) -> None : '''Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters ---------- ctx : lightbulb.Context A `lightbulb` context. ''' self . _update_button () await run_view ( self , ctx , self . menu . content )","title":"ComplexView"},{"location":"dev/menu/#utils.nav.menu.ComplexView.__init__","text":"__init__ ( menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True , authors : t . Sequence [ int ] = None ) -> None Construct a complex menu. Parameters: Name Type Description Default menu MenuComponent A MenuComponent tree. This must be a root node. required timeout t . Optional [ float ], optional How long (in seconds) the menu should accept interactions. Default to 120 . 120 autodefer bool , optional Whether or not the menu should defer when possible. Default to True . True authors t . Sequence [ int ], optional A list of ids that are allowed to interact with this view. Default to None . None Source code in utils/nav/menu.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 def __init__ ( self , menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True , authors : t . Sequence [ int ] = None ) -> None : '''Construct a complex menu. Parameters ---------- menu : MenuComponent A `MenuComponent` tree. This must be a root node. timeout : t.Optional[float], optional How long (in seconds) the menu should accept interactions. Default to `120`. autodefer : bool, optional Whether or not the menu should defer when possible. Default to `True`. authors : t.Sequence[int], optional A list of ids that are allowed to interact with this view. Default to `None`. ''' super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . menu = menu self . _author_ids = authors # For list menu self . current_page : int = 0","title":"__init__()"},{"location":"dev/menu/#utils.nav.menu.ComplexView.update","text":"update () -> None Update the menu. This shouldn't be called by the user. Raises: Type Description RuntimeError The message is not found (for unknown reasons).","title":"update()"},{"location":"dev/menu/#utils.nav.menu.ComplexView.update--notes","text":"All MenuButton should call this method inside their callbacks once it's done with everything. Source code in utils/nav/menu.py 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 async def update ( self ) -> None : '''Update the menu. This shouldn't be called by the user. Raises ------ RuntimeError The message is not found (for unknown reasons). Notes ----- All `MenuButton` should call this method inside their callbacks once it's done with everything. ''' self . _update_button () content = self . menu . content # If view is in a list menu. Can also check if menu.content is None instead. if isinstance ( self . menu . options , list ): content = self . menu . options [ self . current_page ] if self . message : await self . message . edit ( content , components = self . build ()) else : raise RuntimeError ( \"Oops ComplexView.update() failed.\" )","title":"Notes"},{"location":"dev/menu/#utils.nav.menu.ComplexView.on_timeout","text":"on_timeout () -> None Called when the view times out.","title":"on_timeout()"},{"location":"dev/menu/#utils.nav.menu.ComplexView.on_timeout--notes","text":"This adds the timeout button into the menu. Source code in utils/nav/menu.py 433 434 435 436 437 438 439 440 441 442 async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout ()","title":"Notes"},{"location":"dev/menu/#utils.nav.menu.ComplexView.run","text":"run ( ctx : lightbulb . Context ) -> None Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters: Name Type Description Default ctx lightbulb . Context A lightbulb context. required Source code in utils/nav/menu.py 444 445 446 447 448 449 450 451 452 453 454 455 456 async def run ( self , ctx : lightbulb . Context ) -> None : '''Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters ---------- ctx : lightbulb.Context A `lightbulb` context. ''' self . _update_button () await run_view ( self , ctx , self . menu . content )","title":"run()"},{"location":"dev/models/","text":"Contains many data structures, including the customized MichaelBot class. GuildCache A wrapper around dict[str, psql.Guild] This includes many ways to obtain info, such as get() , keys() , items() , values() , and __getitem__() . These methods will return a deep copy of the desired object, so you can freely edit them. Warnings A cache should be used immediately upon fetching. You must periodically refresh the data if you use it in a session-like setting, otherwise, two or more cache might exist at the same time, causing some sort of \"data race\" when updating. Source code in utils/models.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class GuildCache : '''A wrapper around `dict[str, psql.Guild]` This includes many ways to obtain info, such as `get()`, `keys()`, `items()`, `values()`, and `__getitem__()`. These methods will return a deep copy of the desired object, so you can freely edit them. Warnings -------- A cache should be used immediately upon fetching. You must periodically refresh the data if you use it in a session-like setting, otherwise, two or more cache might exist at the same time, causing some sort of \"data race\" when updating. ''' def __init__ ( self ) -> None : self . __guild_mapping : dict [ str , psql . Guild ] = {} def __getitem__ ( self , guild_id : int ): return copy . deepcopy ( self . __guild_mapping [ guild_id ]) def get ( self , guild_id : int ): return copy . deepcopy ( self . __guild_mapping . get ( guild_id )) def keys ( self ): return self . __guild_mapping . keys () def items ( self ): return self . __guild_mapping . items () def values ( self ): return self . __guild_mapping . values () async def insert ( self , conn : asyncpg . Connection , guild : psql . Guild ): '''Explicitly add a new guild to the cache and to the db. This is mostly used to save overheads within `psql.Guild.sync()` Warnings -------- Using this method means you're 100% sure the guild doesn't exist. For entries that *might* exist, consider using `update_with()`. Parameters ---------- conn : asyncpg.Connection The connection to use. guild : psql.Guild The guild to insert. ''' await psql . Guild . insert_one ( conn , guild ) self . __guild_mapping [ guild . id ] = guild async def update ( self , conn : asyncpg . Connection , guild : psql . Guild ): await psql . Guild . update ( conn , guild ) self . __guild_mapping [ guild . id ] = guild async def update_from_db ( self , conn : asyncpg . Connection , guild_id : int ): guild = await psql . Guild . get_one ( conn , guild_id ) if guild is None : del self . __guild_mapping [ guild_id ] self . __guild_mapping [ guild . id ] = guild async def update_all_from_db ( self , conn : asyncpg . Connection ): guilds = await psql . Guild . get_all ( conn ) self . __guild_mapping = {} for guild in guilds : self . __guild_mapping [ guild . id ] = guild def update_local ( self , guild : psql . Guild ): self . __guild_mapping [ guild . id ] = guild def remove_local ( self , guild_id : int ): del self . __guild_mapping [ guild_id ] insert async insert ( conn : asyncpg . Connection , guild : psql . Guild ) Explicitly add a new guild to the cache and to the db. This is mostly used to save overheads within psql.Guild.sync() Warnings Using this method means you're 100% sure the guild doesn't exist. For entries that might exist, consider using update_with() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required guild psql . Guild The guild to insert. required Source code in utils/models.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 async def insert ( self , conn : asyncpg . Connection , guild : psql . Guild ): '''Explicitly add a new guild to the cache and to the db. This is mostly used to save overheads within `psql.Guild.sync()` Warnings -------- Using this method means you're 100% sure the guild doesn't exist. For entries that *might* exist, consider using `update_with()`. Parameters ---------- conn : asyncpg.Connection The connection to use. guild : psql.Guild The guild to insert. ''' await psql . Guild . insert_one ( conn , guild ) self . __guild_mapping [ guild . id ] = guild LogCache A wrapper around dict[str, psql.GuildLog] This includes many ways to obtain info, such as get() , keys() , items() , values() , and __getitem__() . These methods will return a deep copy of the desired object, so you can freely edit them. Warnings A cache should be used immediately upon fetching. You must periodically refresh the data if you use it in a session-like setting, otherwise, two or more cache might exist at the same time, causing some sort of \"data race\" when updating. Source code in utils/models.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 class LogCache : '''A wrapper around `dict[str, psql.GuildLog]` This includes many ways to obtain info, such as `get()`, `keys()`, `items()`, `values()`, and `__getitem__()`. These methods will return a deep copy of the desired object, so you can freely edit them. Warnings -------- A cache should be used immediately upon fetching. You must periodically refresh the data if you use it in a session-like setting, otherwise, two or more cache might exist at the same time, causing some sort of \"data race\" when updating. ''' def __init__ ( self ) -> None : self . __log_mapping : dict [ str , psql . GuildLog ] = {} def __getitem__ ( self , guild_id : int ): return copy . deepcopy ( self . __log_mapping [ guild_id ]) def get ( self , guild_id : int ): return copy . deepcopy ( self . __log_mapping . get ( guild_id )) def keys ( self ): return self . __log_mapping . keys () def items ( self ): return self . __log_mapping . items () def values ( self ): return self . __log_mapping . values () async def insert ( self , conn : asyncpg . Connection , guild : psql . GuildLog ): await psql . GuildLog . insert_one ( conn , guild . guild_id ) self . __log_mapping [ guild . guild_id ] = guild async def update ( self , conn : asyncpg . Connection , guild : psql . GuildLog ): await psql . GuildLog . update ( conn , guild ) self . __log_mapping [ guild . guild_id ] = guild async def update_from_db ( self , conn : asyncpg . Connection , guild_id : int ): guild = await psql . GuildLog . get_one ( conn , guild_id ) if guild is None : del self . __log_mapping [ guild_id ] self . __log_mapping [ guild . guild_id ] = guild async def update_all_from_db ( self , conn : asyncpg . Connection ): guilds = await psql . GuildLog . get_all ( conn ) self . __log_mapping = {} for guild in guilds : self . __log_mapping [ guild . guild_id ] = guild def update_local ( self , guild : psql . GuildLog ): self . __log_mapping [ guild . guild_id ] = guild def remove_local ( self , guild_id : int ): del self . __log_mapping [ guild_id ] UserCache A wrapper around dict[str, psql.User] This includes many ways to obtain info, such as get() , keys() , items() , values() , and __getitem__() . These methods will return a deep copy of the desired object, so you can freely edit them. Warnings A cache should be used immediately upon fetching. You must periodically refresh the data if you use it in a session-like setting, otherwise, two or more cache might exist at the same time, causing some sort of \"data race\" when updating. Source code in utils/models.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 class UserCache : '''A wrapper around `dict[str, psql.User]` This includes many ways to obtain info, such as `get()`, `keys()`, `items()`, `values()`, and `__getitem__()`. These methods will return a deep copy of the desired object, so you can freely edit them. Warnings -------- A cache should be used immediately upon fetching. You must periodically refresh the data if you use it in a session-like setting, otherwise, two or more cache might exist at the same time, causing some sort of \"data race\" when updating. ''' def __init__ ( self ) -> None : self . __user_mapping : dict [ str , psql . User ] = {} def __getitem__ ( self , user_id : int ): return copy . deepcopy ( self . __user_mapping [ user_id ]) def get ( self , user_id : int ): return copy . deepcopy ( self . __user_mapping . get ( user_id )) def keys ( self ): return self . __user_mapping . keys () def items ( self ): return self . __user_mapping . items () def values ( self ): return self . __user_mapping . values () async def insert ( self , conn : asyncpg . Connection , user : psql . User ): '''Explicitly add a new user to the cache and to the db. This is mostly used to save overheads within `psql.User.sync()` Warnings -------- Using this method means you're 100% sure the user doesn't exist. For entries that *might* exist, consider using `sync_user()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user : psql.User The user to insert. ''' await psql . User . insert_one ( conn , user ) self . __user_mapping [ user . id ] = user async def update ( self , conn : asyncpg . Connection , user : psql . User ): '''Sync the database with the new value. Parameters ---------- conn : asyncpg.Connection The connection to use. user : psql.User The user value to update with. ''' await psql . User . update ( conn , user ) self . __user_mapping [ user . id ] = user async def update_from_db ( self , conn : asyncpg . Connection , user_id : int ): user = await psql . User . get_one ( conn , user_id ) if user is None : del self . __user_mapping [ user_id ] self . __user_mapping [ user . id ] = user async def update_all_from_db ( self , conn : asyncpg . Connection ): users = await psql . User . get_all ( conn ) self . __user_mapping = {} for user in users : self . __user_mapping [ user . id ] = user def update_local ( self , user : psql . User ): self . __user_mapping [ user . id ] = user insert async insert ( conn : asyncpg . Connection , user : psql . User ) Explicitly add a new user to the cache and to the db. This is mostly used to save overheads within psql.User.sync() Warnings Using this method means you're 100% sure the user doesn't exist. For entries that might exist, consider using sync_user() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required user psql . User The user to insert. required Source code in utils/models.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 async def insert ( self , conn : asyncpg . Connection , user : psql . User ): '''Explicitly add a new user to the cache and to the db. This is mostly used to save overheads within `psql.User.sync()` Warnings -------- Using this method means you're 100% sure the user doesn't exist. For entries that *might* exist, consider using `sync_user()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user : psql.User The user to insert. ''' await psql . User . insert_one ( conn , user ) self . __user_mapping [ user . id ] = user update async update ( conn : asyncpg . Connection , user : psql . User ) Sync the database with the new value. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required user psql . User The user value to update with. required Source code in utils/models.py 179 180 181 182 183 184 185 186 187 188 189 190 191 async def update ( self , conn : asyncpg . Connection , user : psql . User ): '''Sync the database with the new value. Parameters ---------- conn : asyncpg.Connection The connection to use. user : psql.User The user value to update with. ''' await psql . User . update ( conn , user ) self . __user_mapping [ user . id ] = user ItemCache A wrapper around dict[str, psql.Item] This includes many ways to obtain info, such as get() , keys() , items() , values() , and __getitem__() . These methods will return a deep copy of the desired object, so you can freely edit them. Warnings A cache should be used immediately upon fetching. You must periodically refresh the data if you use it in a session-like setting, otherwise, two or more cache might exist at the same time, causing some sort of \"data race\" when updating. Source code in utils/models.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 class ItemCache : '''A wrapper around `dict[str, psql.Item]` This includes many ways to obtain info, such as `get()`, `keys()`, `items()`, `values()`, and `__getitem__()`. These methods will return a deep copy of the desired object, so you can freely edit them. Warnings -------- A cache should be used immediately upon fetching. You must periodically refresh the data if you use it in a session-like setting, otherwise, two or more cache might exist at the same time, causing some sort of \"data race\" when updating. ''' def __init__ ( self ): self . __item_mapping : dict [ str , psql . Item ] = {} def __getitem__ ( self , item_id : str ) -> psql . Item : '''Return a copy of the item matching the item's id.''' return copy . deepcopy ( self . __item_mapping [ item_id ]) def get ( self , item_id : str ) -> t . Optional [ psql . Item ]: '''Return a copy of the item matching the item's id, or `None` if none was found.''' return copy . deepcopy ( self . __item_mapping . get ( item_id )) def get_by_name ( self , name_or_alias : str ): '''Return a copy of the item matching the item's name or alias, or `None` if none was found.''' if self . get ( name_or_alias ): return self . get ( name_or_alias ) name = name_or_alias . lower () for item in self . __item_mapping . values (): if name == item . name . lower (): return copy . deepcopy ( item ) if item . aliases and name in [ alias . lower () for alias in item . aliases ]: return copy . deepcopy ( item ) return None def keys ( self ): '''Return an iterable of keys inside the underlying `dict`.''' return self . __item_mapping . keys () def items ( self ): '''Return an iterable of items inside the underlying `dict`.''' return self . __item_mapping . items () def values ( self ): '''Return an iterable of values inside the underlying `dict`.''' return self . __item_mapping . values () async def update ( self , conn : asyncpg . Connection , item : psql . Item ): await psql . Item . update ( conn , item ) self . __item_mapping [ item . id ] = item def update_local ( self , item : psql . Item ): '''Set the cache item with the new value. This basically sets the internal mapping with the new item. Parameters ---------- item : psql.Item The item value to update with. ''' self . __item_mapping [ item . id ] = item __getitem__ __getitem__ ( item_id : str ) -> psql . Item Return a copy of the item matching the item's id. Source code in utils/models.py 223 224 225 226 def __getitem__ ( self , item_id : str ) -> psql . Item : '''Return a copy of the item matching the item's id.''' return copy . deepcopy ( self . __item_mapping [ item_id ]) get get ( item_id : str ) -> t . Optional [ psql . Item ] Return a copy of the item matching the item's id, or None if none was found. Source code in utils/models.py 227 228 229 230 def get ( self , item_id : str ) -> t . Optional [ psql . Item ]: '''Return a copy of the item matching the item's id, or `None` if none was found.''' return copy . deepcopy ( self . __item_mapping . get ( item_id )) get_by_name get_by_name ( name_or_alias : str ) Return a copy of the item matching the item's name or alias, or None if none was found. Source code in utils/models.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def get_by_name ( self , name_or_alias : str ): '''Return a copy of the item matching the item's name or alias, or `None` if none was found.''' if self . get ( name_or_alias ): return self . get ( name_or_alias ) name = name_or_alias . lower () for item in self . __item_mapping . values (): if name == item . name . lower (): return copy . deepcopy ( item ) if item . aliases and name in [ alias . lower () for alias in item . aliases ]: return copy . deepcopy ( item ) return None keys keys () Return an iterable of keys inside the underlying dict . Source code in utils/models.py 245 246 247 248 def keys ( self ): '''Return an iterable of keys inside the underlying `dict`.''' return self . __item_mapping . keys () items items () Return an iterable of items inside the underlying dict . Source code in utils/models.py 249 250 251 252 def items ( self ): '''Return an iterable of items inside the underlying `dict`.''' return self . __item_mapping . items () values values () Return an iterable of values inside the underlying dict . Source code in utils/models.py 253 254 255 256 def values ( self ): '''Return an iterable of values inside the underlying `dict`.''' return self . __item_mapping . values () update_local update_local ( item : psql . Item ) Set the cache item with the new value. This basically sets the internal mapping with the new item. Parameters: Name Type Description Default item psql . Item The item value to update with. required Source code in utils/models.py 261 262 263 264 265 266 267 268 269 270 271 272 def update_local ( self , item : psql . Item ): '''Set the cache item with the new value. This basically sets the internal mapping with the new item. Parameters ---------- item : psql.Item The item value to update with. ''' self . __item_mapping [ item . id ] = item DefaultColor dataclass Store several default colors to use instantly. Source code in utils/models.py 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 @dataclass ( frozen = True ) class DefaultColor : '''Store several default colors to use instantly.''' teal = hikari . Color ( 0x1abc9c ) dark_teal = hikari . Color ( 0x11806a ) brand_green = hikari . Color ( 0x57F287 ) green = hikari . Color ( 0x2ecc71 ) dark_green = hikari . Color ( 0x1f8b4c ) blue = hikari . Color ( 0x3498db ) dark_blue = hikari . Color ( 0x206694 ) purple = hikari . Color ( 0x9b59b6 ) dark_purple = hikari . Color ( 0x71368a ) magenta = hikari . Color ( 0xe91e63 ) dark_magenta = hikari . Color ( 0xad1457 ) gold = hikari . Color ( 0xf1c40f ) dark_gold = hikari . Color ( 0xc27c0e ) orange = hikari . Color ( 0xe67e22 ) dark_orange = hikari . Color ( 0xa84300 ) brand_red = hikari . Color ( 0xED4245 ) red = hikari . Color ( 0xe74c3c ) dark_red = hikari . Color ( 0x992d22 ) lighter_gray = hikari . Color ( 0x95a5a6 ) dark_gray = hikari . Color ( 0x607d8b ) light_gray = hikari . Color ( 0x979c9f ) darker_gray = hikari . Color ( 0x546e7a ) og_blurple = hikari . Color ( 0x7289da ) blurple = hikari . Color ( 0x5865F2 ) greyple = hikari . Color ( 0x5865F2 ) dark_theme = hikari . Color ( 0x36393F ) fuchsia = hikari . Color ( 0xEB459E ) yellow = hikari . Color ( 0xFEE75C ) black = hikari . Color ( 0x000000 ) white = hikari . Color ( 0xFFFFFF ) available_names = [] def __init__ ( self ): if DefaultColor . available_names : return for attr in DefaultColor . __dict__ : if attr . startswith ( \"__\" ): continue if attr in ( \"get_color\" , \"available_names\" ): continue DefaultColor . available_names . append ( attr ) @staticmethod def get_color ( color : str ): return getattr ( DefaultColor (), color ) NodeExtra dataclass A class to store extra data for the lavaplayer.Node Source code in utils/models.py 327 328 329 330 331 @dataclass class NodeExtra : '''A class to store extra data for the `lavaplayer.Node`''' queue_loop : bool = False working_channel : int = 0 MichaelBot Bases: lightbulb . BotApp A subclass of lightbulb.BotApp . This allows syntax highlight on many custom attributes. Source code in utils/models.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 class MichaelBot ( lightbulb . BotApp ): '''A subclass of `lightbulb.BotApp`. This allows syntax highlight on many custom attributes.''' __slots__ = ( \"info\" , \"secrets\" , \"online_at\" , \"logging\" , \"pool\" , \"aio_session\" , \"guild_cache\" , \"log_cache\" , \"user_cache\" , \"item_cache\" , \"lavalink\" , \"node_extra\" ) def __init__ ( self , token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None : ''' Parameters ----------------- info : dict The bot info. Store the one in `config.json`. secrets : dict The bot's secrets such as token, database info, etc. ''' self . info : dict = kwargs . pop ( \"info\" ) self . secrets : dict = kwargs . pop ( \"secrets\" ) self . online_at : dt . datetime = None self . pool : t . Optional [ asyncpg . Pool ] = None self . aio_session : t . Optional [ aiohttp . ClientSession ] = None # Store some db info. This allows read-only operation much cheaper. self . guild_cache = GuildCache () self . log_cache = LogCache () self . user_cache = UserCache () self . item_cache = ItemCache () self . lavalink : t . Optional [ lavaplayer . LavalinkClient ] = None # Currently lavaplayer doesn't support adding attr to lavaplayer.objects.Node # so we'll make a dictionary to manually track additional info. self . node_extra : dict [ int , NodeExtra ] = {} launch_options = self . info . get ( \"launch_options\" ) log_level = \"INFO\" if launch_options is None : launch_options = \"\" for option in launch_options . split (): if option in [ \"--debug\" , \"-d\" ]: default_enabled_guilds = self . info [ \"default_guilds\" ] log_level = \"DEBUG\" if option in [ \"--quiet\" , \"-q\" ]: log_level = \"\" super () . __init__ ( token , prefix , ignore_bots , owner_ids , default_enabled_guilds , help_class , help_slash_command , delete_unbound_commands , case_insensitive_prefix_commands , logs = log_level if bool ( log_level ) else None , ** kwargs ) def get_slash_command ( self , name : str ) -> t . Optional [ lightbulb . SlashCommand ]: '''Get the slash command with the given name, or `None` if none was found. Unlike the default behavior in `lightbulb.BotApp`, this also searches for subcommands. Parameters ---------- name : str The command name to search. Returns ------- t.Optional[lightbulb.SlashCommand] The slash command with that name, or `None` if none was found. ''' # Reference: https://hikari-lightbulb.readthedocs.io/en/latest/_modules/lightbulb/app.html#BotApp.get_prefix_command parts = name . split () if len ( parts ) == 1 : return self . _slash_commands . get ( name ) maybe_group = self . _slash_commands . get ( parts . pop ( 0 )) if not isinstance ( maybe_group , lightbulb . SlashCommandGroup ): return None this : t . Optional [ t . Union [ lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup , lightbulb . SlashSubCommand ] ] = maybe_group for part in parts : if this is None or isinstance ( this , lightbulb . SlashSubCommand ): return None this = this . get_subcommand ( part ) return this async def reset_cooldown ( self , ctx : lightbulb . Context ): '''A shortcut to reset a command's cooldown. Parameters ---------- ctx : lightbulb.Context The context the command is invoked. ''' if ctx . invoked . cooldown_manager is not None : await ctx . invoked . cooldown_manager . reset_cooldown ( ctx ) __init__ __init__ ( token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None Parameters: Name Type Description Default info dict The bot info. Store the one in config.json . required secrets dict The bot's secrets such as token, database info, etc. required Source code in utils/models.py 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 def __init__ ( self , token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None : ''' Parameters ----------------- info : dict The bot info. Store the one in `config.json`. secrets : dict The bot's secrets such as token, database info, etc. ''' self . info : dict = kwargs . pop ( \"info\" ) self . secrets : dict = kwargs . pop ( \"secrets\" ) self . online_at : dt . datetime = None self . pool : t . Optional [ asyncpg . Pool ] = None self . aio_session : t . Optional [ aiohttp . ClientSession ] = None # Store some db info. This allows read-only operation much cheaper. self . guild_cache = GuildCache () self . log_cache = LogCache () self . user_cache = UserCache () self . item_cache = ItemCache () self . lavalink : t . Optional [ lavaplayer . LavalinkClient ] = None # Currently lavaplayer doesn't support adding attr to lavaplayer.objects.Node # so we'll make a dictionary to manually track additional info. self . node_extra : dict [ int , NodeExtra ] = {} launch_options = self . info . get ( \"launch_options\" ) log_level = \"INFO\" if launch_options is None : launch_options = \"\" for option in launch_options . split (): if option in [ \"--debug\" , \"-d\" ]: default_enabled_guilds = self . info [ \"default_guilds\" ] log_level = \"DEBUG\" if option in [ \"--quiet\" , \"-q\" ]: log_level = \"\" super () . __init__ ( token , prefix , ignore_bots , owner_ids , default_enabled_guilds , help_class , help_slash_command , delete_unbound_commands , case_insensitive_prefix_commands , logs = log_level if bool ( log_level ) else None , ** kwargs ) get_slash_command get_slash_command ( name : str ) -> t . Optional [ lightbulb . SlashCommand ] Get the slash command with the given name, or None if none was found. Unlike the default behavior in lightbulb.BotApp , this also searches for subcommands. Parameters: Name Type Description Default name str The command name to search. required Returns: Type Description t . Optional [ lightbulb . SlashCommand ] The slash command with that name, or None if none was found. Source code in utils/models.py 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 def get_slash_command ( self , name : str ) -> t . Optional [ lightbulb . SlashCommand ]: '''Get the slash command with the given name, or `None` if none was found. Unlike the default behavior in `lightbulb.BotApp`, this also searches for subcommands. Parameters ---------- name : str The command name to search. Returns ------- t.Optional[lightbulb.SlashCommand] The slash command with that name, or `None` if none was found. ''' # Reference: https://hikari-lightbulb.readthedocs.io/en/latest/_modules/lightbulb/app.html#BotApp.get_prefix_command parts = name . split () if len ( parts ) == 1 : return self . _slash_commands . get ( name ) maybe_group = self . _slash_commands . get ( parts . pop ( 0 )) if not isinstance ( maybe_group , lightbulb . SlashCommandGroup ): return None this : t . Optional [ t . Union [ lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup , lightbulb . SlashSubCommand ] ] = maybe_group for part in parts : if this is None or isinstance ( this , lightbulb . SlashSubCommand ): return None this = this . get_subcommand ( part ) return this reset_cooldown async reset_cooldown ( ctx : lightbulb . Context ) A shortcut to reset a command's cooldown. Parameters: Name Type Description Default ctx lightbulb . Context The context the command is invoked. required Source code in utils/models.py 451 452 453 454 455 456 457 458 459 460 461 async def reset_cooldown ( self , ctx : lightbulb . Context ): '''A shortcut to reset a command's cooldown. Parameters ---------- ctx : lightbulb.Context The context the command is invoked. ''' if ctx . invoked . cooldown_manager is not None : await ctx . invoked . cooldown_manager . reset_cooldown ( ctx )","title":"models.py"},{"location":"dev/models/#utils.models.GuildCache","text":"A wrapper around dict[str, psql.Guild] This includes many ways to obtain info, such as get() , keys() , items() , values() , and __getitem__() . These methods will return a deep copy of the desired object, so you can freely edit them.","title":"GuildCache"},{"location":"dev/models/#utils.models.GuildCache--warnings","text":"A cache should be used immediately upon fetching. You must periodically refresh the data if you use it in a session-like setting, otherwise, two or more cache might exist at the same time, causing some sort of \"data race\" when updating. Source code in utils/models.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class GuildCache : '''A wrapper around `dict[str, psql.Guild]` This includes many ways to obtain info, such as `get()`, `keys()`, `items()`, `values()`, and `__getitem__()`. These methods will return a deep copy of the desired object, so you can freely edit them. Warnings -------- A cache should be used immediately upon fetching. You must periodically refresh the data if you use it in a session-like setting, otherwise, two or more cache might exist at the same time, causing some sort of \"data race\" when updating. ''' def __init__ ( self ) -> None : self . __guild_mapping : dict [ str , psql . Guild ] = {} def __getitem__ ( self , guild_id : int ): return copy . deepcopy ( self . __guild_mapping [ guild_id ]) def get ( self , guild_id : int ): return copy . deepcopy ( self . __guild_mapping . get ( guild_id )) def keys ( self ): return self . __guild_mapping . keys () def items ( self ): return self . __guild_mapping . items () def values ( self ): return self . __guild_mapping . values () async def insert ( self , conn : asyncpg . Connection , guild : psql . Guild ): '''Explicitly add a new guild to the cache and to the db. This is mostly used to save overheads within `psql.Guild.sync()` Warnings -------- Using this method means you're 100% sure the guild doesn't exist. For entries that *might* exist, consider using `update_with()`. Parameters ---------- conn : asyncpg.Connection The connection to use. guild : psql.Guild The guild to insert. ''' await psql . Guild . insert_one ( conn , guild ) self . __guild_mapping [ guild . id ] = guild async def update ( self , conn : asyncpg . Connection , guild : psql . Guild ): await psql . Guild . update ( conn , guild ) self . __guild_mapping [ guild . id ] = guild async def update_from_db ( self , conn : asyncpg . Connection , guild_id : int ): guild = await psql . Guild . get_one ( conn , guild_id ) if guild is None : del self . __guild_mapping [ guild_id ] self . __guild_mapping [ guild . id ] = guild async def update_all_from_db ( self , conn : asyncpg . Connection ): guilds = await psql . Guild . get_all ( conn ) self . __guild_mapping = {} for guild in guilds : self . __guild_mapping [ guild . id ] = guild def update_local ( self , guild : psql . Guild ): self . __guild_mapping [ guild . id ] = guild def remove_local ( self , guild_id : int ): del self . __guild_mapping [ guild_id ]","title":"Warnings"},{"location":"dev/models/#utils.models.GuildCache.insert","text":"insert ( conn : asyncpg . Connection , guild : psql . Guild ) Explicitly add a new guild to the cache and to the db. This is mostly used to save overheads within psql.Guild.sync()","title":"insert()"},{"location":"dev/models/#utils.models.GuildCache.insert--warnings","text":"Using this method means you're 100% sure the guild doesn't exist. For entries that might exist, consider using update_with() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required guild psql . Guild The guild to insert. required Source code in utils/models.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 async def insert ( self , conn : asyncpg . Connection , guild : psql . Guild ): '''Explicitly add a new guild to the cache and to the db. This is mostly used to save overheads within `psql.Guild.sync()` Warnings -------- Using this method means you're 100% sure the guild doesn't exist. For entries that *might* exist, consider using `update_with()`. Parameters ---------- conn : asyncpg.Connection The connection to use. guild : psql.Guild The guild to insert. ''' await psql . Guild . insert_one ( conn , guild ) self . __guild_mapping [ guild . id ] = guild","title":"Warnings"},{"location":"dev/models/#utils.models.LogCache","text":"A wrapper around dict[str, psql.GuildLog] This includes many ways to obtain info, such as get() , keys() , items() , values() , and __getitem__() . These methods will return a deep copy of the desired object, so you can freely edit them.","title":"LogCache"},{"location":"dev/models/#utils.models.LogCache--warnings","text":"A cache should be used immediately upon fetching. You must periodically refresh the data if you use it in a session-like setting, otherwise, two or more cache might exist at the same time, causing some sort of \"data race\" when updating. Source code in utils/models.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 class LogCache : '''A wrapper around `dict[str, psql.GuildLog]` This includes many ways to obtain info, such as `get()`, `keys()`, `items()`, `values()`, and `__getitem__()`. These methods will return a deep copy of the desired object, so you can freely edit them. Warnings -------- A cache should be used immediately upon fetching. You must periodically refresh the data if you use it in a session-like setting, otherwise, two or more cache might exist at the same time, causing some sort of \"data race\" when updating. ''' def __init__ ( self ) -> None : self . __log_mapping : dict [ str , psql . GuildLog ] = {} def __getitem__ ( self , guild_id : int ): return copy . deepcopy ( self . __log_mapping [ guild_id ]) def get ( self , guild_id : int ): return copy . deepcopy ( self . __log_mapping . get ( guild_id )) def keys ( self ): return self . __log_mapping . keys () def items ( self ): return self . __log_mapping . items () def values ( self ): return self . __log_mapping . values () async def insert ( self , conn : asyncpg . Connection , guild : psql . GuildLog ): await psql . GuildLog . insert_one ( conn , guild . guild_id ) self . __log_mapping [ guild . guild_id ] = guild async def update ( self , conn : asyncpg . Connection , guild : psql . GuildLog ): await psql . GuildLog . update ( conn , guild ) self . __log_mapping [ guild . guild_id ] = guild async def update_from_db ( self , conn : asyncpg . Connection , guild_id : int ): guild = await psql . GuildLog . get_one ( conn , guild_id ) if guild is None : del self . __log_mapping [ guild_id ] self . __log_mapping [ guild . guild_id ] = guild async def update_all_from_db ( self , conn : asyncpg . Connection ): guilds = await psql . GuildLog . get_all ( conn ) self . __log_mapping = {} for guild in guilds : self . __log_mapping [ guild . guild_id ] = guild def update_local ( self , guild : psql . GuildLog ): self . __log_mapping [ guild . guild_id ] = guild def remove_local ( self , guild_id : int ): del self . __log_mapping [ guild_id ]","title":"Warnings"},{"location":"dev/models/#utils.models.UserCache","text":"A wrapper around dict[str, psql.User] This includes many ways to obtain info, such as get() , keys() , items() , values() , and __getitem__() . These methods will return a deep copy of the desired object, so you can freely edit them.","title":"UserCache"},{"location":"dev/models/#utils.models.UserCache--warnings","text":"A cache should be used immediately upon fetching. You must periodically refresh the data if you use it in a session-like setting, otherwise, two or more cache might exist at the same time, causing some sort of \"data race\" when updating. Source code in utils/models.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 class UserCache : '''A wrapper around `dict[str, psql.User]` This includes many ways to obtain info, such as `get()`, `keys()`, `items()`, `values()`, and `__getitem__()`. These methods will return a deep copy of the desired object, so you can freely edit them. Warnings -------- A cache should be used immediately upon fetching. You must periodically refresh the data if you use it in a session-like setting, otherwise, two or more cache might exist at the same time, causing some sort of \"data race\" when updating. ''' def __init__ ( self ) -> None : self . __user_mapping : dict [ str , psql . User ] = {} def __getitem__ ( self , user_id : int ): return copy . deepcopy ( self . __user_mapping [ user_id ]) def get ( self , user_id : int ): return copy . deepcopy ( self . __user_mapping . get ( user_id )) def keys ( self ): return self . __user_mapping . keys () def items ( self ): return self . __user_mapping . items () def values ( self ): return self . __user_mapping . values () async def insert ( self , conn : asyncpg . Connection , user : psql . User ): '''Explicitly add a new user to the cache and to the db. This is mostly used to save overheads within `psql.User.sync()` Warnings -------- Using this method means you're 100% sure the user doesn't exist. For entries that *might* exist, consider using `sync_user()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user : psql.User The user to insert. ''' await psql . User . insert_one ( conn , user ) self . __user_mapping [ user . id ] = user async def update ( self , conn : asyncpg . Connection , user : psql . User ): '''Sync the database with the new value. Parameters ---------- conn : asyncpg.Connection The connection to use. user : psql.User The user value to update with. ''' await psql . User . update ( conn , user ) self . __user_mapping [ user . id ] = user async def update_from_db ( self , conn : asyncpg . Connection , user_id : int ): user = await psql . User . get_one ( conn , user_id ) if user is None : del self . __user_mapping [ user_id ] self . __user_mapping [ user . id ] = user async def update_all_from_db ( self , conn : asyncpg . Connection ): users = await psql . User . get_all ( conn ) self . __user_mapping = {} for user in users : self . __user_mapping [ user . id ] = user def update_local ( self , user : psql . User ): self . __user_mapping [ user . id ] = user","title":"Warnings"},{"location":"dev/models/#utils.models.UserCache.insert","text":"insert ( conn : asyncpg . Connection , user : psql . User ) Explicitly add a new user to the cache and to the db. This is mostly used to save overheads within psql.User.sync()","title":"insert()"},{"location":"dev/models/#utils.models.UserCache.insert--warnings","text":"Using this method means you're 100% sure the user doesn't exist. For entries that might exist, consider using sync_user() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required user psql . User The user to insert. required Source code in utils/models.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 async def insert ( self , conn : asyncpg . Connection , user : psql . User ): '''Explicitly add a new user to the cache and to the db. This is mostly used to save overheads within `psql.User.sync()` Warnings -------- Using this method means you're 100% sure the user doesn't exist. For entries that *might* exist, consider using `sync_user()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user : psql.User The user to insert. ''' await psql . User . insert_one ( conn , user ) self . __user_mapping [ user . id ] = user","title":"Warnings"},{"location":"dev/models/#utils.models.UserCache.update","text":"update ( conn : asyncpg . Connection , user : psql . User ) Sync the database with the new value. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required user psql . User The user value to update with. required Source code in utils/models.py 179 180 181 182 183 184 185 186 187 188 189 190 191 async def update ( self , conn : asyncpg . Connection , user : psql . User ): '''Sync the database with the new value. Parameters ---------- conn : asyncpg.Connection The connection to use. user : psql.User The user value to update with. ''' await psql . User . update ( conn , user ) self . __user_mapping [ user . id ] = user","title":"update()"},{"location":"dev/models/#utils.models.ItemCache","text":"A wrapper around dict[str, psql.Item] This includes many ways to obtain info, such as get() , keys() , items() , values() , and __getitem__() . These methods will return a deep copy of the desired object, so you can freely edit them.","title":"ItemCache"},{"location":"dev/models/#utils.models.ItemCache--warnings","text":"A cache should be used immediately upon fetching. You must periodically refresh the data if you use it in a session-like setting, otherwise, two or more cache might exist at the same time, causing some sort of \"data race\" when updating. Source code in utils/models.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 class ItemCache : '''A wrapper around `dict[str, psql.Item]` This includes many ways to obtain info, such as `get()`, `keys()`, `items()`, `values()`, and `__getitem__()`. These methods will return a deep copy of the desired object, so you can freely edit them. Warnings -------- A cache should be used immediately upon fetching. You must periodically refresh the data if you use it in a session-like setting, otherwise, two or more cache might exist at the same time, causing some sort of \"data race\" when updating. ''' def __init__ ( self ): self . __item_mapping : dict [ str , psql . Item ] = {} def __getitem__ ( self , item_id : str ) -> psql . Item : '''Return a copy of the item matching the item's id.''' return copy . deepcopy ( self . __item_mapping [ item_id ]) def get ( self , item_id : str ) -> t . Optional [ psql . Item ]: '''Return a copy of the item matching the item's id, or `None` if none was found.''' return copy . deepcopy ( self . __item_mapping . get ( item_id )) def get_by_name ( self , name_or_alias : str ): '''Return a copy of the item matching the item's name or alias, or `None` if none was found.''' if self . get ( name_or_alias ): return self . get ( name_or_alias ) name = name_or_alias . lower () for item in self . __item_mapping . values (): if name == item . name . lower (): return copy . deepcopy ( item ) if item . aliases and name in [ alias . lower () for alias in item . aliases ]: return copy . deepcopy ( item ) return None def keys ( self ): '''Return an iterable of keys inside the underlying `dict`.''' return self . __item_mapping . keys () def items ( self ): '''Return an iterable of items inside the underlying `dict`.''' return self . __item_mapping . items () def values ( self ): '''Return an iterable of values inside the underlying `dict`.''' return self . __item_mapping . values () async def update ( self , conn : asyncpg . Connection , item : psql . Item ): await psql . Item . update ( conn , item ) self . __item_mapping [ item . id ] = item def update_local ( self , item : psql . Item ): '''Set the cache item with the new value. This basically sets the internal mapping with the new item. Parameters ---------- item : psql.Item The item value to update with. ''' self . __item_mapping [ item . id ] = item","title":"Warnings"},{"location":"dev/models/#utils.models.ItemCache.__getitem__","text":"__getitem__ ( item_id : str ) -> psql . Item Return a copy of the item matching the item's id. Source code in utils/models.py 223 224 225 226 def __getitem__ ( self , item_id : str ) -> psql . Item : '''Return a copy of the item matching the item's id.''' return copy . deepcopy ( self . __item_mapping [ item_id ])","title":"__getitem__()"},{"location":"dev/models/#utils.models.ItemCache.get","text":"get ( item_id : str ) -> t . Optional [ psql . Item ] Return a copy of the item matching the item's id, or None if none was found. Source code in utils/models.py 227 228 229 230 def get ( self , item_id : str ) -> t . Optional [ psql . Item ]: '''Return a copy of the item matching the item's id, or `None` if none was found.''' return copy . deepcopy ( self . __item_mapping . get ( item_id ))","title":"get()"},{"location":"dev/models/#utils.models.ItemCache.get_by_name","text":"get_by_name ( name_or_alias : str ) Return a copy of the item matching the item's name or alias, or None if none was found. Source code in utils/models.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def get_by_name ( self , name_or_alias : str ): '''Return a copy of the item matching the item's name or alias, or `None` if none was found.''' if self . get ( name_or_alias ): return self . get ( name_or_alias ) name = name_or_alias . lower () for item in self . __item_mapping . values (): if name == item . name . lower (): return copy . deepcopy ( item ) if item . aliases and name in [ alias . lower () for alias in item . aliases ]: return copy . deepcopy ( item ) return None","title":"get_by_name()"},{"location":"dev/models/#utils.models.ItemCache.keys","text":"keys () Return an iterable of keys inside the underlying dict . Source code in utils/models.py 245 246 247 248 def keys ( self ): '''Return an iterable of keys inside the underlying `dict`.''' return self . __item_mapping . keys ()","title":"keys()"},{"location":"dev/models/#utils.models.ItemCache.items","text":"items () Return an iterable of items inside the underlying dict . Source code in utils/models.py 249 250 251 252 def items ( self ): '''Return an iterable of items inside the underlying `dict`.''' return self . __item_mapping . items ()","title":"items()"},{"location":"dev/models/#utils.models.ItemCache.values","text":"values () Return an iterable of values inside the underlying dict . Source code in utils/models.py 253 254 255 256 def values ( self ): '''Return an iterable of values inside the underlying `dict`.''' return self . __item_mapping . values ()","title":"values()"},{"location":"dev/models/#utils.models.ItemCache.update_local","text":"update_local ( item : psql . Item ) Set the cache item with the new value. This basically sets the internal mapping with the new item. Parameters: Name Type Description Default item psql . Item The item value to update with. required Source code in utils/models.py 261 262 263 264 265 266 267 268 269 270 271 272 def update_local ( self , item : psql . Item ): '''Set the cache item with the new value. This basically sets the internal mapping with the new item. Parameters ---------- item : psql.Item The item value to update with. ''' self . __item_mapping [ item . id ] = item","title":"update_local()"},{"location":"dev/models/#utils.models.DefaultColor","text":"Store several default colors to use instantly. Source code in utils/models.py 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 @dataclass ( frozen = True ) class DefaultColor : '''Store several default colors to use instantly.''' teal = hikari . Color ( 0x1abc9c ) dark_teal = hikari . Color ( 0x11806a ) brand_green = hikari . Color ( 0x57F287 ) green = hikari . Color ( 0x2ecc71 ) dark_green = hikari . Color ( 0x1f8b4c ) blue = hikari . Color ( 0x3498db ) dark_blue = hikari . Color ( 0x206694 ) purple = hikari . Color ( 0x9b59b6 ) dark_purple = hikari . Color ( 0x71368a ) magenta = hikari . Color ( 0xe91e63 ) dark_magenta = hikari . Color ( 0xad1457 ) gold = hikari . Color ( 0xf1c40f ) dark_gold = hikari . Color ( 0xc27c0e ) orange = hikari . Color ( 0xe67e22 ) dark_orange = hikari . Color ( 0xa84300 ) brand_red = hikari . Color ( 0xED4245 ) red = hikari . Color ( 0xe74c3c ) dark_red = hikari . Color ( 0x992d22 ) lighter_gray = hikari . Color ( 0x95a5a6 ) dark_gray = hikari . Color ( 0x607d8b ) light_gray = hikari . Color ( 0x979c9f ) darker_gray = hikari . Color ( 0x546e7a ) og_blurple = hikari . Color ( 0x7289da ) blurple = hikari . Color ( 0x5865F2 ) greyple = hikari . Color ( 0x5865F2 ) dark_theme = hikari . Color ( 0x36393F ) fuchsia = hikari . Color ( 0xEB459E ) yellow = hikari . Color ( 0xFEE75C ) black = hikari . Color ( 0x000000 ) white = hikari . Color ( 0xFFFFFF ) available_names = [] def __init__ ( self ): if DefaultColor . available_names : return for attr in DefaultColor . __dict__ : if attr . startswith ( \"__\" ): continue if attr in ( \"get_color\" , \"available_names\" ): continue DefaultColor . available_names . append ( attr ) @staticmethod def get_color ( color : str ): return getattr ( DefaultColor (), color )","title":"DefaultColor"},{"location":"dev/models/#utils.models.NodeExtra","text":"A class to store extra data for the lavaplayer.Node Source code in utils/models.py 327 328 329 330 331 @dataclass class NodeExtra : '''A class to store extra data for the `lavaplayer.Node`''' queue_loop : bool = False working_channel : int = 0","title":"NodeExtra"},{"location":"dev/models/#utils.models.MichaelBot","text":"Bases: lightbulb . BotApp A subclass of lightbulb.BotApp . This allows syntax highlight on many custom attributes. Source code in utils/models.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 class MichaelBot ( lightbulb . BotApp ): '''A subclass of `lightbulb.BotApp`. This allows syntax highlight on many custom attributes.''' __slots__ = ( \"info\" , \"secrets\" , \"online_at\" , \"logging\" , \"pool\" , \"aio_session\" , \"guild_cache\" , \"log_cache\" , \"user_cache\" , \"item_cache\" , \"lavalink\" , \"node_extra\" ) def __init__ ( self , token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None : ''' Parameters ----------------- info : dict The bot info. Store the one in `config.json`. secrets : dict The bot's secrets such as token, database info, etc. ''' self . info : dict = kwargs . pop ( \"info\" ) self . secrets : dict = kwargs . pop ( \"secrets\" ) self . online_at : dt . datetime = None self . pool : t . Optional [ asyncpg . Pool ] = None self . aio_session : t . Optional [ aiohttp . ClientSession ] = None # Store some db info. This allows read-only operation much cheaper. self . guild_cache = GuildCache () self . log_cache = LogCache () self . user_cache = UserCache () self . item_cache = ItemCache () self . lavalink : t . Optional [ lavaplayer . LavalinkClient ] = None # Currently lavaplayer doesn't support adding attr to lavaplayer.objects.Node # so we'll make a dictionary to manually track additional info. self . node_extra : dict [ int , NodeExtra ] = {} launch_options = self . info . get ( \"launch_options\" ) log_level = \"INFO\" if launch_options is None : launch_options = \"\" for option in launch_options . split (): if option in [ \"--debug\" , \"-d\" ]: default_enabled_guilds = self . info [ \"default_guilds\" ] log_level = \"DEBUG\" if option in [ \"--quiet\" , \"-q\" ]: log_level = \"\" super () . __init__ ( token , prefix , ignore_bots , owner_ids , default_enabled_guilds , help_class , help_slash_command , delete_unbound_commands , case_insensitive_prefix_commands , logs = log_level if bool ( log_level ) else None , ** kwargs ) def get_slash_command ( self , name : str ) -> t . Optional [ lightbulb . SlashCommand ]: '''Get the slash command with the given name, or `None` if none was found. Unlike the default behavior in `lightbulb.BotApp`, this also searches for subcommands. Parameters ---------- name : str The command name to search. Returns ------- t.Optional[lightbulb.SlashCommand] The slash command with that name, or `None` if none was found. ''' # Reference: https://hikari-lightbulb.readthedocs.io/en/latest/_modules/lightbulb/app.html#BotApp.get_prefix_command parts = name . split () if len ( parts ) == 1 : return self . _slash_commands . get ( name ) maybe_group = self . _slash_commands . get ( parts . pop ( 0 )) if not isinstance ( maybe_group , lightbulb . SlashCommandGroup ): return None this : t . Optional [ t . Union [ lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup , lightbulb . SlashSubCommand ] ] = maybe_group for part in parts : if this is None or isinstance ( this , lightbulb . SlashSubCommand ): return None this = this . get_subcommand ( part ) return this async def reset_cooldown ( self , ctx : lightbulb . Context ): '''A shortcut to reset a command's cooldown. Parameters ---------- ctx : lightbulb.Context The context the command is invoked. ''' if ctx . invoked . cooldown_manager is not None : await ctx . invoked . cooldown_manager . reset_cooldown ( ctx )","title":"MichaelBot"},{"location":"dev/models/#utils.models.MichaelBot.__init__","text":"__init__ ( token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None Parameters: Name Type Description Default info dict The bot info. Store the one in config.json . required secrets dict The bot's secrets such as token, database info, etc. required Source code in utils/models.py 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 def __init__ ( self , token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None : ''' Parameters ----------------- info : dict The bot info. Store the one in `config.json`. secrets : dict The bot's secrets such as token, database info, etc. ''' self . info : dict = kwargs . pop ( \"info\" ) self . secrets : dict = kwargs . pop ( \"secrets\" ) self . online_at : dt . datetime = None self . pool : t . Optional [ asyncpg . Pool ] = None self . aio_session : t . Optional [ aiohttp . ClientSession ] = None # Store some db info. This allows read-only operation much cheaper. self . guild_cache = GuildCache () self . log_cache = LogCache () self . user_cache = UserCache () self . item_cache = ItemCache () self . lavalink : t . Optional [ lavaplayer . LavalinkClient ] = None # Currently lavaplayer doesn't support adding attr to lavaplayer.objects.Node # so we'll make a dictionary to manually track additional info. self . node_extra : dict [ int , NodeExtra ] = {} launch_options = self . info . get ( \"launch_options\" ) log_level = \"INFO\" if launch_options is None : launch_options = \"\" for option in launch_options . split (): if option in [ \"--debug\" , \"-d\" ]: default_enabled_guilds = self . info [ \"default_guilds\" ] log_level = \"DEBUG\" if option in [ \"--quiet\" , \"-q\" ]: log_level = \"\" super () . __init__ ( token , prefix , ignore_bots , owner_ids , default_enabled_guilds , help_class , help_slash_command , delete_unbound_commands , case_insensitive_prefix_commands , logs = log_level if bool ( log_level ) else None , ** kwargs )","title":"__init__()"},{"location":"dev/models/#utils.models.MichaelBot.get_slash_command","text":"get_slash_command ( name : str ) -> t . Optional [ lightbulb . SlashCommand ] Get the slash command with the given name, or None if none was found. Unlike the default behavior in lightbulb.BotApp , this also searches for subcommands. Parameters: Name Type Description Default name str The command name to search. required Returns: Type Description t . Optional [ lightbulb . SlashCommand ] The slash command with that name, or None if none was found. Source code in utils/models.py 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 def get_slash_command ( self , name : str ) -> t . Optional [ lightbulb . SlashCommand ]: '''Get the slash command with the given name, or `None` if none was found. Unlike the default behavior in `lightbulb.BotApp`, this also searches for subcommands. Parameters ---------- name : str The command name to search. Returns ------- t.Optional[lightbulb.SlashCommand] The slash command with that name, or `None` if none was found. ''' # Reference: https://hikari-lightbulb.readthedocs.io/en/latest/_modules/lightbulb/app.html#BotApp.get_prefix_command parts = name . split () if len ( parts ) == 1 : return self . _slash_commands . get ( name ) maybe_group = self . _slash_commands . get ( parts . pop ( 0 )) if not isinstance ( maybe_group , lightbulb . SlashCommandGroup ): return None this : t . Optional [ t . Union [ lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup , lightbulb . SlashSubCommand ] ] = maybe_group for part in parts : if this is None or isinstance ( this , lightbulb . SlashSubCommand ): return None this = this . get_subcommand ( part ) return this","title":"get_slash_command()"},{"location":"dev/models/#utils.models.MichaelBot.reset_cooldown","text":"reset_cooldown ( ctx : lightbulb . Context ) A shortcut to reset a command's cooldown. Parameters: Name Type Description Default ctx lightbulb . Context The context the command is invoked. required Source code in utils/models.py 451 452 453 454 455 456 457 458 459 460 461 async def reset_cooldown ( self , ctx : lightbulb . Context ): '''A shortcut to reset a command's cooldown. Parameters ---------- ctx : lightbulb.Context The context the command is invoked. ''' if ctx . invoked . cooldown_manager is not None : await ctx . invoked . cooldown_manager . reset_cooldown ( ctx )","title":"reset_cooldown()"},{"location":"dev/psql/","text":"Contains many functions and classes that hide all \"naked\" SQL to use. Classes This module has a dataclass for every table currently exist in dbsetup.py . These are used to nicely store a row of data in designated table. However, they don't have any member functions. All SQL functions are static. If you don't use any SQL functions due to performance, you can use these classes to organize your data a bit better than naked dictionary. SQL Functions The SQL functions are meant to make the bot's code looks nice without SQL strings everywhere. They also can be slightly customized to deal with common operations. Therefore, these functions will contain overheads. If performance is your main concern, do not use any of these static functions. Generally, all these functions are self-contained, meaning if something screw up, they'll rollback on their own. However, using multiple functions at a time in the bot's code can be dangerous without wrapping them around a transaction. Each class has a __PREVENT_UPDATE tuple that will contains columns that can't be updated via SQL functions for safety. These are usually primary keys or read-only attributes (attributes that doesn't exist on the table, but only for the sake of convenience, like from JOIN table). Other Functions Some public functions can be convenient to use if you decide to not use the SQL functions and instead deal with SQL on your own. Example Without transaction: # This is just an example. In reality, you should use `models.UserCache` instead of directly working on `psql.User`. async with pool.acquire() as conn: user: psql.User | None = await psql.User.get_one(conn, user_id) assert user is not None user.is_whitelist = ... user.balance = ... await psql.User.update(conn, user) With transaction: async with pool.acquire() as conn: users: list[psql.User] | None = await psql.User.get_all(conn) async with conn.transaction(): for user in users: user.is_whitelist = ... user.balance = ... await psql.User.update(conn, user) Error Bases: Exception A base error for high-level PostgreSQL operations. Source code in utils/psql.py 68 69 class Error ( Exception ): '''A base error for high-level PostgreSQL operations.''' GetError Bases: Error A base error for SELECT operations. Notes This should only be raised when get_x() is implicitly called. This will NOT be raised if the user explicitly calls get_x() . Source code in utils/psql.py 71 72 73 74 75 76 77 78 class GetError ( Error ): '''A base error for SELECT operations. Notes ----- This should only be raised when `get_x()` is implicitly called. This will NOT be raised if the user explicitly calls `get_x()`. ''' InsertError Bases: Error A base error for INSERT operations. Source code in utils/psql.py 80 81 class InsertError ( Error ): '''A base error for INSERT operations.''' DeleteError Bases: Error A base error for DELETE operations. Source code in utils/psql.py 83 84 class DeleteError ( Error ): '''A base error for DELETE operations.''' UpdateError Bases: Error A base error for UPDATE operations. Source code in utils/psql.py 86 87 class UpdateError ( Error ): '''A base error for UPDATE operations.''' DuplicateArrayElement Bases: UpdateError Raised when trying to add an element that's already available in a unique-only list (set). Source code in utils/psql.py 89 90 class DuplicateArrayElement ( UpdateError ): '''Raised when trying to add an element that's already available in a unique-only list (set).''' Guild dataclass Represent an entry in the Guilds table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. Source code in utils/psql.py 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 @dataclasses . dataclass ( slots = True ) class Guild : '''Represent an entry in the `Guilds` table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. ''' id : int name : str is_whitelist : bool = True prefix : str = '$' __PREVENT_UPDATE = ( \"id\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entries in the table.''' return await Guild . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Guilds ORDER BY Guilds.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Guild if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ Guild , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM Guilds WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Guild if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , guild : Guild ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"Guilds\" , len ( guild . __slots__ )) return await run_and_return_count ( conn , query , guild . id , guild . name , guild . is_whitelist , guild . prefix ) @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Guilds WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Guild . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Guilds SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) @staticmethod async def update ( conn : asyncpg . Connection , guild : Guild ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_guild = await Guild . get_one ( conn , guild . id ) if not existed_guild : return await Guild . insert_one ( conn , guild ) diff_col = [] for col in existed_guild . __slots__ : if getattr ( existed_guild , col ) != getattr ( guild , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Guild . update_column ( conn , guild . id , change , getattr ( guild , change )) get_all async staticmethod get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]] Get all entries in the table. Source code in utils/psql.py 265 266 267 268 269 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entries in the table.''' return await Guild . get_all_where ( conn , as_dict = as_dict ) get_all_where async staticmethod get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]] Get all entires in the table that matches the condition. Source code in utils/psql.py 270 271 272 273 274 275 276 277 278 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Guilds ORDER BY Guilds.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Guild if not as_dict else dict ) get_one async staticmethod get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ Guild , dict ] Get the first entry in the table that matches the pkey provided. Source code in utils/psql.py 279 280 281 282 283 284 285 286 287 @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ Guild , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM Guilds WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Guild if not as_dict else dict ) insert_one async staticmethod insert_one ( conn : asyncpg . Connection , guild : Guild ) -> int Insert an entry into the table. Source code in utils/psql.py 288 289 290 291 292 293 @staticmethod async def insert_one ( conn : asyncpg . Connection , guild : Guild ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"Guilds\" , len ( guild . __slots__ )) return await run_and_return_count ( conn , query , guild . id , guild . name , guild . is_whitelist , guild . prefix ) delete async staticmethod delete ( conn : asyncpg . Connection , id : int ) -> int Delete an entry in the table based on the provided key. Source code in utils/psql.py 294 295 296 297 298 299 300 301 302 @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Guilds WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) update_column async staticmethod update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int Update a specific column with a new value. Warnings Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes Always prefer using other functions to update rather than this function if possible. Source code in utils/psql.py 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Guild . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Guilds SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) update async staticmethod update ( conn : asyncpg . Connection , guild : Guild ) -> int Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead. Notes This function has its own transaction. Source code in utils/psql.py 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 @staticmethod async def update ( conn : asyncpg . Connection , guild : Guild ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_guild = await Guild . get_one ( conn , guild . id ) if not existed_guild : return await Guild . insert_one ( conn , guild ) diff_col = [] for col in existed_guild . __slots__ : if getattr ( existed_guild , col ) != getattr ( guild , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Guild . update_column ( conn , guild . id , change , getattr ( guild , change )) GuildLog dataclass Represent an entry in the GuildsLogs table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. Source code in utils/psql.py 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 @dataclasses . dataclass ( slots = True ) class GuildLog : '''Represent an entry in the `GuildsLogs` table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. ''' guild_id : int log_channel : int = None guild_channel_create : bool = True guild_channel_delete : bool = True guild_channel_update : bool = True guild_ban : bool = True guild_unban : bool = True guild_update : bool = True member_join : bool = True member_leave : bool = True member_update : bool = True guild_bulk_message_delete : bool = True guild_message_delete : bool = True guild_message_update : bool = True role_create : bool = True role_delete : bool = True role_update : bool = True command_complete : bool = True command_error : bool = True __PREVENT_UPDATE = ( \"guild_id\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]]: '''Get all entries in the table.''' return await GuildLog . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM GuildsLogs; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = GuildLog if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ GuildLog , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = GuildLog if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , guild_id : int ) -> int : '''Insert an entry into the table.''' # Only guild_id is required. query = insert_into_query ( \"GuildsLogs\" , 1 ) return await run_and_return_count ( conn , query , guild_id ) @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in GuildLog . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE GuildsLogs SET { column } = ($1) WHERE guild_id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) @staticmethod async def update ( conn : asyncpg . Connection , guild : GuildLog ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_guild = await GuildLog . get_one ( conn , guild . guild_id ) if not existed_guild : return await GuildLog . insert_one ( conn , guild . guild_id ) diff_col = [] for col in existed_guild . __slots__ : if getattr ( existed_guild , col ) != getattr ( guild , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await GuildLog . update_column ( conn , guild . guild_id , change , getattr ( guild , change )) get_all async staticmethod get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]] Get all entries in the table. Source code in utils/psql.py 378 379 380 381 382 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]]: '''Get all entries in the table.''' return await GuildLog . get_all_where ( conn , as_dict = as_dict ) get_all_where async staticmethod get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]] Get all entires in the table that matches the condition. Source code in utils/psql.py 383 384 385 386 387 388 389 390 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM GuildsLogs; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = GuildLog if not as_dict else dict ) get_one async staticmethod get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ GuildLog , dict ] Get the first entry in the table that matches the pkey provided. Source code in utils/psql.py 391 392 393 394 395 396 397 398 399 @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ GuildLog , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = GuildLog if not as_dict else dict ) insert_one async staticmethod insert_one ( conn : asyncpg . Connection , guild_id : int ) -> int Insert an entry into the table. Source code in utils/psql.py 400 401 402 403 404 405 406 @staticmethod async def insert_one ( conn : asyncpg . Connection , guild_id : int ) -> int : '''Insert an entry into the table.''' # Only guild_id is required. query = insert_into_query ( \"GuildsLogs\" , 1 ) return await run_and_return_count ( conn , query , guild_id ) delete async staticmethod delete ( conn : asyncpg . Connection , id : int ) -> int Delete an entry in the table based on the provided key. Source code in utils/psql.py 407 408 409 410 411 412 413 414 415 @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) update_column async staticmethod update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int Update a specific column with a new value. Warnings Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes Always prefer using other functions to update rather than this function if possible. Source code in utils/psql.py 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in GuildLog . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE GuildsLogs SET { column } = ($1) WHERE guild_id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) update async staticmethod update ( conn : asyncpg . Connection , guild : GuildLog ) -> int Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead. Notes This function has its own transaction. Source code in utils/psql.py 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 @staticmethod async def update ( conn : asyncpg . Connection , guild : GuildLog ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_guild = await GuildLog . get_one ( conn , guild . guild_id ) if not existed_guild : return await GuildLog . insert_one ( conn , guild . guild_id ) diff_col = [] for col in existed_guild . __slots__ : if getattr ( existed_guild , col ) != getattr ( guild , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await GuildLog . update_column ( conn , guild . guild_id , change , getattr ( guild , change )) User dataclass Represent an entry in the Users table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. Source code in utils/psql.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 @dataclasses . dataclass ( slots = True ) class User : '''Represent an entry in the `Users` table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. ''' id : int name : str is_whitelist : bool = True balance : int = 0 world : str = \"overworld\" last_travel : t . Optional [ dt . datetime ] = None daily_streak : int = 0 last_daily : t . Optional [ dt . datetime ] = None health : int = 100 __WORLD_TYPE = ( \"overworld\" , \"nether\" , \"end\" ) __PREVENT_UPDATE = ( \"id\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ User ]: '''Get all entries in the table.''' return await User . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ User , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Users ORDER BY Users.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = User if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , as_dict : bool = False ) -> t . Union [ User , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM Users WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = User if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , user : User ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"Users\" , len ( user . __slots__ )) return await run_and_return_count ( conn , query , user . id , user . name , user . is_whitelist , user . balance , user . world , user . last_travel , user . daily_streak , user . last_daily , user . health ) @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Users WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in User . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Users SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) @staticmethod async def update_balance ( conn : asyncpg . Connection , id : int , new_balance : int ) -> int : if new_balance < 0 : # Might raise a warning here? return 0 return await User . update_column ( conn , id , \"balance\" , new_balance ) @staticmethod async def update_streak ( conn : asyncpg . Connection , id : int , new_streak : int ) -> int : if new_streak < 0 : # Might raise a warning here? return 0 return await User . update_column ( conn , id , \"daily_streak\" , new_streak ) @staticmethod async def add_money ( conn : asyncpg . Connection , id : int , amount : int ) -> int : if amount <= 0 : return 0 existed = await User . get_one ( conn , id ) if not existed : raise UpdateError ( f \"Trying to update entry ' { id } ', but it is not found.\" ) return await User . update_balance ( conn , id , existed . balance + amount ) @staticmethod async def remove_money ( conn : asyncpg . Connection , id : int , amount : int ) -> int : if amount <= 0 : return 0 existed = await User . get_one ( conn , id ) if not existed : raise UpdateError ( f \"Trying to update entry ' { id } ', but it is not found.\" ) if existed . balance <= amount : # Might raise a warning here? Idk. existed . balance = 0 else : existed . balance -= amount return await User . update_balance ( conn , id , existed . balance ) @staticmethod async def update ( conn : asyncpg . Connection , user : User ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_user = await User . get_one ( conn , user . id ) if not existed_user : return await User . insert_one ( conn , user ) diff_col = [] for col in existed_user . __slots__ : if getattr ( existed_user , col ) != getattr ( user , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await User . update_column ( conn , user . id , change , getattr ( user , change )) get_all async staticmethod get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ User ] Get all entries in the table. Source code in utils/psql.py 482 483 484 485 486 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ User ]: '''Get all entries in the table.''' return await User . get_all_where ( conn , as_dict = as_dict ) get_all_where async staticmethod get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ User , dict ]] Get all entires in the table that matches the condition. Source code in utils/psql.py 487 488 489 490 491 492 493 494 495 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ User , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Users ORDER BY Users.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = User if not as_dict else dict ) get_one async staticmethod get_one ( conn : asyncpg . Connection , id : int , as_dict : bool = False ) -> t . Union [ User , dict ] Get the first entry in the table that matches the pkey provided. Source code in utils/psql.py 496 497 498 499 500 501 502 503 504 @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , as_dict : bool = False ) -> t . Union [ User , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM Users WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = User if not as_dict else dict ) insert_one async staticmethod insert_one ( conn : asyncpg . Connection , user : User ) -> int Insert an entry into the table. Source code in utils/psql.py 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 @staticmethod async def insert_one ( conn : asyncpg . Connection , user : User ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"Users\" , len ( user . __slots__ )) return await run_and_return_count ( conn , query , user . id , user . name , user . is_whitelist , user . balance , user . world , user . last_travel , user . daily_streak , user . last_daily , user . health ) delete async staticmethod delete ( conn : asyncpg . Connection , id : int ) -> int Delete an entry in the table based on the provided key. Source code in utils/psql.py 521 522 523 524 525 526 527 528 529 @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Users WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) update_column async staticmethod update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int Update a specific column with a new value. Warnings Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes Always prefer using other functions to update rather than this function if possible. Source code in utils/psql.py 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in User . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Users SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) update async staticmethod update ( conn : asyncpg . Connection , user : User ) -> int Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead. Notes This function has its own transaction. Source code in utils/psql.py 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 @staticmethod async def update ( conn : asyncpg . Connection , user : User ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_user = await User . get_one ( conn , user . id ) if not existed_user : return await User . insert_one ( conn , user ) diff_col = [] for col in existed_user . __slots__ : if getattr ( existed_user , col ) != getattr ( user , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await User . update_column ( conn , user . id , change , getattr ( user , change )) Reminders dataclass Represent an entry in the Reminders table along with possible operations related to the table. Source code in utils/psql.py 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 @dataclasses . dataclass ( slots = True ) class Reminders : '''Represent an entry in the `Reminders` table along with possible operations related to the table.''' remind_id : int user_id : int awake_time : dt . datetime message : str __PREVENT_UPDATE = ( \"remind_id\" , \"user_id\" ) @staticmethod async def get_user_reminders ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders a user have.''' query = \"\"\" SELECT * FROM Reminders WHERE user_id = ($1); \"\"\" result = await conn . fetch ( query , user_id ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] @staticmethod async def get_reminders ( conn : asyncpg . Connection , lower_time : dt . datetime , upper_time : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders within `(lower_time, upper_time]`.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time > ($1) AND awake_time <= ($2); \"\"\" result = await conn . fetch ( query , lower_time , upper_time ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] @staticmethod async def get_past_reminders ( conn : asyncpg . Connection , now : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders that are supposed to be cleared before the time provided.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time < ($1); \"\"\" result = await conn . fetch ( query , now ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] @staticmethod async def insert_reminder ( conn : asyncpg . Connection , user_id : int , when : dt . datetime , message : str ) -> int : '''Insert a reminder entry.''' query = \"\"\" INSERT INTO Reminders (user_id, awake_time, message) VALUES ($1, $2, $3); \"\"\" return await run_and_return_count ( conn , query , user_id , when , message ) @staticmethod async def delete_reminder ( conn : asyncpg . Connection , remind_id : int , user_id : int ) -> int : '''Delete a reminder entry.''' # Although remind_id is sufficient, user_id is to make sure a user can't remove another reminder. query = \"\"\" DELETE FROM Reminders WHERE remind_id = ($1) AND user_id = ($2); \"\"\" return await run_and_return_count ( conn , query , remind_id , user_id ) get_user_reminders async staticmethod get_user_reminders ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]] Get a list of reminders a user have. Source code in utils/psql.py 627 628 629 630 631 632 633 634 635 636 637 @staticmethod async def get_user_reminders ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders a user have.''' query = \"\"\" SELECT * FROM Reminders WHERE user_id = ($1); \"\"\" result = await conn . fetch ( query , user_id ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] get_reminders async staticmethod get_reminders ( conn : asyncpg . Connection , lower_time : dt . datetime , upper_time : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]] Get a list of reminders within (lower_time, upper_time] . Source code in utils/psql.py 638 639 640 641 642 643 644 645 646 647 648 @staticmethod async def get_reminders ( conn : asyncpg . Connection , lower_time : dt . datetime , upper_time : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders within `(lower_time, upper_time]`.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time > ($1) AND awake_time <= ($2); \"\"\" result = await conn . fetch ( query , lower_time , upper_time ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] get_past_reminders async staticmethod get_past_reminders ( conn : asyncpg . Connection , now : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]] Get a list of reminders that are supposed to be cleared before the time provided. Source code in utils/psql.py 649 650 651 652 653 654 655 656 657 658 659 @staticmethod async def get_past_reminders ( conn : asyncpg . Connection , now : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders that are supposed to be cleared before the time provided.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time < ($1); \"\"\" result = await conn . fetch ( query , now ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] insert_reminder async staticmethod insert_reminder ( conn : asyncpg . Connection , user_id : int , when : dt . datetime , message : str ) -> int Insert a reminder entry. Source code in utils/psql.py 660 661 662 663 664 665 666 667 668 @staticmethod async def insert_reminder ( conn : asyncpg . Connection , user_id : int , when : dt . datetime , message : str ) -> int : '''Insert a reminder entry.''' query = \"\"\" INSERT INTO Reminders (user_id, awake_time, message) VALUES ($1, $2, $3); \"\"\" return await run_and_return_count ( conn , query , user_id , when , message ) delete_reminder async staticmethod delete_reminder ( conn : asyncpg . Connection , remind_id : int , user_id : int ) -> int Delete a reminder entry. Source code in utils/psql.py 669 670 671 672 673 674 675 676 677 678 @staticmethod async def delete_reminder ( conn : asyncpg . Connection , remind_id : int , user_id : int ) -> int : '''Delete a reminder entry.''' # Although remind_id is sufficient, user_id is to make sure a user can't remove another reminder. query = \"\"\" DELETE FROM Reminders WHERE remind_id = ($1) AND user_id = ($2); \"\"\" return await run_and_return_count ( conn , query , remind_id , user_id ) Item dataclass Represent an entry in the Items table along with possible operations related to the table. This is mostly used for the bot's cache purpose. If you're using this directly in a code, you're probably doing it wrong. Source code in utils/psql.py 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 @dataclasses . dataclass ( slots = True ) class Item : '''Represent an entry in the `Items` table along with possible operations related to the table. This is mostly used for the bot's cache purpose. If you're using this directly in a code, you're probably doing it wrong. ''' id : str sort_id : int name : str emoji : str description : str rarity : str sell_price : int buy_price : t . Optional [ int ] = None aliases : list [ str ] = dataclasses . field ( default_factory = list ) durability : int = None __PREVENT_UPDATE = ( \"id\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]]: '''Get all entries in the table.''' return await Item . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Item ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Items ORDER by sort_id; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Item if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ]: '''Get the first entry in the table that matches the condition.''' query = \"\"\" SELECT * FROM Items WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Item if not as_dict else dict ) @staticmethod async def get_by_name ( conn : asyncpg . Connection , name_or_alias : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ]: '''Get the first item that has its name/aliases match the provided.''' def filter_name_alias ( record : Item ): return record . name . lower () == name_or_alias . lower () or name_or_alias . lower () in [ alias . lower () for alias in record . aliases ] res = await Item . get_all_where ( conn , where = filter_name_alias , as_dict = as_dict ) assert len ( res ) <= 1 if res : return res [ 0 ] return None @staticmethod async def insert_one ( conn : asyncpg . Connection , item : Item ): '''Insert an entry into the table.''' query = insert_into_query ( \"Items\" , len ( item . __slots__ )) return await run_and_return_count ( conn , query , item . id , item . sort_id , item . name , item . aliases , item . emoji , item . description , item . rarity , item . buy_price , item . sell_price , item . durability , ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Item . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Items SET { column } = ($2) WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id , new_value ) @staticmethod async def update ( conn : asyncpg . Connection , item : Item ): '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_item = await Item . get_one ( conn , item . id ) if existing_item is None : await Item . insert_one ( conn , item ) logger . info ( \"Loaded new item ' %s ' into the database.\" , item . id ) else : diff_col = [] for col in existing_item . __slots__ : if getattr ( existing_item , col ) != getattr ( item , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Item . update_column ( conn , item . id , change , getattr ( item , change )) if diff_col : logger . info ( \"Updated item ' %s ' in the following columns: %s .\" , item . id , diff_col ) get_all async staticmethod get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]] Get all entries in the table. Source code in utils/psql.py 700 701 702 703 704 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]]: '''Get all entries in the table.''' return await Item . get_all_where ( conn , as_dict = as_dict ) get_all_where async staticmethod get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Item ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]] Get all entires in the table that matches the condition. Source code in utils/psql.py 705 706 707 708 709 710 711 712 713 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Item ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Items ORDER by sort_id; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Item if not as_dict else dict ) get_one async staticmethod get_one ( conn : asyncpg . Connection , id : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ] Get the first entry in the table that matches the condition. Source code in utils/psql.py 714 715 716 717 718 719 720 721 722 @staticmethod async def get_one ( conn : asyncpg . Connection , id : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ]: '''Get the first entry in the table that matches the condition.''' query = \"\"\" SELECT * FROM Items WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Item if not as_dict else dict ) get_by_name async staticmethod get_by_name ( conn : asyncpg . Connection , name_or_alias : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ] Get the first item that has its name/aliases match the provided. Source code in utils/psql.py 723 724 725 726 727 728 729 730 731 732 733 734 735 @staticmethod async def get_by_name ( conn : asyncpg . Connection , name_or_alias : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ]: '''Get the first item that has its name/aliases match the provided.''' def filter_name_alias ( record : Item ): return record . name . lower () == name_or_alias . lower () or name_or_alias . lower () in [ alias . lower () for alias in record . aliases ] res = await Item . get_all_where ( conn , where = filter_name_alias , as_dict = as_dict ) assert len ( res ) <= 1 if res : return res [ 0 ] return None insert_one async staticmethod insert_one ( conn : asyncpg . Connection , item : Item ) Insert an entry into the table. Source code in utils/psql.py 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 @staticmethod async def insert_one ( conn : asyncpg . Connection , item : Item ): '''Insert an entry into the table.''' query = insert_into_query ( \"Items\" , len ( item . __slots__ )) return await run_and_return_count ( conn , query , item . id , item . sort_id , item . name , item . aliases , item . emoji , item . description , item . rarity , item . buy_price , item . sell_price , item . durability , ) update_column async staticmethod update_column ( conn : asyncpg . Connection , id : str , column : str , new_value ) -> int Update a specific column with a new value. Warnings Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes Always prefer using other functions to update rather than this function if possible. Source code in utils/psql.py 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 @staticmethod async def update_column ( conn : asyncpg . Connection , id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Item . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Items SET { column } = ($2) WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id , new_value ) update async staticmethod update ( conn : asyncpg . Connection , item : Item ) Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead. Notes This function has its own transaction. Source code in utils/psql.py 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 @staticmethod async def update ( conn : asyncpg . Connection , item : Item ): '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_item = await Item . get_one ( conn , item . id ) if existing_item is None : await Item . insert_one ( conn , item ) logger . info ( \"Loaded new item ' %s ' into the database.\" , item . id ) else : diff_col = [] for col in existing_item . __slots__ : if getattr ( existing_item , col ) != getattr ( item , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Item . update_column ( conn , item . id , change , getattr ( item , change )) if diff_col : logger . info ( \"Updated item ' %s ' in the following columns: %s .\" , item . id , diff_col ) Inventory dataclass Represent an entry in the UserInventory table along with possible operations related to the table. Source code in utils/psql.py 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 @dataclasses . dataclass ( slots = True ) class Inventory : '''Represent an entry in the `UserInventory` table along with possible operations related to the table.''' user_id : int item_id : str amount : int __PREVENT_UPDATE = ( \"user_id\" , \"item_id\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entries in the table.''' return await Inventory . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Inventory ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM UserInventory ORDER BY amount DESC; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Inventory if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Inventory , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM UserInventory WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , item_id , result_type = Inventory if not as_dict else dict ) @staticmethod async def get_user_inventory ( conn , user_id : int , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entries in the table that belongs to a user.''' return await Inventory . get_all_where ( conn , where = lambda r : r . user_id == user_id , as_dict = as_dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"UserInventory\" , len ( Inventory . __slots__ )) return await run_and_return_count ( conn , query , inventory . user_id , inventory . item_id , inventory . amount ) @staticmethod async def delete ( conn : asyncpg . Connection , user_id : int , item_id : str ) -> int : query = \"\"\" DELETE FROM UserInventory WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id ) @staticmethod async def update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Inventory . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE UserInventory SET { column } = ($3) WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id , new_value ) @staticmethod async def add ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int : '''Add item into the user's inventory. Notes ----- This should be preferred over `Inventory.insert_one()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user_id : int The user's id to insert. item_id : str The item's id to insert. amount : int, optional The amount of items to add. Default to 1. Returns ------- int The number of entries affected. Should be 1 or 0. ''' existed = await Inventory . get_one ( conn , user_id , item_id ) if not existed : return await Inventory . insert_one ( conn , Inventory ( user_id , item_id , amount )) else : return await Inventory . update_column ( conn , user_id , item_id , \"amount\" , existed . amount + amount ) @staticmethod async def remove ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int : '''Remove item from the user's inventory. Notes ----- This should be preferred over `Inventory.delete()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user_id : int The user's id to insert. item_id : str The item's id to insert. amount : int, optional The amount of items to remove. Default to 1. Returns ------- int The number of entries affected. Should be 1 or 0. ''' existed = await Inventory . get_one ( conn , user_id , item_id ) if not existed : return 0 elif existed . amount <= amount : return await Inventory . delete ( conn , user_id , item_id ) else : return await Inventory . update_column ( conn , user_id , item_id , \"amount\" , existed . amount - amount ) @staticmethod async def update ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_inv = await Inventory . get_one ( conn , inventory . user_id , inventory . item_id ) if not existing_inv : return await Inventory . insert_one ( conn , inventory ) if inventory . amount <= 0 : return await Inventory . delete ( conn , inventory . user_id , inventory . item_id ) diff_col = [] for col in existing_inv . __slots__ : if col in ( \"user_id\" , \"item_id\" , \"amount\" ): if getattr ( existing_inv , col ) != getattr ( inventory , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Inventory . update_column ( conn , inventory . user_id , inventory . item_id , change , getattr ( inventory , change )) get_all async staticmethod get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]] Get all entries in the table. Source code in utils/psql.py 813 814 815 816 817 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entries in the table.''' return await Inventory . get_all_where ( conn , as_dict = as_dict ) get_all_where async staticmethod get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Inventory ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]] Get all entires in the table that matches the condition. Source code in utils/psql.py 818 819 820 821 822 823 824 825 826 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Inventory ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM UserInventory ORDER BY amount DESC; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Inventory if not as_dict else dict ) get_one async staticmethod get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Inventory , dict ] Get the first entry in the table that matches the pkey provided. Source code in utils/psql.py 827 828 829 830 831 832 833 834 835 836 @staticmethod async def get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Inventory , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM UserInventory WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , item_id , result_type = Inventory if not as_dict else dict ) get_user_inventory async staticmethod get_user_inventory ( conn , user_id : int , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]] Get all entries in the table that belongs to a user. Source code in utils/psql.py 837 838 839 840 841 @staticmethod async def get_user_inventory ( conn , user_id : int , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entries in the table that belongs to a user.''' return await Inventory . get_all_where ( conn , where = lambda r : r . user_id == user_id , as_dict = as_dict ) insert_one async staticmethod insert_one ( conn : asyncpg . Connection , inventory : Inventory ) -> int Insert an entry into the table. Source code in utils/psql.py 842 843 844 845 846 847 @staticmethod async def insert_one ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"UserInventory\" , len ( Inventory . __slots__ )) return await run_and_return_count ( conn , query , inventory . user_id , inventory . item_id , inventory . amount ) update_column async staticmethod update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int Update a specific column with a new value. Warnings Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes Always prefer using other functions to update rather than this function if possible. Source code in utils/psql.py 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 @staticmethod async def update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Inventory . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE UserInventory SET { column } = ($3) WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id , new_value ) add async staticmethod add ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int Add item into the user's inventory. Notes This should be preferred over Inventory.insert_one() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required user_id int The user's id to insert. required item_id str The item's id to insert. required amount int , optional The amount of items to add. Default to 1. 1 Returns: Type Description int The number of entries affected. Should be 1 or 0. Source code in utils/psql.py 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 @staticmethod async def add ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int : '''Add item into the user's inventory. Notes ----- This should be preferred over `Inventory.insert_one()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user_id : int The user's id to insert. item_id : str The item's id to insert. amount : int, optional The amount of items to add. Default to 1. Returns ------- int The number of entries affected. Should be 1 or 0. ''' existed = await Inventory . get_one ( conn , user_id , item_id ) if not existed : return await Inventory . insert_one ( conn , Inventory ( user_id , item_id , amount )) else : return await Inventory . update_column ( conn , user_id , item_id , \"amount\" , existed . amount + amount ) remove async staticmethod remove ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int Remove item from the user's inventory. Notes This should be preferred over Inventory.delete() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required user_id int The user's id to insert. required item_id str The item's id to insert. required amount int , optional The amount of items to remove. Default to 1. 1 Returns: Type Description int The number of entries affected. Should be 1 or 0. Source code in utils/psql.py 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 @staticmethod async def remove ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int : '''Remove item from the user's inventory. Notes ----- This should be preferred over `Inventory.delete()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user_id : int The user's id to insert. item_id : str The item's id to insert. amount : int, optional The amount of items to remove. Default to 1. Returns ------- int The number of entries affected. Should be 1 or 0. ''' existed = await Inventory . get_one ( conn , user_id , item_id ) if not existed : return 0 elif existed . amount <= amount : return await Inventory . delete ( conn , user_id , item_id ) else : return await Inventory . update_column ( conn , user_id , item_id , \"amount\" , existed . amount - amount ) update async staticmethod update ( conn : asyncpg . Connection , inventory : Inventory ) -> int Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead. Notes This function has its own transaction. Source code in utils/psql.py 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 @staticmethod async def update ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_inv = await Inventory . get_one ( conn , inventory . user_id , inventory . item_id ) if not existing_inv : return await Inventory . insert_one ( conn , inventory ) if inventory . amount <= 0 : return await Inventory . delete ( conn , inventory . user_id , inventory . item_id ) diff_col = [] for col in existing_inv . __slots__ : if col in ( \"user_id\" , \"item_id\" , \"amount\" ): if getattr ( existing_inv , col ) != getattr ( inventory , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Inventory . update_column ( conn , inventory . user_id , inventory . item_id , change , getattr ( inventory , change )) Equipment dataclass Represent an entry in the UserEquipment table along with possible operations related to the table. Source code in utils/psql.py 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 @dataclasses . dataclass ( slots = True ) class Equipment : '''Represent an entry in the `UserEquipment` table along with possible operations related to the table.''' user_id : int item_id : str eq_type : str remain_durability : int __EQUIPMENT_TYPE__ = ( \"_sword\" , \"_pickaxe\" , \"_axe\" , \"_potion\" ) __PREVENT_UPDATE = ( \"user_id\" , \"item_id\" , \"eq_type\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: '''Get all entries in the table.''' return await Equipment . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Equipment ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM UserEquipment; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Equipment if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM UserEquipment WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , item_id , result_type = Equipment if not as_dict else dict ) @staticmethod async def get_equipment ( conn : asyncpg . Connection , user_id : int , equipment_type : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ]: '''Get a user's equipment based on equipment type.''' query = \"\"\" SELECT * FROM UserEquipment WHERE user_id = ($1) AND eq_type = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , equipment_type , result_type = Equipment if not as_dict else dict ) @staticmethod async def get_user_equipments ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: return await Equipment . get_all_where ( conn , where = lambda r : r . user_id == user_id , as_dict = as_dict ) @staticmethod async def get_user_potions ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: return await Equipment . get_all_where ( conn , where = lambda r : Equipment . is_potion ( r . item_id ) and r . user_id == user_id , as_dict = as_dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , equipment : Equipment ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"UserEquipment\" , len ( equipment . __slots__ )) return await run_and_return_count ( conn , query , equipment . user_id , equipment . item_id , equipment . eq_type , equipment . remain_durability ) @staticmethod async def transfer_from_inventory ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Transfer an equipment from the inventory. Warnings -------- This does not check whether the user already has that equipment. This must be checked by the user, otherwise an `asyncpg.UniqueViolationError` might be raised. Notes ----- This function already has its own transaction. There is no need to wrap a transaction for this function. Parameters ---------- conn : asyncpg.Connection The connection to use. inventory : Inventory The inventory wrapping the equipment. Returns ------- int The number of entries affected. Should be 1 or 0. Raises ------ asyncpg.UniqueViolationError The unique constraint on `(user_id, eq_type)` is violated. ''' is_equipment = False for eq_type in Equipment . __EQUIPMENT_TYPE__ : if eq_type in inventory . item_id : is_equipment = True item = await Item . get_one ( conn , inventory . item_id ) equipment = Equipment ( inventory . user_id , inventory . item_id , eq_type , item . durability ) break if not is_equipment : return 0 async with conn . transaction (): status = await Inventory . remove ( conn , inventory . user_id , inventory . item_id ) if status == 0 : return 0 # TODO: Add a check to see if the same equipment type is already there. return await Equipment . insert_one ( conn , equipment ) @staticmethod async def delete ( conn : asyncpg . Connection , user_id : int , item_id : str ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM UserEquipment WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id ) @staticmethod async def delete_entries ( conn : asyncpg . Connection , equipments : list [ Equipment ]): async with conn . transaction (): for equipment in equipments : await Equipment . delete ( conn , equipment . user_id , equipment . item_id ) @staticmethod async def update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Equipment . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE UserEquipment SET { column } = ($3) WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id , new_value ) @staticmethod async def update_durability ( conn : asyncpg . Connection , user_id : int , item_id : str , new_durability : int ) -> int : '''Update an equipment's durability and remove if needed.''' if new_durability <= 0 : return await Equipment . delete ( conn , user_id , item_id ) return await Equipment . update_column ( conn , user_id , item_id , \"remain_durability\" , new_durability ) @staticmethod def is_equipment ( item_id : str ) -> bool : '''Check if the item is an equipment or not. Parameters ---------- item_id : str The item's id to check. Returns ------- bool Whether the item is an equipment or not. ''' for eq_type in Equipment . __EQUIPMENT_TYPE__ : if eq_type in item_id : return True return False @staticmethod def is_true_equipment ( item_id : str ) -> bool : return Equipment . is_equipment ( item_id ) and not Equipment . is_potion ( item_id ) @staticmethod def is_potion ( item_id : str ) -> bool : return \"_potion\" in item_id @staticmethod def get_equipment_type ( item_id : str ) -> t . Optional [ str ]: '''Return the equipment type of the equipment. Parameters ---------- item_id : str The item's id. Returns ------- t.Optional[str] The equipment type of the equipment, or `None` if it is not an equipment. ''' if not Equipment . is_equipment ( item_id ): return None return '_' + item_id . split ( '_' )[ - 1 ] get_all async staticmethod get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]] Get all entries in the table. Source code in utils/psql.py 977 978 979 980 981 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: '''Get all entries in the table.''' return await Equipment . get_all_where ( conn , as_dict = as_dict ) get_all_where async staticmethod get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Equipment ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]] Get all entires in the table that matches the condition. Source code in utils/psql.py 982 983 984 985 986 987 988 989 990 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Equipment ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM UserEquipment; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Equipment if not as_dict else dict ) get_one async staticmethod get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ] Get the first entry in the table that matches the pkey provided. Source code in utils/psql.py 991 992 993 994 995 996 997 998 999 1000 @staticmethod async def get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM UserEquipment WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , item_id , result_type = Equipment if not as_dict else dict ) get_equipment async staticmethod get_equipment ( conn : asyncpg . Connection , user_id : int , equipment_type : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ] Get a user's equipment based on equipment type. Source code in utils/psql.py 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 @staticmethod async def get_equipment ( conn : asyncpg . Connection , user_id : int , equipment_type : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ]: '''Get a user's equipment based on equipment type.''' query = \"\"\" SELECT * FROM UserEquipment WHERE user_id = ($1) AND eq_type = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , equipment_type , result_type = Equipment if not as_dict else dict ) insert_one async staticmethod insert_one ( conn : asyncpg . Connection , equipment : Equipment ) -> int Insert an entry into the table. Source code in utils/psql.py 1017 1018 1019 1020 1021 1022 @staticmethod async def insert_one ( conn : asyncpg . Connection , equipment : Equipment ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"UserEquipment\" , len ( equipment . __slots__ )) return await run_and_return_count ( conn , query , equipment . user_id , equipment . item_id , equipment . eq_type , equipment . remain_durability ) transfer_from_inventory async staticmethod transfer_from_inventory ( conn : asyncpg . Connection , inventory : Inventory ) -> int Transfer an equipment from the inventory. Warnings This does not check whether the user already has that equipment. This must be checked by the user, otherwise an asyncpg.UniqueViolationError might be raised. Notes This function already has its own transaction. There is no need to wrap a transaction for this function. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required inventory Inventory The inventory wrapping the equipment. required Returns: Type Description int The number of entries affected. Should be 1 or 0. Raises: Type Description asyncpg . UniqueViolationError The unique constraint on (user_id, eq_type) is violated. Source code in utils/psql.py 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 @staticmethod async def transfer_from_inventory ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Transfer an equipment from the inventory. Warnings -------- This does not check whether the user already has that equipment. This must be checked by the user, otherwise an `asyncpg.UniqueViolationError` might be raised. Notes ----- This function already has its own transaction. There is no need to wrap a transaction for this function. Parameters ---------- conn : asyncpg.Connection The connection to use. inventory : Inventory The inventory wrapping the equipment. Returns ------- int The number of entries affected. Should be 1 or 0. Raises ------ asyncpg.UniqueViolationError The unique constraint on `(user_id, eq_type)` is violated. ''' is_equipment = False for eq_type in Equipment . __EQUIPMENT_TYPE__ : if eq_type in inventory . item_id : is_equipment = True item = await Item . get_one ( conn , inventory . item_id ) equipment = Equipment ( inventory . user_id , inventory . item_id , eq_type , item . durability ) break if not is_equipment : return 0 async with conn . transaction (): status = await Inventory . remove ( conn , inventory . user_id , inventory . item_id ) if status == 0 : return 0 # TODO: Add a check to see if the same equipment type is already there. return await Equipment . insert_one ( conn , equipment ) delete async staticmethod delete ( conn : asyncpg . Connection , user_id : int , item_id : str ) -> int Delete an entry in the table based on the provided key. Source code in utils/psql.py 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 @staticmethod async def delete ( conn : asyncpg . Connection , user_id : int , item_id : str ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM UserEquipment WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id ) update_column async staticmethod update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int Update a specific column with a new value. Warnings Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes Always prefer using other functions to update rather than this function if possible. Source code in utils/psql.py 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 @staticmethod async def update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Equipment . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE UserEquipment SET { column } = ($3) WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id , new_value ) update_durability async staticmethod update_durability ( conn : asyncpg . Connection , user_id : int , item_id : str , new_durability : int ) -> int Update an equipment's durability and remove if needed. Source code in utils/psql.py 1110 1111 1112 1113 1114 1115 1116 @staticmethod async def update_durability ( conn : asyncpg . Connection , user_id : int , item_id : str , new_durability : int ) -> int : '''Update an equipment's durability and remove if needed.''' if new_durability <= 0 : return await Equipment . delete ( conn , user_id , item_id ) return await Equipment . update_column ( conn , user_id , item_id , \"remain_durability\" , new_durability ) is_equipment staticmethod is_equipment ( item_id : str ) -> bool Check if the item is an equipment or not. Parameters: Name Type Description Default item_id str The item's id to check. required Returns: Type Description bool Whether the item is an equipment or not. Source code in utils/psql.py 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 @staticmethod def is_equipment ( item_id : str ) -> bool : '''Check if the item is an equipment or not. Parameters ---------- item_id : str The item's id to check. Returns ------- bool Whether the item is an equipment or not. ''' for eq_type in Equipment . __EQUIPMENT_TYPE__ : if eq_type in item_id : return True return False get_equipment_type staticmethod get_equipment_type ( item_id : str ) -> t . Optional [ str ] Return the equipment type of the equipment. Parameters: Name Type Description Default item_id str The item's id. required Returns: Type Description t . Optional [ str ] The equipment type of the equipment, or None if it is not an equipment. Source code in utils/psql.py 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 @staticmethod def get_equipment_type ( item_id : str ) -> t . Optional [ str ]: '''Return the equipment type of the equipment. Parameters ---------- item_id : str The item's id. Returns ------- t.Optional[str] The equipment type of the equipment, or `None` if it is not an equipment. ''' if not Equipment . is_equipment ( item_id ): return None return '_' + item_id . split ( '_' )[ - 1 ] Badge dataclass Source code in utils/psql.py 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 @dataclasses . dataclass ( slots = True ) class Badge : id : str sort_id : int name : str emoji : str description : str requirement : int = 0 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ): return await Badge . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Badge ], bool ] = lambda r : True , as_dict : bool = False ): query = \"\"\" SELECT * FROM Badges ORDER BY sort_id; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Badge if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : str , * , as_dict : bool = False ): query = \"\"\" SELECT * FROM Badges WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Badge if not as_dict else dict ) @staticmethod async def get_by_name ( conn : asyncpg . Connection , name : str , * , as_dict : bool = False ): query = \"\"\" SELECT * FROM Badges WHERE name LIKE ($1); \"\"\" return await __get_one__ ( conn , query , name , result_type = Badge if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , badge : Badge ): query = insert_into_query ( \"Badges\" , len ( Badge . __slots__ )) return await run_and_return_count ( conn , query , badge . id , badge . sort_id , badge . name , badge . emoji , badge . description , badge . requirement ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : str , column : str , new_value ): query = f \"\"\" UPDATE Badges SET { column } = ($2) WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id , new_value ) @staticmethod async def update ( conn : asyncpg . Connection , badge : Badge ): '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_badge = await Badge . get_one ( conn , badge . id ) if existing_badge is None : await Badge . insert_one ( conn , badge ) logger . info ( \"Loaded new badge ' %s ' into the database.\" , badge . id ) else : diff_col = [] for col in existing_badge . __slots__ : if getattr ( existing_badge , col ) != getattr ( badge , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Badge . update_column ( conn , badge . id , change , getattr ( badge , change )) if diff_col : logger . info ( \"Updated item ' %s ' in the following columns: %s .\" , badge . id , diff_col ) update async staticmethod update ( conn : asyncpg . Connection , badge : Badge ) Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead. Notes This function has its own transaction. Source code in utils/psql.py 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 @staticmethod async def update ( conn : asyncpg . Connection , badge : Badge ): '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_badge = await Badge . get_one ( conn , badge . id ) if existing_badge is None : await Badge . insert_one ( conn , badge ) logger . info ( \"Loaded new badge ' %s ' into the database.\" , badge . id ) else : diff_col = [] for col in existing_badge . __slots__ : if getattr ( existing_badge , col ) != getattr ( badge , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Badge . update_column ( conn , badge . id , change , getattr ( badge , change )) if diff_col : logger . info ( \"Updated item ' %s ' in the following columns: %s .\" , badge . id , diff_col ) UserBadge dataclass Represent an entry in the UserEquipment table along with possible operations related to the table. Note that badge_requirement is a read-only attribute; it doesn't matter if you try to update it, it'll be ignored because it doesn't belong to this table. Source code in utils/psql.py 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 @dataclasses . dataclass ( slots = True ) class UserBadge : '''Represent an entry in the `UserEquipment` table along with possible operations related to the table. Note that `badge_requirement` is a read-only attribute; it doesn't matter if you try to update it, it'll be ignored because it doesn't belong to this table. ''' user_id : int badge_id : str badge_progress : int = 0 badge_requirement : int = 0 __PREVENT_UPDATE = ( \"user_id\" , \"badge_id\" , \"badge_requirement\" ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ UserBadge ], bool ] = lambda r : True , as_dict : bool = False ): query = \"\"\" SELECT Users_Badges.*, Badges.requirement AS badge_requirement FROM Users_Badges INNER JOIN Badges ON Users_Badges.badge_id = Badges.id; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = UserBadge if not as_dict else dict ) @staticmethod async def get_user_badges ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ): query = f \"\"\" SELECT Users_Badges.*, Badges.requirement AS badge_requirement FROM Users_Badges INNER JOIN Badges ON Users_Badges.badge_id = Badges.id WHERE user_id = { user_id } ; \"\"\" return await __get_all__ ( conn , query , result_type = UserBadge if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , user_id : int , badge_id : str , * , as_dict : bool = False ): query = \"\"\" SELECT Users_Badges.*, Badges.requirement AS badge_requirement FROM Users_Badges INNER JOIN Badges ON Users_Badges.badge_id = Badges.id WHERE user_id = ($1) AND badge_id = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , badge_id , result_type = UserBadge if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , ubadge : UserBadge ): query = insert_into_query ( \"Users_Badges\" , len ( UserBadge . __slots__ ) - 1 ) return await run_and_return_count ( conn , query , ubadge . user_id , ubadge . badge_id , ubadge . badge_progress ) @staticmethod async def add ( conn : asyncpg . Connection , ubadge : UserBadge ): query = \"\"\" INSERT INTO Users_Badges VALUES ($1, $2, $3) ON CONFLICT DO NOTHING; \"\"\" return await run_and_return_count ( conn , query , ubadge . user_id , ubadge . badge_id , ubadge . badge_progress ) @staticmethod async def update_column ( conn : asyncpg . Connection , user_id : int , badge_id : str , column : str , new_value ): if column in UserBadge . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Users_Badges SET { column } = ($3) WHERE user_id = ($1) AND badge_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , badge_id , new_value ) @staticmethod async def update ( conn : asyncpg . Connection , ubadge : UserBadge ): '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_badge = await UserBadge . get_one ( conn , ubadge . user_id , ubadge . badge_id ) if existing_badge is None : await UserBadge . insert_one ( conn , ubadge ) else : diff_col = [] for col in existing_badge . __slots__ : if getattr ( existing_badge , col ) != getattr ( ubadge , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await UserBadge . update_column ( conn , ubadge . user_id , ubadge . badge_id , change , getattr ( ubadge , change )) @staticmethod async def add_progress ( conn : asyncpg . Connection , user_id : int , badge_id : str , progress : int = 1 ): existing_badge = await UserBadge . get_one ( conn , user_id , badge_id ) if not existing_badge : return await UserBadge . insert_one ( conn , UserBadge ( user_id , badge_id , progress )) existing_badge . badge_progress += progress return await UserBadge . update_column ( conn , user_id , badge_id , \"badge_progress\" , existing_badge . badge_progress ) def completed ( self ): return self . badge_progress >= self . badge_requirement update async staticmethod update ( conn : asyncpg . Connection , ubadge : UserBadge ) Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead. Notes This function has its own transaction. Source code in utils/psql.py 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 @staticmethod async def update ( conn : asyncpg . Connection , ubadge : UserBadge ): '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_badge = await UserBadge . get_one ( conn , ubadge . user_id , ubadge . badge_id ) if existing_badge is None : await UserBadge . insert_one ( conn , ubadge ) else : diff_col = [] for col in existing_badge . __slots__ : if getattr ( existing_badge , col ) != getattr ( ubadge , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await UserBadge . update_column ( conn , ubadge . user_id , ubadge . badge_id , change , getattr ( ubadge , change )) record_to_type record_to_type ( record : asyncpg . Record , / , result_type : t . Type [ T ] = dict ) -> T Convert a asyncpg.Record into a dict or None if the object is already None . This is for convenience purpose, where dict(Record) will return {} which is not an accurate representation of empty. obj is None or obj is not None is more obvious to anyone than bool(obj) or not bool(obj) . Parameters: Name Type Description Default record asyncpg . Record The record to convert. required result_type t . Type The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a dict . Default to dict . dict Return t.Optional[T] Either None or result_type . Source code in utils/psql.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def record_to_type ( record : asyncpg . Record , / , result_type : t . Type [ T ] = dict ) -> T : '''Convert a `asyncpg.Record` into a `dict` or `None` if the object is already `None`. This is for convenience purpose, where `dict(Record)` will return `{}` which is not an accurate representation of empty. `obj is None` or `obj is not None` is more obvious to anyone than `bool(obj)` or `not bool(obj)`. Parameters ---------- record : asyncpg.Record The record to convert. result_type : t.Type The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a `dict`. Default to `dict`. Return ------ t.Optional[T] Either `None` or `result_type`. ''' if record is None : return None d = dict ( record ) if result_type is dict : return d return result_type ( ** d ) legacy_insert_into async legacy_insert_into ( conn , table_name : str , * args ) Insert values into table_name . Warning: This function is an old function from pre-rewrite. It is advised to do the logic by yourself. Source code in utils/psql.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 async def legacy_insert_into ( conn , table_name : str , * args ): ''' Insert values into `table_name`. Warning: This function is an old function from pre-rewrite. It is advised to do the logic by yourself. ''' arg_str = \"(\" # max(*args, key = len): Get the longest tuple in the list. for j in range ( len ( max ( * args , key = len ))): arg_str += f \"$ { j + 1 } , \" arg_str = arg_str [: - 2 ] + ')' await conn . executemany ( f ''' INSERT INTO { table_name } VALUES { arg_str } ''' , * args ) insert_into_query insert_into_query ( table_name : str , len_col : int ) -> str Return the query to insert into a table that has len_col columns. Parameters: Name Type Description Default table_name str The table to insert. required len_col int How many column does the table have. required Returns: Type Description str An INSERT SQL statement with query formatter ready to use in .execute() Source code in utils/psql.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def insert_into_query ( table_name : str , len_col : int ) -> str : '''Return the query to insert into a table that has `len_col` columns. Parameters ---------- table_name : str The table to insert. len_col : int How many column does the table have. Returns ------- str An INSERT SQL statement with query formatter ready to use in `.execute()` ''' arg_str = \"(\" for index in range ( len_col ): arg_str += f \"$ { index + 1 } , \" arg_str = arg_str [: - 2 ] + ')' return f \"INSERT INTO { table_name } VALUES { arg_str } ;\" __get_all__ async __get_all__ ( conn : asyncpg . Connection , query : str , * , where : t . Callable [[ T ], bool ] = lambda r : True , result_type : t . Type [ T ] = dict ) -> list [ T ] Run a SELECT statement and return a list of objects. This should NOT be used outside of the module. Instead, use table_name.get_all() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required query str The SELECT statement to run. This should not contain WHERE clause. Conditions should be set in where parameter. required where t . Callable [[ dict ], bool ] Additional conditions to filter. By default, no condition is applied (always return True ). lambda r: True result_type t . Type [ T ] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a dict . Default to dict . dict Returns: Type Description list [ T ] A list of result_type or empty list. Source code in utils/psql.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 async def __get_all__ ( conn : asyncpg . Connection , query : str , * , where : t . Callable [[ T ], bool ] = lambda r : True , result_type : t . Type [ T ] = dict ) -> list [ T ]: '''Run a `SELECT` statement and return a list of objects. This should NOT be used outside of the module. Instead, use `table_name.get_all()`. Parameters ---------- conn : asyncpg.Connection The connection to use. query : str The `SELECT` statement to run. This should not contain `WHERE` clause. Conditions should be set in `where` parameter. where : t.Callable[[dict], bool] Additional conditions to filter. By default, no condition is applied (always return `True`). result_type : t.Type[T] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a `dict`. Default to `dict`. Returns ------- list[T] A list of `result_type` or empty list. ''' result = await conn . fetch ( query ) l = [] record_obj = None for record in result : # NOTE: This code is for handling dict case; will remove soon. #record_obj = record_to_type(record) #if record_obj is None or (record_obj is not None and where(record_obj)): # l.append(record_obj) record_obj = record_to_type ( record , result_type ) if record_obj is None or ( record_obj is not None and where ( record_obj )): l . append ( record_obj ) return l __get_one__ async __get_one__ ( conn : asyncpg . Connection , query : str , * constraints , result_type : t . Type [ T ] = dict ) -> t . Optional [ T ] Run a SELECT statement and return the first object that matches the constraints. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required query str The SELECT statement to run. This should contain a WHERE clause. required *constraints str Arguments to be formatted into the query. () result_type t . Type [ T ] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a dict . Default to dict . dict Returns: Type Description t . Optional [ T ] A result_type or None if no object is found. Source code in utils/psql.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 async def __get_one__ ( conn : asyncpg . Connection , query : str , * constraints , result_type : t . Type [ T ] = dict ) -> t . Optional [ T ]: '''Run a `SELECT` statement and return the first object that matches the constraints. Parameters ---------- conn : asyncpg.Connection The connection to use. query : str The `SELECT` statement to run. This should contain a `WHERE` clause. *constraints : str Arguments to be formatted into the query. result_type : t.Type[T] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a `dict`. Default to `dict`. Returns ------- t.Optional[T] A `result_type` or `None` if no object is found. ''' record = await conn . fetchrow ( query , * constraints ) return record_to_type ( record , result_type ) run_and_return_count async run_and_return_count ( conn : asyncpg . Connection , query : str , * args , ** kwargs ) -> t . Optional [ int ] Execute an SQL operation and return the number of entries affected. Warnings This is meant to run INSERT, DELETE, and UPDATE statements. Other statement might or might not work. Parameters: Name Type Description Default conn asyncpg . Connection The connection to execute. required *args tuple The arguments to pass into conn.execute() () **kwargs The arguments to pass into conn.execute() {} Returns: Type Description t . Optional [ int ] The number of rows affected. If the operation doesn't return the row count, None is returned. Source code in utils/psql.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 async def run_and_return_count ( conn : asyncpg . Connection , query : str , * args , ** kwargs ) -> t . Optional [ int ]: '''Execute an SQL operation and return the number of entries affected. Warnings -------- This is meant to run INSERT, DELETE, and UPDATE statements. Other statement might or might not work. Parameters ---------- conn : asyncpg.Connection The connection to execute. *args : tuple The arguments to pass into `conn.execute()` **kwargs: dict The arguments to pass into `conn.execute()` Returns ------- t.Optional[int] The number of rows affected. If the operation doesn't return the row count, `None` is returned. ''' status = await conn . execute ( query , * args , ** kwargs ) # INSERT returns \"INSERT oid count\". try : count = int ( status . split ()[ - 1 ]) return count except ValueError : return None","title":"psql.py"},{"location":"dev/psql/#utils.psql--classes","text":"This module has a dataclass for every table currently exist in dbsetup.py . These are used to nicely store a row of data in designated table. However, they don't have any member functions. All SQL functions are static. If you don't use any SQL functions due to performance, you can use these classes to organize your data a bit better than naked dictionary.","title":"Classes"},{"location":"dev/psql/#utils.psql--sql-functions","text":"The SQL functions are meant to make the bot's code looks nice without SQL strings everywhere. They also can be slightly customized to deal with common operations. Therefore, these functions will contain overheads. If performance is your main concern, do not use any of these static functions. Generally, all these functions are self-contained, meaning if something screw up, they'll rollback on their own. However, using multiple functions at a time in the bot's code can be dangerous without wrapping them around a transaction. Each class has a __PREVENT_UPDATE tuple that will contains columns that can't be updated via SQL functions for safety. These are usually primary keys or read-only attributes (attributes that doesn't exist on the table, but only for the sake of convenience, like from JOIN table).","title":"SQL Functions"},{"location":"dev/psql/#utils.psql--other-functions","text":"Some public functions can be convenient to use if you decide to not use the SQL functions and instead deal with SQL on your own.","title":"Other Functions"},{"location":"dev/psql/#utils.psql--example","text":"Without transaction: # This is just an example. In reality, you should use `models.UserCache` instead of directly working on `psql.User`. async with pool.acquire() as conn: user: psql.User | None = await psql.User.get_one(conn, user_id) assert user is not None user.is_whitelist = ... user.balance = ... await psql.User.update(conn, user) With transaction: async with pool.acquire() as conn: users: list[psql.User] | None = await psql.User.get_all(conn) async with conn.transaction(): for user in users: user.is_whitelist = ... user.balance = ... await psql.User.update(conn, user)","title":"Example"},{"location":"dev/psql/#utils.psql.Error","text":"Bases: Exception A base error for high-level PostgreSQL operations. Source code in utils/psql.py 68 69 class Error ( Exception ): '''A base error for high-level PostgreSQL operations.'''","title":"Error"},{"location":"dev/psql/#utils.psql.GetError","text":"Bases: Error A base error for SELECT operations.","title":"GetError"},{"location":"dev/psql/#utils.psql.GetError--notes","text":"This should only be raised when get_x() is implicitly called. This will NOT be raised if the user explicitly calls get_x() . Source code in utils/psql.py 71 72 73 74 75 76 77 78 class GetError ( Error ): '''A base error for SELECT operations. Notes ----- This should only be raised when `get_x()` is implicitly called. This will NOT be raised if the user explicitly calls `get_x()`. '''","title":"Notes"},{"location":"dev/psql/#utils.psql.InsertError","text":"Bases: Error A base error for INSERT operations. Source code in utils/psql.py 80 81 class InsertError ( Error ): '''A base error for INSERT operations.'''","title":"InsertError"},{"location":"dev/psql/#utils.psql.DeleteError","text":"Bases: Error A base error for DELETE operations. Source code in utils/psql.py 83 84 class DeleteError ( Error ): '''A base error for DELETE operations.'''","title":"DeleteError"},{"location":"dev/psql/#utils.psql.UpdateError","text":"Bases: Error A base error for UPDATE operations. Source code in utils/psql.py 86 87 class UpdateError ( Error ): '''A base error for UPDATE operations.'''","title":"UpdateError"},{"location":"dev/psql/#utils.psql.DuplicateArrayElement","text":"Bases: UpdateError Raised when trying to add an element that's already available in a unique-only list (set). Source code in utils/psql.py 89 90 class DuplicateArrayElement ( UpdateError ): '''Raised when trying to add an element that's already available in a unique-only list (set).'''","title":"DuplicateArrayElement"},{"location":"dev/psql/#utils.psql.Guild","text":"Represent an entry in the Guilds table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. Source code in utils/psql.py 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 @dataclasses . dataclass ( slots = True ) class Guild : '''Represent an entry in the `Guilds` table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. ''' id : int name : str is_whitelist : bool = True prefix : str = '$' __PREVENT_UPDATE = ( \"id\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entries in the table.''' return await Guild . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Guilds ORDER BY Guilds.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Guild if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ Guild , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM Guilds WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Guild if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , guild : Guild ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"Guilds\" , len ( guild . __slots__ )) return await run_and_return_count ( conn , query , guild . id , guild . name , guild . is_whitelist , guild . prefix ) @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Guilds WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Guild . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Guilds SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) @staticmethod async def update ( conn : asyncpg . Connection , guild : Guild ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_guild = await Guild . get_one ( conn , guild . id ) if not existed_guild : return await Guild . insert_one ( conn , guild ) diff_col = [] for col in existed_guild . __slots__ : if getattr ( existed_guild , col ) != getattr ( guild , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Guild . update_column ( conn , guild . id , change , getattr ( guild , change ))","title":"Guild"},{"location":"dev/psql/#utils.psql.Guild.get_all","text":"get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]] Get all entries in the table. Source code in utils/psql.py 265 266 267 268 269 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entries in the table.''' return await Guild . get_all_where ( conn , as_dict = as_dict )","title":"get_all()"},{"location":"dev/psql/#utils.psql.Guild.get_all_where","text":"get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]] Get all entires in the table that matches the condition. Source code in utils/psql.py 270 271 272 273 274 275 276 277 278 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Guilds ORDER BY Guilds.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Guild if not as_dict else dict )","title":"get_all_where()"},{"location":"dev/psql/#utils.psql.Guild.get_one","text":"get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ Guild , dict ] Get the first entry in the table that matches the pkey provided. Source code in utils/psql.py 279 280 281 282 283 284 285 286 287 @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ Guild , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM Guilds WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Guild if not as_dict else dict )","title":"get_one()"},{"location":"dev/psql/#utils.psql.Guild.insert_one","text":"insert_one ( conn : asyncpg . Connection , guild : Guild ) -> int Insert an entry into the table. Source code in utils/psql.py 288 289 290 291 292 293 @staticmethod async def insert_one ( conn : asyncpg . Connection , guild : Guild ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"Guilds\" , len ( guild . __slots__ )) return await run_and_return_count ( conn , query , guild . id , guild . name , guild . is_whitelist , guild . prefix )","title":"insert_one()"},{"location":"dev/psql/#utils.psql.Guild.delete","text":"delete ( conn : asyncpg . Connection , id : int ) -> int Delete an entry in the table based on the provided key. Source code in utils/psql.py 294 295 296 297 298 299 300 301 302 @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Guilds WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id )","title":"delete()"},{"location":"dev/psql/#utils.psql.Guild.update_column","text":"update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int Update a specific column with a new value.","title":"update_column()"},{"location":"dev/psql/#utils.psql.Guild.update_column--warnings","text":"Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL.","title":"Warnings"},{"location":"dev/psql/#utils.psql.Guild.update_column--notes","text":"Always prefer using other functions to update rather than this function if possible. Source code in utils/psql.py 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Guild . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Guilds SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id )","title":"Notes"},{"location":"dev/psql/#utils.psql.Guild.update","text":"update ( conn : asyncpg . Connection , guild : Guild ) -> int Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead.","title":"update()"},{"location":"dev/psql/#utils.psql.Guild.update--notes","text":"This function has its own transaction. Source code in utils/psql.py 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 @staticmethod async def update ( conn : asyncpg . Connection , guild : Guild ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_guild = await Guild . get_one ( conn , guild . id ) if not existed_guild : return await Guild . insert_one ( conn , guild ) diff_col = [] for col in existed_guild . __slots__ : if getattr ( existed_guild , col ) != getattr ( guild , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Guild . update_column ( conn , guild . id , change , getattr ( guild , change ))","title":"Notes"},{"location":"dev/psql/#utils.psql.GuildLog","text":"Represent an entry in the GuildsLogs table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. Source code in utils/psql.py 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 @dataclasses . dataclass ( slots = True ) class GuildLog : '''Represent an entry in the `GuildsLogs` table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. ''' guild_id : int log_channel : int = None guild_channel_create : bool = True guild_channel_delete : bool = True guild_channel_update : bool = True guild_ban : bool = True guild_unban : bool = True guild_update : bool = True member_join : bool = True member_leave : bool = True member_update : bool = True guild_bulk_message_delete : bool = True guild_message_delete : bool = True guild_message_update : bool = True role_create : bool = True role_delete : bool = True role_update : bool = True command_complete : bool = True command_error : bool = True __PREVENT_UPDATE = ( \"guild_id\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]]: '''Get all entries in the table.''' return await GuildLog . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM GuildsLogs; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = GuildLog if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ GuildLog , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = GuildLog if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , guild_id : int ) -> int : '''Insert an entry into the table.''' # Only guild_id is required. query = insert_into_query ( \"GuildsLogs\" , 1 ) return await run_and_return_count ( conn , query , guild_id ) @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in GuildLog . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE GuildsLogs SET { column } = ($1) WHERE guild_id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) @staticmethod async def update ( conn : asyncpg . Connection , guild : GuildLog ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_guild = await GuildLog . get_one ( conn , guild . guild_id ) if not existed_guild : return await GuildLog . insert_one ( conn , guild . guild_id ) diff_col = [] for col in existed_guild . __slots__ : if getattr ( existed_guild , col ) != getattr ( guild , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await GuildLog . update_column ( conn , guild . guild_id , change , getattr ( guild , change ))","title":"GuildLog"},{"location":"dev/psql/#utils.psql.GuildLog.get_all","text":"get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]] Get all entries in the table. Source code in utils/psql.py 378 379 380 381 382 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]]: '''Get all entries in the table.''' return await GuildLog . get_all_where ( conn , as_dict = as_dict )","title":"get_all()"},{"location":"dev/psql/#utils.psql.GuildLog.get_all_where","text":"get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]] Get all entires in the table that matches the condition. Source code in utils/psql.py 383 384 385 386 387 388 389 390 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM GuildsLogs; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = GuildLog if not as_dict else dict )","title":"get_all_where()"},{"location":"dev/psql/#utils.psql.GuildLog.get_one","text":"get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ GuildLog , dict ] Get the first entry in the table that matches the pkey provided. Source code in utils/psql.py 391 392 393 394 395 396 397 398 399 @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ GuildLog , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = GuildLog if not as_dict else dict )","title":"get_one()"},{"location":"dev/psql/#utils.psql.GuildLog.insert_one","text":"insert_one ( conn : asyncpg . Connection , guild_id : int ) -> int Insert an entry into the table. Source code in utils/psql.py 400 401 402 403 404 405 406 @staticmethod async def insert_one ( conn : asyncpg . Connection , guild_id : int ) -> int : '''Insert an entry into the table.''' # Only guild_id is required. query = insert_into_query ( \"GuildsLogs\" , 1 ) return await run_and_return_count ( conn , query , guild_id )","title":"insert_one()"},{"location":"dev/psql/#utils.psql.GuildLog.delete","text":"delete ( conn : asyncpg . Connection , id : int ) -> int Delete an entry in the table based on the provided key. Source code in utils/psql.py 407 408 409 410 411 412 413 414 415 @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await run_and_return_count ( conn , query , id )","title":"delete()"},{"location":"dev/psql/#utils.psql.GuildLog.update_column","text":"update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int Update a specific column with a new value.","title":"update_column()"},{"location":"dev/psql/#utils.psql.GuildLog.update_column--warnings","text":"Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL.","title":"Warnings"},{"location":"dev/psql/#utils.psql.GuildLog.update_column--notes","text":"Always prefer using other functions to update rather than this function if possible. Source code in utils/psql.py 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in GuildLog . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE GuildsLogs SET { column } = ($1) WHERE guild_id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id )","title":"Notes"},{"location":"dev/psql/#utils.psql.GuildLog.update","text":"update ( conn : asyncpg . Connection , guild : GuildLog ) -> int Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead.","title":"update()"},{"location":"dev/psql/#utils.psql.GuildLog.update--notes","text":"This function has its own transaction. Source code in utils/psql.py 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 @staticmethod async def update ( conn : asyncpg . Connection , guild : GuildLog ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_guild = await GuildLog . get_one ( conn , guild . guild_id ) if not existed_guild : return await GuildLog . insert_one ( conn , guild . guild_id ) diff_col = [] for col in existed_guild . __slots__ : if getattr ( existed_guild , col ) != getattr ( guild , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await GuildLog . update_column ( conn , guild . guild_id , change , getattr ( guild , change ))","title":"Notes"},{"location":"dev/psql/#utils.psql.User","text":"Represent an entry in the Users table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. Source code in utils/psql.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 @dataclasses . dataclass ( slots = True ) class User : '''Represent an entry in the `Users` table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. ''' id : int name : str is_whitelist : bool = True balance : int = 0 world : str = \"overworld\" last_travel : t . Optional [ dt . datetime ] = None daily_streak : int = 0 last_daily : t . Optional [ dt . datetime ] = None health : int = 100 __WORLD_TYPE = ( \"overworld\" , \"nether\" , \"end\" ) __PREVENT_UPDATE = ( \"id\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ User ]: '''Get all entries in the table.''' return await User . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ User , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Users ORDER BY Users.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = User if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , as_dict : bool = False ) -> t . Union [ User , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM Users WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = User if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , user : User ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"Users\" , len ( user . __slots__ )) return await run_and_return_count ( conn , query , user . id , user . name , user . is_whitelist , user . balance , user . world , user . last_travel , user . daily_streak , user . last_daily , user . health ) @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Users WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in User . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Users SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) @staticmethod async def update_balance ( conn : asyncpg . Connection , id : int , new_balance : int ) -> int : if new_balance < 0 : # Might raise a warning here? return 0 return await User . update_column ( conn , id , \"balance\" , new_balance ) @staticmethod async def update_streak ( conn : asyncpg . Connection , id : int , new_streak : int ) -> int : if new_streak < 0 : # Might raise a warning here? return 0 return await User . update_column ( conn , id , \"daily_streak\" , new_streak ) @staticmethod async def add_money ( conn : asyncpg . Connection , id : int , amount : int ) -> int : if amount <= 0 : return 0 existed = await User . get_one ( conn , id ) if not existed : raise UpdateError ( f \"Trying to update entry ' { id } ', but it is not found.\" ) return await User . update_balance ( conn , id , existed . balance + amount ) @staticmethod async def remove_money ( conn : asyncpg . Connection , id : int , amount : int ) -> int : if amount <= 0 : return 0 existed = await User . get_one ( conn , id ) if not existed : raise UpdateError ( f \"Trying to update entry ' { id } ', but it is not found.\" ) if existed . balance <= amount : # Might raise a warning here? Idk. existed . balance = 0 else : existed . balance -= amount return await User . update_balance ( conn , id , existed . balance ) @staticmethod async def update ( conn : asyncpg . Connection , user : User ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_user = await User . get_one ( conn , user . id ) if not existed_user : return await User . insert_one ( conn , user ) diff_col = [] for col in existed_user . __slots__ : if getattr ( existed_user , col ) != getattr ( user , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await User . update_column ( conn , user . id , change , getattr ( user , change ))","title":"User"},{"location":"dev/psql/#utils.psql.User.get_all","text":"get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ User ] Get all entries in the table. Source code in utils/psql.py 482 483 484 485 486 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ User ]: '''Get all entries in the table.''' return await User . get_all_where ( conn , as_dict = as_dict )","title":"get_all()"},{"location":"dev/psql/#utils.psql.User.get_all_where","text":"get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ User , dict ]] Get all entires in the table that matches the condition. Source code in utils/psql.py 487 488 489 490 491 492 493 494 495 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ User , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Users ORDER BY Users.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = User if not as_dict else dict )","title":"get_all_where()"},{"location":"dev/psql/#utils.psql.User.get_one","text":"get_one ( conn : asyncpg . Connection , id : int , as_dict : bool = False ) -> t . Union [ User , dict ] Get the first entry in the table that matches the pkey provided. Source code in utils/psql.py 496 497 498 499 500 501 502 503 504 @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , as_dict : bool = False ) -> t . Union [ User , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM Users WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = User if not as_dict else dict )","title":"get_one()"},{"location":"dev/psql/#utils.psql.User.insert_one","text":"insert_one ( conn : asyncpg . Connection , user : User ) -> int Insert an entry into the table. Source code in utils/psql.py 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 @staticmethod async def insert_one ( conn : asyncpg . Connection , user : User ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"Users\" , len ( user . __slots__ )) return await run_and_return_count ( conn , query , user . id , user . name , user . is_whitelist , user . balance , user . world , user . last_travel , user . daily_streak , user . last_daily , user . health )","title":"insert_one()"},{"location":"dev/psql/#utils.psql.User.delete","text":"delete ( conn : asyncpg . Connection , id : int ) -> int Delete an entry in the table based on the provided key. Source code in utils/psql.py 521 522 523 524 525 526 527 528 529 @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Users WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id )","title":"delete()"},{"location":"dev/psql/#utils.psql.User.update_column","text":"update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int Update a specific column with a new value.","title":"update_column()"},{"location":"dev/psql/#utils.psql.User.update_column--warnings","text":"Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL.","title":"Warnings"},{"location":"dev/psql/#utils.psql.User.update_column--notes","text":"Always prefer using other functions to update rather than this function if possible. Source code in utils/psql.py 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in User . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Users SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id )","title":"Notes"},{"location":"dev/psql/#utils.psql.User.update","text":"update ( conn : asyncpg . Connection , user : User ) -> int Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead.","title":"update()"},{"location":"dev/psql/#utils.psql.User.update--notes","text":"This function has its own transaction. Source code in utils/psql.py 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 @staticmethod async def update ( conn : asyncpg . Connection , user : User ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_user = await User . get_one ( conn , user . id ) if not existed_user : return await User . insert_one ( conn , user ) diff_col = [] for col in existed_user . __slots__ : if getattr ( existed_user , col ) != getattr ( user , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await User . update_column ( conn , user . id , change , getattr ( user , change ))","title":"Notes"},{"location":"dev/psql/#utils.psql.Reminders","text":"Represent an entry in the Reminders table along with possible operations related to the table. Source code in utils/psql.py 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 @dataclasses . dataclass ( slots = True ) class Reminders : '''Represent an entry in the `Reminders` table along with possible operations related to the table.''' remind_id : int user_id : int awake_time : dt . datetime message : str __PREVENT_UPDATE = ( \"remind_id\" , \"user_id\" ) @staticmethod async def get_user_reminders ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders a user have.''' query = \"\"\" SELECT * FROM Reminders WHERE user_id = ($1); \"\"\" result = await conn . fetch ( query , user_id ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] @staticmethod async def get_reminders ( conn : asyncpg . Connection , lower_time : dt . datetime , upper_time : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders within `(lower_time, upper_time]`.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time > ($1) AND awake_time <= ($2); \"\"\" result = await conn . fetch ( query , lower_time , upper_time ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] @staticmethod async def get_past_reminders ( conn : asyncpg . Connection , now : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders that are supposed to be cleared before the time provided.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time < ($1); \"\"\" result = await conn . fetch ( query , now ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] @staticmethod async def insert_reminder ( conn : asyncpg . Connection , user_id : int , when : dt . datetime , message : str ) -> int : '''Insert a reminder entry.''' query = \"\"\" INSERT INTO Reminders (user_id, awake_time, message) VALUES ($1, $2, $3); \"\"\" return await run_and_return_count ( conn , query , user_id , when , message ) @staticmethod async def delete_reminder ( conn : asyncpg . Connection , remind_id : int , user_id : int ) -> int : '''Delete a reminder entry.''' # Although remind_id is sufficient, user_id is to make sure a user can't remove another reminder. query = \"\"\" DELETE FROM Reminders WHERE remind_id = ($1) AND user_id = ($2); \"\"\" return await run_and_return_count ( conn , query , remind_id , user_id )","title":"Reminders"},{"location":"dev/psql/#utils.psql.Reminders.get_user_reminders","text":"get_user_reminders ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]] Get a list of reminders a user have. Source code in utils/psql.py 627 628 629 630 631 632 633 634 635 636 637 @staticmethod async def get_user_reminders ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders a user have.''' query = \"\"\" SELECT * FROM Reminders WHERE user_id = ($1); \"\"\" result = await conn . fetch ( query , user_id ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ]","title":"get_user_reminders()"},{"location":"dev/psql/#utils.psql.Reminders.get_reminders","text":"get_reminders ( conn : asyncpg . Connection , lower_time : dt . datetime , upper_time : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]] Get a list of reminders within (lower_time, upper_time] . Source code in utils/psql.py 638 639 640 641 642 643 644 645 646 647 648 @staticmethod async def get_reminders ( conn : asyncpg . Connection , lower_time : dt . datetime , upper_time : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders within `(lower_time, upper_time]`.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time > ($1) AND awake_time <= ($2); \"\"\" result = await conn . fetch ( query , lower_time , upper_time ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ]","title":"get_reminders()"},{"location":"dev/psql/#utils.psql.Reminders.get_past_reminders","text":"get_past_reminders ( conn : asyncpg . Connection , now : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]] Get a list of reminders that are supposed to be cleared before the time provided. Source code in utils/psql.py 649 650 651 652 653 654 655 656 657 658 659 @staticmethod async def get_past_reminders ( conn : asyncpg . Connection , now : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders that are supposed to be cleared before the time provided.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time < ($1); \"\"\" result = await conn . fetch ( query , now ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ]","title":"get_past_reminders()"},{"location":"dev/psql/#utils.psql.Reminders.insert_reminder","text":"insert_reminder ( conn : asyncpg . Connection , user_id : int , when : dt . datetime , message : str ) -> int Insert a reminder entry. Source code in utils/psql.py 660 661 662 663 664 665 666 667 668 @staticmethod async def insert_reminder ( conn : asyncpg . Connection , user_id : int , when : dt . datetime , message : str ) -> int : '''Insert a reminder entry.''' query = \"\"\" INSERT INTO Reminders (user_id, awake_time, message) VALUES ($1, $2, $3); \"\"\" return await run_and_return_count ( conn , query , user_id , when , message )","title":"insert_reminder()"},{"location":"dev/psql/#utils.psql.Reminders.delete_reminder","text":"delete_reminder ( conn : asyncpg . Connection , remind_id : int , user_id : int ) -> int Delete a reminder entry. Source code in utils/psql.py 669 670 671 672 673 674 675 676 677 678 @staticmethod async def delete_reminder ( conn : asyncpg . Connection , remind_id : int , user_id : int ) -> int : '''Delete a reminder entry.''' # Although remind_id is sufficient, user_id is to make sure a user can't remove another reminder. query = \"\"\" DELETE FROM Reminders WHERE remind_id = ($1) AND user_id = ($2); \"\"\" return await run_and_return_count ( conn , query , remind_id , user_id )","title":"delete_reminder()"},{"location":"dev/psql/#utils.psql.Item","text":"Represent an entry in the Items table along with possible operations related to the table. This is mostly used for the bot's cache purpose. If you're using this directly in a code, you're probably doing it wrong. Source code in utils/psql.py 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 @dataclasses . dataclass ( slots = True ) class Item : '''Represent an entry in the `Items` table along with possible operations related to the table. This is mostly used for the bot's cache purpose. If you're using this directly in a code, you're probably doing it wrong. ''' id : str sort_id : int name : str emoji : str description : str rarity : str sell_price : int buy_price : t . Optional [ int ] = None aliases : list [ str ] = dataclasses . field ( default_factory = list ) durability : int = None __PREVENT_UPDATE = ( \"id\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]]: '''Get all entries in the table.''' return await Item . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Item ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Items ORDER by sort_id; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Item if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ]: '''Get the first entry in the table that matches the condition.''' query = \"\"\" SELECT * FROM Items WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Item if not as_dict else dict ) @staticmethod async def get_by_name ( conn : asyncpg . Connection , name_or_alias : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ]: '''Get the first item that has its name/aliases match the provided.''' def filter_name_alias ( record : Item ): return record . name . lower () == name_or_alias . lower () or name_or_alias . lower () in [ alias . lower () for alias in record . aliases ] res = await Item . get_all_where ( conn , where = filter_name_alias , as_dict = as_dict ) assert len ( res ) <= 1 if res : return res [ 0 ] return None @staticmethod async def insert_one ( conn : asyncpg . Connection , item : Item ): '''Insert an entry into the table.''' query = insert_into_query ( \"Items\" , len ( item . __slots__ )) return await run_and_return_count ( conn , query , item . id , item . sort_id , item . name , item . aliases , item . emoji , item . description , item . rarity , item . buy_price , item . sell_price , item . durability , ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Item . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Items SET { column } = ($2) WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id , new_value ) @staticmethod async def update ( conn : asyncpg . Connection , item : Item ): '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_item = await Item . get_one ( conn , item . id ) if existing_item is None : await Item . insert_one ( conn , item ) logger . info ( \"Loaded new item ' %s ' into the database.\" , item . id ) else : diff_col = [] for col in existing_item . __slots__ : if getattr ( existing_item , col ) != getattr ( item , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Item . update_column ( conn , item . id , change , getattr ( item , change )) if diff_col : logger . info ( \"Updated item ' %s ' in the following columns: %s .\" , item . id , diff_col )","title":"Item"},{"location":"dev/psql/#utils.psql.Item.get_all","text":"get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]] Get all entries in the table. Source code in utils/psql.py 700 701 702 703 704 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]]: '''Get all entries in the table.''' return await Item . get_all_where ( conn , as_dict = as_dict )","title":"get_all()"},{"location":"dev/psql/#utils.psql.Item.get_all_where","text":"get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Item ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]] Get all entires in the table that matches the condition. Source code in utils/psql.py 705 706 707 708 709 710 711 712 713 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Item ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Items ORDER by sort_id; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Item if not as_dict else dict )","title":"get_all_where()"},{"location":"dev/psql/#utils.psql.Item.get_one","text":"get_one ( conn : asyncpg . Connection , id : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ] Get the first entry in the table that matches the condition. Source code in utils/psql.py 714 715 716 717 718 719 720 721 722 @staticmethod async def get_one ( conn : asyncpg . Connection , id : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ]: '''Get the first entry in the table that matches the condition.''' query = \"\"\" SELECT * FROM Items WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Item if not as_dict else dict )","title":"get_one()"},{"location":"dev/psql/#utils.psql.Item.get_by_name","text":"get_by_name ( conn : asyncpg . Connection , name_or_alias : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ] Get the first item that has its name/aliases match the provided. Source code in utils/psql.py 723 724 725 726 727 728 729 730 731 732 733 734 735 @staticmethod async def get_by_name ( conn : asyncpg . Connection , name_or_alias : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ]: '''Get the first item that has its name/aliases match the provided.''' def filter_name_alias ( record : Item ): return record . name . lower () == name_or_alias . lower () or name_or_alias . lower () in [ alias . lower () for alias in record . aliases ] res = await Item . get_all_where ( conn , where = filter_name_alias , as_dict = as_dict ) assert len ( res ) <= 1 if res : return res [ 0 ] return None","title":"get_by_name()"},{"location":"dev/psql/#utils.psql.Item.insert_one","text":"insert_one ( conn : asyncpg . Connection , item : Item ) Insert an entry into the table. Source code in utils/psql.py 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 @staticmethod async def insert_one ( conn : asyncpg . Connection , item : Item ): '''Insert an entry into the table.''' query = insert_into_query ( \"Items\" , len ( item . __slots__ )) return await run_and_return_count ( conn , query , item . id , item . sort_id , item . name , item . aliases , item . emoji , item . description , item . rarity , item . buy_price , item . sell_price , item . durability , )","title":"insert_one()"},{"location":"dev/psql/#utils.psql.Item.update_column","text":"update_column ( conn : asyncpg . Connection , id : str , column : str , new_value ) -> int Update a specific column with a new value.","title":"update_column()"},{"location":"dev/psql/#utils.psql.Item.update_column--warnings","text":"Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL.","title":"Warnings"},{"location":"dev/psql/#utils.psql.Item.update_column--notes","text":"Always prefer using other functions to update rather than this function if possible. Source code in utils/psql.py 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 @staticmethod async def update_column ( conn : asyncpg . Connection , id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Item . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Items SET { column } = ($2) WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id , new_value )","title":"Notes"},{"location":"dev/psql/#utils.psql.Item.update","text":"update ( conn : asyncpg . Connection , item : Item ) Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead.","title":"update()"},{"location":"dev/psql/#utils.psql.Item.update--notes","text":"This function has its own transaction. Source code in utils/psql.py 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 @staticmethod async def update ( conn : asyncpg . Connection , item : Item ): '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_item = await Item . get_one ( conn , item . id ) if existing_item is None : await Item . insert_one ( conn , item ) logger . info ( \"Loaded new item ' %s ' into the database.\" , item . id ) else : diff_col = [] for col in existing_item . __slots__ : if getattr ( existing_item , col ) != getattr ( item , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Item . update_column ( conn , item . id , change , getattr ( item , change )) if diff_col : logger . info ( \"Updated item ' %s ' in the following columns: %s .\" , item . id , diff_col )","title":"Notes"},{"location":"dev/psql/#utils.psql.Inventory","text":"Represent an entry in the UserInventory table along with possible operations related to the table. Source code in utils/psql.py 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 @dataclasses . dataclass ( slots = True ) class Inventory : '''Represent an entry in the `UserInventory` table along with possible operations related to the table.''' user_id : int item_id : str amount : int __PREVENT_UPDATE = ( \"user_id\" , \"item_id\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entries in the table.''' return await Inventory . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Inventory ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM UserInventory ORDER BY amount DESC; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Inventory if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Inventory , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM UserInventory WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , item_id , result_type = Inventory if not as_dict else dict ) @staticmethod async def get_user_inventory ( conn , user_id : int , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entries in the table that belongs to a user.''' return await Inventory . get_all_where ( conn , where = lambda r : r . user_id == user_id , as_dict = as_dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"UserInventory\" , len ( Inventory . __slots__ )) return await run_and_return_count ( conn , query , inventory . user_id , inventory . item_id , inventory . amount ) @staticmethod async def delete ( conn : asyncpg . Connection , user_id : int , item_id : str ) -> int : query = \"\"\" DELETE FROM UserInventory WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id ) @staticmethod async def update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Inventory . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE UserInventory SET { column } = ($3) WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id , new_value ) @staticmethod async def add ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int : '''Add item into the user's inventory. Notes ----- This should be preferred over `Inventory.insert_one()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user_id : int The user's id to insert. item_id : str The item's id to insert. amount : int, optional The amount of items to add. Default to 1. Returns ------- int The number of entries affected. Should be 1 or 0. ''' existed = await Inventory . get_one ( conn , user_id , item_id ) if not existed : return await Inventory . insert_one ( conn , Inventory ( user_id , item_id , amount )) else : return await Inventory . update_column ( conn , user_id , item_id , \"amount\" , existed . amount + amount ) @staticmethod async def remove ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int : '''Remove item from the user's inventory. Notes ----- This should be preferred over `Inventory.delete()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user_id : int The user's id to insert. item_id : str The item's id to insert. amount : int, optional The amount of items to remove. Default to 1. Returns ------- int The number of entries affected. Should be 1 or 0. ''' existed = await Inventory . get_one ( conn , user_id , item_id ) if not existed : return 0 elif existed . amount <= amount : return await Inventory . delete ( conn , user_id , item_id ) else : return await Inventory . update_column ( conn , user_id , item_id , \"amount\" , existed . amount - amount ) @staticmethod async def update ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_inv = await Inventory . get_one ( conn , inventory . user_id , inventory . item_id ) if not existing_inv : return await Inventory . insert_one ( conn , inventory ) if inventory . amount <= 0 : return await Inventory . delete ( conn , inventory . user_id , inventory . item_id ) diff_col = [] for col in existing_inv . __slots__ : if col in ( \"user_id\" , \"item_id\" , \"amount\" ): if getattr ( existing_inv , col ) != getattr ( inventory , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Inventory . update_column ( conn , inventory . user_id , inventory . item_id , change , getattr ( inventory , change ))","title":"Inventory"},{"location":"dev/psql/#utils.psql.Inventory.get_all","text":"get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]] Get all entries in the table. Source code in utils/psql.py 813 814 815 816 817 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entries in the table.''' return await Inventory . get_all_where ( conn , as_dict = as_dict )","title":"get_all()"},{"location":"dev/psql/#utils.psql.Inventory.get_all_where","text":"get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Inventory ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]] Get all entires in the table that matches the condition. Source code in utils/psql.py 818 819 820 821 822 823 824 825 826 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Inventory ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM UserInventory ORDER BY amount DESC; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Inventory if not as_dict else dict )","title":"get_all_where()"},{"location":"dev/psql/#utils.psql.Inventory.get_one","text":"get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Inventory , dict ] Get the first entry in the table that matches the pkey provided. Source code in utils/psql.py 827 828 829 830 831 832 833 834 835 836 @staticmethod async def get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Inventory , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM UserInventory WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , item_id , result_type = Inventory if not as_dict else dict )","title":"get_one()"},{"location":"dev/psql/#utils.psql.Inventory.get_user_inventory","text":"get_user_inventory ( conn , user_id : int , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]] Get all entries in the table that belongs to a user. Source code in utils/psql.py 837 838 839 840 841 @staticmethod async def get_user_inventory ( conn , user_id : int , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entries in the table that belongs to a user.''' return await Inventory . get_all_where ( conn , where = lambda r : r . user_id == user_id , as_dict = as_dict )","title":"get_user_inventory()"},{"location":"dev/psql/#utils.psql.Inventory.insert_one","text":"insert_one ( conn : asyncpg . Connection , inventory : Inventory ) -> int Insert an entry into the table. Source code in utils/psql.py 842 843 844 845 846 847 @staticmethod async def insert_one ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"UserInventory\" , len ( Inventory . __slots__ )) return await run_and_return_count ( conn , query , inventory . user_id , inventory . item_id , inventory . amount )","title":"insert_one()"},{"location":"dev/psql/#utils.psql.Inventory.update_column","text":"update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int Update a specific column with a new value.","title":"update_column()"},{"location":"dev/psql/#utils.psql.Inventory.update_column--warnings","text":"Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL.","title":"Warnings"},{"location":"dev/psql/#utils.psql.Inventory.update_column--notes","text":"Always prefer using other functions to update rather than this function if possible. Source code in utils/psql.py 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 @staticmethod async def update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Inventory . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE UserInventory SET { column } = ($3) WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id , new_value )","title":"Notes"},{"location":"dev/psql/#utils.psql.Inventory.add","text":"add ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int Add item into the user's inventory.","title":"add()"},{"location":"dev/psql/#utils.psql.Inventory.add--notes","text":"This should be preferred over Inventory.insert_one() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required user_id int The user's id to insert. required item_id str The item's id to insert. required amount int , optional The amount of items to add. Default to 1. 1 Returns: Type Description int The number of entries affected. Should be 1 or 0. Source code in utils/psql.py 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 @staticmethod async def add ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int : '''Add item into the user's inventory. Notes ----- This should be preferred over `Inventory.insert_one()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user_id : int The user's id to insert. item_id : str The item's id to insert. amount : int, optional The amount of items to add. Default to 1. Returns ------- int The number of entries affected. Should be 1 or 0. ''' existed = await Inventory . get_one ( conn , user_id , item_id ) if not existed : return await Inventory . insert_one ( conn , Inventory ( user_id , item_id , amount )) else : return await Inventory . update_column ( conn , user_id , item_id , \"amount\" , existed . amount + amount )","title":"Notes"},{"location":"dev/psql/#utils.psql.Inventory.remove","text":"remove ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int Remove item from the user's inventory.","title":"remove()"},{"location":"dev/psql/#utils.psql.Inventory.remove--notes","text":"This should be preferred over Inventory.delete() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required user_id int The user's id to insert. required item_id str The item's id to insert. required amount int , optional The amount of items to remove. Default to 1. 1 Returns: Type Description int The number of entries affected. Should be 1 or 0. Source code in utils/psql.py 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 @staticmethod async def remove ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int : '''Remove item from the user's inventory. Notes ----- This should be preferred over `Inventory.delete()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user_id : int The user's id to insert. item_id : str The item's id to insert. amount : int, optional The amount of items to remove. Default to 1. Returns ------- int The number of entries affected. Should be 1 or 0. ''' existed = await Inventory . get_one ( conn , user_id , item_id ) if not existed : return 0 elif existed . amount <= amount : return await Inventory . delete ( conn , user_id , item_id ) else : return await Inventory . update_column ( conn , user_id , item_id , \"amount\" , existed . amount - amount )","title":"Notes"},{"location":"dev/psql/#utils.psql.Inventory.update","text":"update ( conn : asyncpg . Connection , inventory : Inventory ) -> int Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead.","title":"update()"},{"location":"dev/psql/#utils.psql.Inventory.update--notes","text":"This function has its own transaction. Source code in utils/psql.py 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 @staticmethod async def update ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_inv = await Inventory . get_one ( conn , inventory . user_id , inventory . item_id ) if not existing_inv : return await Inventory . insert_one ( conn , inventory ) if inventory . amount <= 0 : return await Inventory . delete ( conn , inventory . user_id , inventory . item_id ) diff_col = [] for col in existing_inv . __slots__ : if col in ( \"user_id\" , \"item_id\" , \"amount\" ): if getattr ( existing_inv , col ) != getattr ( inventory , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Inventory . update_column ( conn , inventory . user_id , inventory . item_id , change , getattr ( inventory , change ))","title":"Notes"},{"location":"dev/psql/#utils.psql.Equipment","text":"Represent an entry in the UserEquipment table along with possible operations related to the table. Source code in utils/psql.py 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 @dataclasses . dataclass ( slots = True ) class Equipment : '''Represent an entry in the `UserEquipment` table along with possible operations related to the table.''' user_id : int item_id : str eq_type : str remain_durability : int __EQUIPMENT_TYPE__ = ( \"_sword\" , \"_pickaxe\" , \"_axe\" , \"_potion\" ) __PREVENT_UPDATE = ( \"user_id\" , \"item_id\" , \"eq_type\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: '''Get all entries in the table.''' return await Equipment . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Equipment ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM UserEquipment; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Equipment if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM UserEquipment WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , item_id , result_type = Equipment if not as_dict else dict ) @staticmethod async def get_equipment ( conn : asyncpg . Connection , user_id : int , equipment_type : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ]: '''Get a user's equipment based on equipment type.''' query = \"\"\" SELECT * FROM UserEquipment WHERE user_id = ($1) AND eq_type = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , equipment_type , result_type = Equipment if not as_dict else dict ) @staticmethod async def get_user_equipments ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: return await Equipment . get_all_where ( conn , where = lambda r : r . user_id == user_id , as_dict = as_dict ) @staticmethod async def get_user_potions ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: return await Equipment . get_all_where ( conn , where = lambda r : Equipment . is_potion ( r . item_id ) and r . user_id == user_id , as_dict = as_dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , equipment : Equipment ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"UserEquipment\" , len ( equipment . __slots__ )) return await run_and_return_count ( conn , query , equipment . user_id , equipment . item_id , equipment . eq_type , equipment . remain_durability ) @staticmethod async def transfer_from_inventory ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Transfer an equipment from the inventory. Warnings -------- This does not check whether the user already has that equipment. This must be checked by the user, otherwise an `asyncpg.UniqueViolationError` might be raised. Notes ----- This function already has its own transaction. There is no need to wrap a transaction for this function. Parameters ---------- conn : asyncpg.Connection The connection to use. inventory : Inventory The inventory wrapping the equipment. Returns ------- int The number of entries affected. Should be 1 or 0. Raises ------ asyncpg.UniqueViolationError The unique constraint on `(user_id, eq_type)` is violated. ''' is_equipment = False for eq_type in Equipment . __EQUIPMENT_TYPE__ : if eq_type in inventory . item_id : is_equipment = True item = await Item . get_one ( conn , inventory . item_id ) equipment = Equipment ( inventory . user_id , inventory . item_id , eq_type , item . durability ) break if not is_equipment : return 0 async with conn . transaction (): status = await Inventory . remove ( conn , inventory . user_id , inventory . item_id ) if status == 0 : return 0 # TODO: Add a check to see if the same equipment type is already there. return await Equipment . insert_one ( conn , equipment ) @staticmethod async def delete ( conn : asyncpg . Connection , user_id : int , item_id : str ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM UserEquipment WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id ) @staticmethod async def delete_entries ( conn : asyncpg . Connection , equipments : list [ Equipment ]): async with conn . transaction (): for equipment in equipments : await Equipment . delete ( conn , equipment . user_id , equipment . item_id ) @staticmethod async def update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Equipment . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE UserEquipment SET { column } = ($3) WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id , new_value ) @staticmethod async def update_durability ( conn : asyncpg . Connection , user_id : int , item_id : str , new_durability : int ) -> int : '''Update an equipment's durability and remove if needed.''' if new_durability <= 0 : return await Equipment . delete ( conn , user_id , item_id ) return await Equipment . update_column ( conn , user_id , item_id , \"remain_durability\" , new_durability ) @staticmethod def is_equipment ( item_id : str ) -> bool : '''Check if the item is an equipment or not. Parameters ---------- item_id : str The item's id to check. Returns ------- bool Whether the item is an equipment or not. ''' for eq_type in Equipment . __EQUIPMENT_TYPE__ : if eq_type in item_id : return True return False @staticmethod def is_true_equipment ( item_id : str ) -> bool : return Equipment . is_equipment ( item_id ) and not Equipment . is_potion ( item_id ) @staticmethod def is_potion ( item_id : str ) -> bool : return \"_potion\" in item_id @staticmethod def get_equipment_type ( item_id : str ) -> t . Optional [ str ]: '''Return the equipment type of the equipment. Parameters ---------- item_id : str The item's id. Returns ------- t.Optional[str] The equipment type of the equipment, or `None` if it is not an equipment. ''' if not Equipment . is_equipment ( item_id ): return None return '_' + item_id . split ( '_' )[ - 1 ]","title":"Equipment"},{"location":"dev/psql/#utils.psql.Equipment.get_all","text":"get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]] Get all entries in the table. Source code in utils/psql.py 977 978 979 980 981 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: '''Get all entries in the table.''' return await Equipment . get_all_where ( conn , as_dict = as_dict )","title":"get_all()"},{"location":"dev/psql/#utils.psql.Equipment.get_all_where","text":"get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Equipment ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]] Get all entires in the table that matches the condition. Source code in utils/psql.py 982 983 984 985 986 987 988 989 990 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Equipment ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM UserEquipment; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Equipment if not as_dict else dict )","title":"get_all_where()"},{"location":"dev/psql/#utils.psql.Equipment.get_one","text":"get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ] Get the first entry in the table that matches the pkey provided. Source code in utils/psql.py 991 992 993 994 995 996 997 998 999 1000 @staticmethod async def get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM UserEquipment WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , item_id , result_type = Equipment if not as_dict else dict )","title":"get_one()"},{"location":"dev/psql/#utils.psql.Equipment.get_equipment","text":"get_equipment ( conn : asyncpg . Connection , user_id : int , equipment_type : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ] Get a user's equipment based on equipment type. Source code in utils/psql.py 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 @staticmethod async def get_equipment ( conn : asyncpg . Connection , user_id : int , equipment_type : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ]: '''Get a user's equipment based on equipment type.''' query = \"\"\" SELECT * FROM UserEquipment WHERE user_id = ($1) AND eq_type = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , equipment_type , result_type = Equipment if not as_dict else dict )","title":"get_equipment()"},{"location":"dev/psql/#utils.psql.Equipment.insert_one","text":"insert_one ( conn : asyncpg . Connection , equipment : Equipment ) -> int Insert an entry into the table. Source code in utils/psql.py 1017 1018 1019 1020 1021 1022 @staticmethod async def insert_one ( conn : asyncpg . Connection , equipment : Equipment ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"UserEquipment\" , len ( equipment . __slots__ )) return await run_and_return_count ( conn , query , equipment . user_id , equipment . item_id , equipment . eq_type , equipment . remain_durability )","title":"insert_one()"},{"location":"dev/psql/#utils.psql.Equipment.transfer_from_inventory","text":"transfer_from_inventory ( conn : asyncpg . Connection , inventory : Inventory ) -> int Transfer an equipment from the inventory.","title":"transfer_from_inventory()"},{"location":"dev/psql/#utils.psql.Equipment.transfer_from_inventory--warnings","text":"This does not check whether the user already has that equipment. This must be checked by the user, otherwise an asyncpg.UniqueViolationError might be raised.","title":"Warnings"},{"location":"dev/psql/#utils.psql.Equipment.transfer_from_inventory--notes","text":"This function already has its own transaction. There is no need to wrap a transaction for this function. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required inventory Inventory The inventory wrapping the equipment. required Returns: Type Description int The number of entries affected. Should be 1 or 0. Raises: Type Description asyncpg . UniqueViolationError The unique constraint on (user_id, eq_type) is violated. Source code in utils/psql.py 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 @staticmethod async def transfer_from_inventory ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Transfer an equipment from the inventory. Warnings -------- This does not check whether the user already has that equipment. This must be checked by the user, otherwise an `asyncpg.UniqueViolationError` might be raised. Notes ----- This function already has its own transaction. There is no need to wrap a transaction for this function. Parameters ---------- conn : asyncpg.Connection The connection to use. inventory : Inventory The inventory wrapping the equipment. Returns ------- int The number of entries affected. Should be 1 or 0. Raises ------ asyncpg.UniqueViolationError The unique constraint on `(user_id, eq_type)` is violated. ''' is_equipment = False for eq_type in Equipment . __EQUIPMENT_TYPE__ : if eq_type in inventory . item_id : is_equipment = True item = await Item . get_one ( conn , inventory . item_id ) equipment = Equipment ( inventory . user_id , inventory . item_id , eq_type , item . durability ) break if not is_equipment : return 0 async with conn . transaction (): status = await Inventory . remove ( conn , inventory . user_id , inventory . item_id ) if status == 0 : return 0 # TODO: Add a check to see if the same equipment type is already there. return await Equipment . insert_one ( conn , equipment )","title":"Notes"},{"location":"dev/psql/#utils.psql.Equipment.delete","text":"delete ( conn : asyncpg . Connection , user_id : int , item_id : str ) -> int Delete an entry in the table based on the provided key. Source code in utils/psql.py 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 @staticmethod async def delete ( conn : asyncpg . Connection , user_id : int , item_id : str ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM UserEquipment WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id )","title":"delete()"},{"location":"dev/psql/#utils.psql.Equipment.update_column","text":"update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int Update a specific column with a new value.","title":"update_column()"},{"location":"dev/psql/#utils.psql.Equipment.update_column--warnings","text":"Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL.","title":"Warnings"},{"location":"dev/psql/#utils.psql.Equipment.update_column--notes","text":"Always prefer using other functions to update rather than this function if possible. Source code in utils/psql.py 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 @staticmethod async def update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Equipment . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE UserEquipment SET { column } = ($3) WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id , new_value )","title":"Notes"},{"location":"dev/psql/#utils.psql.Equipment.update_durability","text":"update_durability ( conn : asyncpg . Connection , user_id : int , item_id : str , new_durability : int ) -> int Update an equipment's durability and remove if needed. Source code in utils/psql.py 1110 1111 1112 1113 1114 1115 1116 @staticmethod async def update_durability ( conn : asyncpg . Connection , user_id : int , item_id : str , new_durability : int ) -> int : '''Update an equipment's durability and remove if needed.''' if new_durability <= 0 : return await Equipment . delete ( conn , user_id , item_id ) return await Equipment . update_column ( conn , user_id , item_id , \"remain_durability\" , new_durability )","title":"update_durability()"},{"location":"dev/psql/#utils.psql.Equipment.is_equipment","text":"is_equipment ( item_id : str ) -> bool Check if the item is an equipment or not. Parameters: Name Type Description Default item_id str The item's id to check. required Returns: Type Description bool Whether the item is an equipment or not. Source code in utils/psql.py 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 @staticmethod def is_equipment ( item_id : str ) -> bool : '''Check if the item is an equipment or not. Parameters ---------- item_id : str The item's id to check. Returns ------- bool Whether the item is an equipment or not. ''' for eq_type in Equipment . __EQUIPMENT_TYPE__ : if eq_type in item_id : return True return False","title":"is_equipment()"},{"location":"dev/psql/#utils.psql.Equipment.get_equipment_type","text":"get_equipment_type ( item_id : str ) -> t . Optional [ str ] Return the equipment type of the equipment. Parameters: Name Type Description Default item_id str The item's id. required Returns: Type Description t . Optional [ str ] The equipment type of the equipment, or None if it is not an equipment. Source code in utils/psql.py 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 @staticmethod def get_equipment_type ( item_id : str ) -> t . Optional [ str ]: '''Return the equipment type of the equipment. Parameters ---------- item_id : str The item's id. Returns ------- t.Optional[str] The equipment type of the equipment, or `None` if it is not an equipment. ''' if not Equipment . is_equipment ( item_id ): return None return '_' + item_id . split ( '_' )[ - 1 ]","title":"get_equipment_type()"},{"location":"dev/psql/#utils.psql.Badge","text":"Source code in utils/psql.py 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 @dataclasses . dataclass ( slots = True ) class Badge : id : str sort_id : int name : str emoji : str description : str requirement : int = 0 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ): return await Badge . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Badge ], bool ] = lambda r : True , as_dict : bool = False ): query = \"\"\" SELECT * FROM Badges ORDER BY sort_id; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Badge if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : str , * , as_dict : bool = False ): query = \"\"\" SELECT * FROM Badges WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Badge if not as_dict else dict ) @staticmethod async def get_by_name ( conn : asyncpg . Connection , name : str , * , as_dict : bool = False ): query = \"\"\" SELECT * FROM Badges WHERE name LIKE ($1); \"\"\" return await __get_one__ ( conn , query , name , result_type = Badge if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , badge : Badge ): query = insert_into_query ( \"Badges\" , len ( Badge . __slots__ )) return await run_and_return_count ( conn , query , badge . id , badge . sort_id , badge . name , badge . emoji , badge . description , badge . requirement ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : str , column : str , new_value ): query = f \"\"\" UPDATE Badges SET { column } = ($2) WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id , new_value ) @staticmethod async def update ( conn : asyncpg . Connection , badge : Badge ): '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_badge = await Badge . get_one ( conn , badge . id ) if existing_badge is None : await Badge . insert_one ( conn , badge ) logger . info ( \"Loaded new badge ' %s ' into the database.\" , badge . id ) else : diff_col = [] for col in existing_badge . __slots__ : if getattr ( existing_badge , col ) != getattr ( badge , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Badge . update_column ( conn , badge . id , change , getattr ( badge , change )) if diff_col : logger . info ( \"Updated item ' %s ' in the following columns: %s .\" , badge . id , diff_col )","title":"Badge"},{"location":"dev/psql/#utils.psql.Badge.update","text":"update ( conn : asyncpg . Connection , badge : Badge ) Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead.","title":"update()"},{"location":"dev/psql/#utils.psql.Badge.update--notes","text":"This function has its own transaction. Source code in utils/psql.py 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 @staticmethod async def update ( conn : asyncpg . Connection , badge : Badge ): '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_badge = await Badge . get_one ( conn , badge . id ) if existing_badge is None : await Badge . insert_one ( conn , badge ) logger . info ( \"Loaded new badge ' %s ' into the database.\" , badge . id ) else : diff_col = [] for col in existing_badge . __slots__ : if getattr ( existing_badge , col ) != getattr ( badge , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Badge . update_column ( conn , badge . id , change , getattr ( badge , change )) if diff_col : logger . info ( \"Updated item ' %s ' in the following columns: %s .\" , badge . id , diff_col )","title":"Notes"},{"location":"dev/psql/#utils.psql.UserBadge","text":"Represent an entry in the UserEquipment table along with possible operations related to the table. Note that badge_requirement is a read-only attribute; it doesn't matter if you try to update it, it'll be ignored because it doesn't belong to this table. Source code in utils/psql.py 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 @dataclasses . dataclass ( slots = True ) class UserBadge : '''Represent an entry in the `UserEquipment` table along with possible operations related to the table. Note that `badge_requirement` is a read-only attribute; it doesn't matter if you try to update it, it'll be ignored because it doesn't belong to this table. ''' user_id : int badge_id : str badge_progress : int = 0 badge_requirement : int = 0 __PREVENT_UPDATE = ( \"user_id\" , \"badge_id\" , \"badge_requirement\" ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ UserBadge ], bool ] = lambda r : True , as_dict : bool = False ): query = \"\"\" SELECT Users_Badges.*, Badges.requirement AS badge_requirement FROM Users_Badges INNER JOIN Badges ON Users_Badges.badge_id = Badges.id; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = UserBadge if not as_dict else dict ) @staticmethod async def get_user_badges ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ): query = f \"\"\" SELECT Users_Badges.*, Badges.requirement AS badge_requirement FROM Users_Badges INNER JOIN Badges ON Users_Badges.badge_id = Badges.id WHERE user_id = { user_id } ; \"\"\" return await __get_all__ ( conn , query , result_type = UserBadge if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , user_id : int , badge_id : str , * , as_dict : bool = False ): query = \"\"\" SELECT Users_Badges.*, Badges.requirement AS badge_requirement FROM Users_Badges INNER JOIN Badges ON Users_Badges.badge_id = Badges.id WHERE user_id = ($1) AND badge_id = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , badge_id , result_type = UserBadge if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , ubadge : UserBadge ): query = insert_into_query ( \"Users_Badges\" , len ( UserBadge . __slots__ ) - 1 ) return await run_and_return_count ( conn , query , ubadge . user_id , ubadge . badge_id , ubadge . badge_progress ) @staticmethod async def add ( conn : asyncpg . Connection , ubadge : UserBadge ): query = \"\"\" INSERT INTO Users_Badges VALUES ($1, $2, $3) ON CONFLICT DO NOTHING; \"\"\" return await run_and_return_count ( conn , query , ubadge . user_id , ubadge . badge_id , ubadge . badge_progress ) @staticmethod async def update_column ( conn : asyncpg . Connection , user_id : int , badge_id : str , column : str , new_value ): if column in UserBadge . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Users_Badges SET { column } = ($3) WHERE user_id = ($1) AND badge_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , badge_id , new_value ) @staticmethod async def update ( conn : asyncpg . Connection , ubadge : UserBadge ): '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_badge = await UserBadge . get_one ( conn , ubadge . user_id , ubadge . badge_id ) if existing_badge is None : await UserBadge . insert_one ( conn , ubadge ) else : diff_col = [] for col in existing_badge . __slots__ : if getattr ( existing_badge , col ) != getattr ( ubadge , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await UserBadge . update_column ( conn , ubadge . user_id , ubadge . badge_id , change , getattr ( ubadge , change )) @staticmethod async def add_progress ( conn : asyncpg . Connection , user_id : int , badge_id : str , progress : int = 1 ): existing_badge = await UserBadge . get_one ( conn , user_id , badge_id ) if not existing_badge : return await UserBadge . insert_one ( conn , UserBadge ( user_id , badge_id , progress )) existing_badge . badge_progress += progress return await UserBadge . update_column ( conn , user_id , badge_id , \"badge_progress\" , existing_badge . badge_progress ) def completed ( self ): return self . badge_progress >= self . badge_requirement","title":"UserBadge"},{"location":"dev/psql/#utils.psql.UserBadge.update","text":"update ( conn : asyncpg . Connection , ubadge : UserBadge ) Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead.","title":"update()"},{"location":"dev/psql/#utils.psql.UserBadge.update--notes","text":"This function has its own transaction. Source code in utils/psql.py 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 @staticmethod async def update ( conn : asyncpg . Connection , ubadge : UserBadge ): '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_badge = await UserBadge . get_one ( conn , ubadge . user_id , ubadge . badge_id ) if existing_badge is None : await UserBadge . insert_one ( conn , ubadge ) else : diff_col = [] for col in existing_badge . __slots__ : if getattr ( existing_badge , col ) != getattr ( ubadge , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await UserBadge . update_column ( conn , ubadge . user_id , ubadge . badge_id , change , getattr ( ubadge , change ))","title":"Notes"},{"location":"dev/psql/#utils.psql.record_to_type","text":"record_to_type ( record : asyncpg . Record , / , result_type : t . Type [ T ] = dict ) -> T Convert a asyncpg.Record into a dict or None if the object is already None . This is for convenience purpose, where dict(Record) will return {} which is not an accurate representation of empty. obj is None or obj is not None is more obvious to anyone than bool(obj) or not bool(obj) . Parameters: Name Type Description Default record asyncpg . Record The record to convert. required result_type t . Type The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a dict . Default to dict . dict","title":"record_to_type()"},{"location":"dev/psql/#utils.psql.record_to_type--return","text":"t.Optional[T] Either None or result_type . Source code in utils/psql.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def record_to_type ( record : asyncpg . Record , / , result_type : t . Type [ T ] = dict ) -> T : '''Convert a `asyncpg.Record` into a `dict` or `None` if the object is already `None`. This is for convenience purpose, where `dict(Record)` will return `{}` which is not an accurate representation of empty. `obj is None` or `obj is not None` is more obvious to anyone than `bool(obj)` or `not bool(obj)`. Parameters ---------- record : asyncpg.Record The record to convert. result_type : t.Type The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a `dict`. Default to `dict`. Return ------ t.Optional[T] Either `None` or `result_type`. ''' if record is None : return None d = dict ( record ) if result_type is dict : return d return result_type ( ** d )","title":"Return"},{"location":"dev/psql/#utils.psql.legacy_insert_into","text":"legacy_insert_into ( conn , table_name : str , * args ) Insert values into table_name . Warning: This function is an old function from pre-rewrite. It is advised to do the logic by yourself. Source code in utils/psql.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 async def legacy_insert_into ( conn , table_name : str , * args ): ''' Insert values into `table_name`. Warning: This function is an old function from pre-rewrite. It is advised to do the logic by yourself. ''' arg_str = \"(\" # max(*args, key = len): Get the longest tuple in the list. for j in range ( len ( max ( * args , key = len ))): arg_str += f \"$ { j + 1 } , \" arg_str = arg_str [: - 2 ] + ')' await conn . executemany ( f ''' INSERT INTO { table_name } VALUES { arg_str } ''' , * args )","title":"legacy_insert_into()"},{"location":"dev/psql/#utils.psql.insert_into_query","text":"insert_into_query ( table_name : str , len_col : int ) -> str Return the query to insert into a table that has len_col columns. Parameters: Name Type Description Default table_name str The table to insert. required len_col int How many column does the table have. required Returns: Type Description str An INSERT SQL statement with query formatter ready to use in .execute() Source code in utils/psql.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def insert_into_query ( table_name : str , len_col : int ) -> str : '''Return the query to insert into a table that has `len_col` columns. Parameters ---------- table_name : str The table to insert. len_col : int How many column does the table have. Returns ------- str An INSERT SQL statement with query formatter ready to use in `.execute()` ''' arg_str = \"(\" for index in range ( len_col ): arg_str += f \"$ { index + 1 } , \" arg_str = arg_str [: - 2 ] + ')' return f \"INSERT INTO { table_name } VALUES { arg_str } ;\"","title":"insert_into_query()"},{"location":"dev/psql/#utils.psql.__get_all__","text":"__get_all__ ( conn : asyncpg . Connection , query : str , * , where : t . Callable [[ T ], bool ] = lambda r : True , result_type : t . Type [ T ] = dict ) -> list [ T ] Run a SELECT statement and return a list of objects. This should NOT be used outside of the module. Instead, use table_name.get_all() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required query str The SELECT statement to run. This should not contain WHERE clause. Conditions should be set in where parameter. required where t . Callable [[ dict ], bool ] Additional conditions to filter. By default, no condition is applied (always return True ). lambda r: True result_type t . Type [ T ] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a dict . Default to dict . dict Returns: Type Description list [ T ] A list of result_type or empty list. Source code in utils/psql.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 async def __get_all__ ( conn : asyncpg . Connection , query : str , * , where : t . Callable [[ T ], bool ] = lambda r : True , result_type : t . Type [ T ] = dict ) -> list [ T ]: '''Run a `SELECT` statement and return a list of objects. This should NOT be used outside of the module. Instead, use `table_name.get_all()`. Parameters ---------- conn : asyncpg.Connection The connection to use. query : str The `SELECT` statement to run. This should not contain `WHERE` clause. Conditions should be set in `where` parameter. where : t.Callable[[dict], bool] Additional conditions to filter. By default, no condition is applied (always return `True`). result_type : t.Type[T] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a `dict`. Default to `dict`. Returns ------- list[T] A list of `result_type` or empty list. ''' result = await conn . fetch ( query ) l = [] record_obj = None for record in result : # NOTE: This code is for handling dict case; will remove soon. #record_obj = record_to_type(record) #if record_obj is None or (record_obj is not None and where(record_obj)): # l.append(record_obj) record_obj = record_to_type ( record , result_type ) if record_obj is None or ( record_obj is not None and where ( record_obj )): l . append ( record_obj ) return l","title":"__get_all__()"},{"location":"dev/psql/#utils.psql.__get_one__","text":"__get_one__ ( conn : asyncpg . Connection , query : str , * constraints , result_type : t . Type [ T ] = dict ) -> t . Optional [ T ] Run a SELECT statement and return the first object that matches the constraints. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required query str The SELECT statement to run. This should contain a WHERE clause. required *constraints str Arguments to be formatted into the query. () result_type t . Type [ T ] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a dict . Default to dict . dict Returns: Type Description t . Optional [ T ] A result_type or None if no object is found. Source code in utils/psql.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 async def __get_one__ ( conn : asyncpg . Connection , query : str , * constraints , result_type : t . Type [ T ] = dict ) -> t . Optional [ T ]: '''Run a `SELECT` statement and return the first object that matches the constraints. Parameters ---------- conn : asyncpg.Connection The connection to use. query : str The `SELECT` statement to run. This should contain a `WHERE` clause. *constraints : str Arguments to be formatted into the query. result_type : t.Type[T] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a `dict`. Default to `dict`. Returns ------- t.Optional[T] A `result_type` or `None` if no object is found. ''' record = await conn . fetchrow ( query , * constraints ) return record_to_type ( record , result_type )","title":"__get_one__()"},{"location":"dev/psql/#utils.psql.run_and_return_count","text":"run_and_return_count ( conn : asyncpg . Connection , query : str , * args , ** kwargs ) -> t . Optional [ int ] Execute an SQL operation and return the number of entries affected.","title":"run_and_return_count()"},{"location":"dev/psql/#utils.psql.run_and_return_count--warnings","text":"This is meant to run INSERT, DELETE, and UPDATE statements. Other statement might or might not work. Parameters: Name Type Description Default conn asyncpg . Connection The connection to execute. required *args tuple The arguments to pass into conn.execute() () **kwargs The arguments to pass into conn.execute() {} Returns: Type Description t . Optional [ int ] The number of rows affected. If the operation doesn't return the row count, None is returned. Source code in utils/psql.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 async def run_and_return_count ( conn : asyncpg . Connection , query : str , * args , ** kwargs ) -> t . Optional [ int ]: '''Execute an SQL operation and return the number of entries affected. Warnings -------- This is meant to run INSERT, DELETE, and UPDATE statements. Other statement might or might not work. Parameters ---------- conn : asyncpg.Connection The connection to execute. *args : tuple The arguments to pass into `conn.execute()` **kwargs: dict The arguments to pass into `conn.execute()` Returns ------- t.Optional[int] The number of rows affected. If the operation doesn't return the row count, `None` is returned. ''' status = await conn . execute ( query , * args , ** kwargs ) # INSERT returns \"INSERT oid count\". try : count = int ( status . split ()[ - 1 ]) return count except ValueError : return None","title":"Warnings"},{"location":"econ/badges/","text":"Badges Badges are sort of achievements/milestones you get which can also act as permanent buffs. Below are all the badges in the bot. You can check them in categories/econ/badges.json . Name Description Detail The Beginning A decorative badge. Earned by obtaining your first log. Obtain log in any ways. Wooden Age After chopping quite an amount of logs, the merchant decides to buy your wood for a higher price. Chop at least 200 logs. Increase log sell price from 3 to 4. Nature Killer You chopped so many trees, it's actually quite surprising the Earth hasn't collapsed from the lack of photosynthesis. Chop at least 2000 logs. Increase log rate from chopping. First Meal Wow, you can eat! It's delicious. Use a food item at least once. Tasty Meal After eating quite an amount of food, your body seems to absorb nutrients from food more efficiently. Use at least 500 food items. Increase the healing amount of any food items by 5. Bizarre Eating You ate a lot, and yet your belly doesn't grow. What a mystery. Use at least 1000 food items. Increase the healing amount of any food items by 20% (after accounting Tasty Meal). Metal Acquired A decorative badge. Earned by obtaining your first iron. Obtain iron in any ways. Iron Age Everyone wants iron. With that in mind, you now sell it for even a higher price. Mine at least 200 irons. Increase iron sell price from 12 to 14. Iron Man Do you ever wonder where these iron ingots come from? Mine at least 2000 irons. Increase iron rate from mining by 10%. Diamond! A decorative badge. Earned by obtaining your first diamond. Obtain diamond in any ways. Diamond Hunter After mining quite an amount of diamonds, you now know the strategy to greatly improve your chance of finding diamonds. Mine at least 100 diamonds. Increase diamond drop rate by 5%. Full Diamond Now that you have all the diamonds in the world, what do you do now? Mine at least 1000 diamonds. Further increase diamond drop rate by 10%. Minimum and maximum diamond drops are increased by 2. Hidden in the Depth A decorative badge. Earned from getting Ancient Debris. Obtain ancient debris in any ways. Heavy Metals After mining quite an amount of Ancient Debris, you now know the strategy to greatly improve your chance of finding Ancient Debris. Mine at least 50 ancient debris. Increase debris drop rate by 2.5%. Netherist That's a lot of effort to mine all these debris. Maybe I'll reward you with this badge. Looks cool with the Netherite right? Mine at least 500 ancient debris. Further increase debris drop rate by 5%. Minimum and maximum debris drops are increased by 1. Info Fire A decorative badge. Earned by obtaining your first blaze rod. Obtain blaze rod in any ways. Firefighter Did you know snowball is effective against blazes? Yea no one cares anyway, Power V Bow go brr. Explore and obtain at least 100 blaze rods. Increase blaze rod drop rate by 5%. Sudden End All of a sudden you died! This is a compensation for that. At least now you know you can die in here. Die at least 1 time. Staph Dying! You died so many times, the bot has to give you a mercy on increasing your damage reductions a bit. Die at least 50 times. Gives +3 damage reductions for every equipment equipped. How are you still sane? Actually how? Die at least 100 times. Lower inventory death penalty from 5% to 2%. Kasaneru IF Repeating Life from Zero Die at least 500 times. Gives +2 (for a total of +5) damage reductions for every equipment equipped. Local Brewery A decorative badge. Earned from brewing your first potion. Brew at least 1 potion. Alchemist After brewing for a while, you find a way to optimize the materials so you can produce 1 more bottle! Brew at least 50 potions. Brew recipe will yield an additional potion (4 instead of 3). Mad Scientist You brew potions for so long, you can produce 2 more bottles out of the existing recipe. Crazy. Brew at least 500 potions. Brew recipe will yield 2 more potions (6 instead of 4). Potion Master You know potions in the back of your hand. This allows you to use 1 more potion. Brew at least 1000 potions. You can equip up to 4 potions at a time.","title":"Badges"},{"location":"econ/badges/#badges","text":"Badges are sort of achievements/milestones you get which can also act as permanent buffs. Below are all the badges in the bot. You can check them in categories/econ/badges.json . Name Description Detail The Beginning A decorative badge. Earned by obtaining your first log. Obtain log in any ways. Wooden Age After chopping quite an amount of logs, the merchant decides to buy your wood for a higher price. Chop at least 200 logs. Increase log sell price from 3 to 4. Nature Killer You chopped so many trees, it's actually quite surprising the Earth hasn't collapsed from the lack of photosynthesis. Chop at least 2000 logs. Increase log rate from chopping. First Meal Wow, you can eat! It's delicious. Use a food item at least once. Tasty Meal After eating quite an amount of food, your body seems to absorb nutrients from food more efficiently. Use at least 500 food items. Increase the healing amount of any food items by 5. Bizarre Eating You ate a lot, and yet your belly doesn't grow. What a mystery. Use at least 1000 food items. Increase the healing amount of any food items by 20% (after accounting Tasty Meal). Metal Acquired A decorative badge. Earned by obtaining your first iron. Obtain iron in any ways. Iron Age Everyone wants iron. With that in mind, you now sell it for even a higher price. Mine at least 200 irons. Increase iron sell price from 12 to 14. Iron Man Do you ever wonder where these iron ingots come from? Mine at least 2000 irons. Increase iron rate from mining by 10%. Diamond! A decorative badge. Earned by obtaining your first diamond. Obtain diamond in any ways. Diamond Hunter After mining quite an amount of diamonds, you now know the strategy to greatly improve your chance of finding diamonds. Mine at least 100 diamonds. Increase diamond drop rate by 5%. Full Diamond Now that you have all the diamonds in the world, what do you do now? Mine at least 1000 diamonds. Further increase diamond drop rate by 10%. Minimum and maximum diamond drops are increased by 2. Hidden in the Depth A decorative badge. Earned from getting Ancient Debris. Obtain ancient debris in any ways. Heavy Metals After mining quite an amount of Ancient Debris, you now know the strategy to greatly improve your chance of finding Ancient Debris. Mine at least 50 ancient debris. Increase debris drop rate by 2.5%. Netherist That's a lot of effort to mine all these debris. Maybe I'll reward you with this badge. Looks cool with the Netherite right? Mine at least 500 ancient debris. Further increase debris drop rate by 5%. Minimum and maximum debris drops are increased by 1. Info Fire A decorative badge. Earned by obtaining your first blaze rod. Obtain blaze rod in any ways. Firefighter Did you know snowball is effective against blazes? Yea no one cares anyway, Power V Bow go brr. Explore and obtain at least 100 blaze rods. Increase blaze rod drop rate by 5%. Sudden End All of a sudden you died! This is a compensation for that. At least now you know you can die in here. Die at least 1 time. Staph Dying! You died so many times, the bot has to give you a mercy on increasing your damage reductions a bit. Die at least 50 times. Gives +3 damage reductions for every equipment equipped. How are you still sane? Actually how? Die at least 100 times. Lower inventory death penalty from 5% to 2%. Kasaneru IF Repeating Life from Zero Die at least 500 times. Gives +2 (for a total of +5) damage reductions for every equipment equipped. Local Brewery A decorative badge. Earned from brewing your first potion. Brew at least 1 potion. Alchemist After brewing for a while, you find a way to optimize the materials so you can produce 1 more bottle! Brew at least 50 potions. Brew recipe will yield an additional potion (4 instead of 3). Mad Scientist You brew potions for so long, you can produce 2 more bottles out of the existing recipe. Crazy. Brew at least 500 potions. Brew recipe will yield 2 more potions (6 instead of 4). Potion Master You know potions in the back of your hand. This allows you to use 1 more potion. Brew at least 1000 potions. You can equip up to 4 potions at a time.","title":"Badges"},{"location":"econ/death/","text":"Damage Mechanism The damage mechanism can be beneficial if you know what's going on in order to avoid damage lost and eventually, death. You can always check out categories/economy.py for more technical details. Also note that the damage mechanism only happens to action commands ( mine , explore , chop ). Brief Overall, the bot will use the loot table generated from each action command to determine the maximum damage you'll receive. After a few processing, the actual damage you'll be taking (or final damage ) will be a random value in the range of [max_dmg / 2, max_dmg] . Thus, the damage mentioned for the rest of the page will refer to max damage , unless stated otherwise. Reward Value When a loot table is generated for action commands (before multipliers and rerolls start to apply), the bot also generate the max damage for this action. These are manually defined, but generally, the better the reward, the higher the damage. The exact values can be found in categories/econ/loot.py , under the __<ACTION>_LOOT variable. Damage Reductions Damage Reductions further lower the damage. Basically the bot will check for your relevant equipments and any relevant boosts you have that lower the damage and apply directly. For example, a diamond pickaxe has a damage reduction of 25, so it'll take the current damage and subtract 25 out of that. This will be applied continuously until it goes through all the reductions. However, no matter how many reductions you apply, the max damage can't be lower than 2 . Finally, your final damage will be determined by a random number between [floor(dmg / 2) - 1, dmg] , where dmg is the max damage. This is to ensure there are varieties in the final damage. Example: You have a diamond pickaxe, so you're having a 25 damage reductions. You also have a strength potion equipped, so you have another 2 damage reductions. You mine something and get a raw damage of 60. You're mining in the Overworld, so the bot caps your damage to 50. Now the bot applies reductions. You have 25 + 2 = 27 reductions. Thus, you'll at most receive 50 - 27 = 23 damage. Your final damage (the damage you're actually taking) will be a random number between [floor(23 / 2) - 1, 23] , which is [10, 23] . Available Reductions All damage reductions can be found in categories/econ/loot.py , defined by the DMG_REDUCTIONS variable. Wood tools: 0 Stone tools: 10 Iron sword + axe: 20 Iron pickaxe: 15 Diamond tools: 25 Netherite tools: 25 Fire Potion: 2 Haste Potion: 2 when mining and chopping Strength Potion: 2 when exploring Fortune Potion: 5 when mining Looting Potion: 5 when exploring Nature Potion: 5 when chopping Luck Potion: 10 Staph Dying! badge: 3 per equipment (including potions) Kasaneru IF badge: 2 per equipment (including potions) Note that for tools, reduction only applies to the corresponding action. For example, if you have a diamond pickaxe and an iron sword, then when mining, you'll have the 25 reductions, while when you're exploring, you'll have the 20 reductions. Death Penalty If you don't monitor your health and let it drop to 0 or below, you dies. These are the consequences of death: Losing all equipments with few exceptions. Losing all potions. Losing 20% of current balance (rounded up). Losing 5% (2% if How are you still sane? badge is acquired) of all items in inventory (rounded up). If the user is in a different world, they'll be forced to be in the Overworld, with a few exceptions. This won't update the cooldown in travel . Health reset back to 100. Out of all of these, losing all potions and 5% of all items in inventory are arguably the worst, so don't die :)","title":"Death Mechanism"},{"location":"econ/death/#damage-mechanism","text":"The damage mechanism can be beneficial if you know what's going on in order to avoid damage lost and eventually, death. You can always check out categories/economy.py for more technical details. Also note that the damage mechanism only happens to action commands ( mine , explore , chop ).","title":"Damage Mechanism"},{"location":"econ/death/#brief","text":"Overall, the bot will use the loot table generated from each action command to determine the maximum damage you'll receive. After a few processing, the actual damage you'll be taking (or final damage ) will be a random value in the range of [max_dmg / 2, max_dmg] . Thus, the damage mentioned for the rest of the page will refer to max damage , unless stated otherwise.","title":"Brief"},{"location":"econ/death/#reward-value","text":"When a loot table is generated for action commands (before multipliers and rerolls start to apply), the bot also generate the max damage for this action. These are manually defined, but generally, the better the reward, the higher the damage. The exact values can be found in categories/econ/loot.py , under the __<ACTION>_LOOT variable.","title":"Reward Value"},{"location":"econ/death/#damage-reductions","text":"Damage Reductions further lower the damage. Basically the bot will check for your relevant equipments and any relevant boosts you have that lower the damage and apply directly. For example, a diamond pickaxe has a damage reduction of 25, so it'll take the current damage and subtract 25 out of that. This will be applied continuously until it goes through all the reductions. However, no matter how many reductions you apply, the max damage can't be lower than 2 . Finally, your final damage will be determined by a random number between [floor(dmg / 2) - 1, dmg] , where dmg is the max damage. This is to ensure there are varieties in the final damage. Example: You have a diamond pickaxe, so you're having a 25 damage reductions. You also have a strength potion equipped, so you have another 2 damage reductions. You mine something and get a raw damage of 60. You're mining in the Overworld, so the bot caps your damage to 50. Now the bot applies reductions. You have 25 + 2 = 27 reductions. Thus, you'll at most receive 50 - 27 = 23 damage. Your final damage (the damage you're actually taking) will be a random number between [floor(23 / 2) - 1, 23] , which is [10, 23] .","title":"Damage Reductions"},{"location":"econ/death/#available-reductions","text":"All damage reductions can be found in categories/econ/loot.py , defined by the DMG_REDUCTIONS variable. Wood tools: 0 Stone tools: 10 Iron sword + axe: 20 Iron pickaxe: 15 Diamond tools: 25 Netherite tools: 25 Fire Potion: 2 Haste Potion: 2 when mining and chopping Strength Potion: 2 when exploring Fortune Potion: 5 when mining Looting Potion: 5 when exploring Nature Potion: 5 when chopping Luck Potion: 10 Staph Dying! badge: 3 per equipment (including potions) Kasaneru IF badge: 2 per equipment (including potions) Note that for tools, reduction only applies to the corresponding action. For example, if you have a diamond pickaxe and an iron sword, then when mining, you'll have the 25 reductions, while when you're exploring, you'll have the 20 reductions.","title":"Available Reductions"},{"location":"econ/death/#death-penalty","text":"If you don't monitor your health and let it drop to 0 or below, you dies. These are the consequences of death: Losing all equipments with few exceptions. Losing all potions. Losing 20% of current balance (rounded up). Losing 5% (2% if How are you still sane? badge is acquired) of all items in inventory (rounded up). If the user is in a different world, they'll be forced to be in the Overworld, with a few exceptions. This won't update the cooldown in travel . Health reset back to 100. Out of all of these, losing all potions and 5% of all items in inventory are arguably the worst, so don't die :)","title":"Death Penalty"},{"location":"econ/potions/","text":"Potions Potions can be seen as special equipments. They're internally treated as equipments, yet are slightly different from equipments. Potions are essential in midgame and especially endgame. However, they're often very expensive, so you'd need to do some planning before using them. A user can equip at most 3 different kinds of potions at once, and you can only equip at most 1 of the same kind of potions at once. Potions are created to mainly support action commands ( mine , explore , chop ), so keep this in mind. This may change in the future. All potions have their own effects that might stack with other potions' effects. These are often referred to as their main effect . However, these effects often has a chance to activate. When a potion activates, it'll apply its main effect and lose 1 durability, just like when you use an equipment. When it doesn't, nothing happens. In addition to their main effects, potions often have their passive effects . These are effects that always activate and doesn't consume any durability nor chance. These are often death reductions. All potions will be cleared when you die, so you have to plan carefully with your death chance. Potions can be obtained via brewing , which is just crafting but for potions. You'll need a lot of items along with some money, then use brew <potion> . Currently, each brew will give you 3 potions. This document will briefly describe all current potions in more details. It won't list the brew recipe because this can be easily checked via info item . All of the info here can be verified in the source code in categories/economy.py and categories/econ/loot.py if you have trust issues with me. Fire Potion The easiest potion to obtain. You can grab it in market with a price of 1500 alternatively besides the standard brewing system. Main Effect: When the user dies in the Nether, there is a 70% chance this potion will activate, negating the death of the user. Passive Effect: Lower the maximum damage by 2 on all dimensions. Durability: 10 This is a more lazy option if you're tight on food, so you decide whether or not to invest in this potion. Just to note, if you enter the Nether with low gear (which you shouldn't anyway), you should get this because the Nether will most likely one-hit you in some locations. Haste Potion Main Effect: A 50% chance to roll the drop 5 times and get all of them while mining and chopping. Passive Effect: Lower the maximum damage by 2 while mining. Durability: 20 Note that because it says \"roll\", you don't necessarily get x5 rewards, but your probability of getting an item is theoretically x5. Fortune Potion Main Effect: A 50% chance to multiply the drop by 4 times while mining. Passive Effect: Lower the maximum damage by 5 while mining. Durability: 20 Nature Potion Main Effect: A 50% chance to multiply the drop by 4 times while chopping. Passive Effect: Lower the maximum damage by 5 while chopping. Durability: 20 Strength Potion Main Effect: A 50% chance to roll the drop 5 times and get all of them while exploring. Passive Effect: Lower the maximum damage by 2 while exploring. Durability: 20 Note that because it says \"roll\", you don't necessarily get x5 rewards, but your probability of getting an item is theoretically x5. Looting Potion Main Effect: A 50% chance to multiply the drop by 4 times while exploring. Passive Effect: Lower the maximum damage by 5 while exploring. Durability: 20 Luck Potion Main Effect: A 50% chance to multiplies the drop by 2 times. Also ensure that 1. If a possible drop is already dropped, it'll then drop max_amount and 2. If a possible drop is not dropped, it'll then drop min_amount . Passive Effect: Lower the maximum damage by 10 on all dimensions. As a Legendary equipment, this cannot be lost upon death while equipped. Durability: 50 This is a powerful potion that basically removes the rate in which an item drops. It'd be basically 50%, completely based on whether the potion activates or not. However, note that there's a chance an item won't be dropped if its min_amount is 0. Undying Potion Main Effect: When the user receives a lethal damage or a damage over 40, there is a 100% chance this potion will activate, negating the said damage to the user. If Fire Potion is activated, Fire Potion will be prioritized over this potion. Passive Effect: While equipped, this potion will allow the user to equip 1 more potion. As a Legendary equipment, this cannot be lost upon death while equipped. Durability: 20 This is an extremely useful potion that guarantees you to not die, while essentially costing you no potion slot. It also renders some locations no longer dangerous, since most of the damage dealt by those location are typically well over 50. Definitely useful to get.","title":"Potions"},{"location":"econ/potions/#potions","text":"Potions can be seen as special equipments. They're internally treated as equipments, yet are slightly different from equipments. Potions are essential in midgame and especially endgame. However, they're often very expensive, so you'd need to do some planning before using them. A user can equip at most 3 different kinds of potions at once, and you can only equip at most 1 of the same kind of potions at once. Potions are created to mainly support action commands ( mine , explore , chop ), so keep this in mind. This may change in the future. All potions have their own effects that might stack with other potions' effects. These are often referred to as their main effect . However, these effects often has a chance to activate. When a potion activates, it'll apply its main effect and lose 1 durability, just like when you use an equipment. When it doesn't, nothing happens. In addition to their main effects, potions often have their passive effects . These are effects that always activate and doesn't consume any durability nor chance. These are often death reductions. All potions will be cleared when you die, so you have to plan carefully with your death chance. Potions can be obtained via brewing , which is just crafting but for potions. You'll need a lot of items along with some money, then use brew <potion> . Currently, each brew will give you 3 potions. This document will briefly describe all current potions in more details. It won't list the brew recipe because this can be easily checked via info item . All of the info here can be verified in the source code in categories/economy.py and categories/econ/loot.py if you have trust issues with me.","title":"Potions"},{"location":"econ/potions/#fire-potion","text":"The easiest potion to obtain. You can grab it in market with a price of 1500 alternatively besides the standard brewing system. Main Effect: When the user dies in the Nether, there is a 70% chance this potion will activate, negating the death of the user. Passive Effect: Lower the maximum damage by 2 on all dimensions. Durability: 10 This is a more lazy option if you're tight on food, so you decide whether or not to invest in this potion. Just to note, if you enter the Nether with low gear (which you shouldn't anyway), you should get this because the Nether will most likely one-hit you in some locations.","title":"Fire Potion"},{"location":"econ/potions/#haste-potion","text":"Main Effect: A 50% chance to roll the drop 5 times and get all of them while mining and chopping. Passive Effect: Lower the maximum damage by 2 while mining. Durability: 20 Note that because it says \"roll\", you don't necessarily get x5 rewards, but your probability of getting an item is theoretically x5.","title":"Haste Potion"},{"location":"econ/potions/#fortune-potion","text":"Main Effect: A 50% chance to multiply the drop by 4 times while mining. Passive Effect: Lower the maximum damage by 5 while mining. Durability: 20","title":"Fortune Potion"},{"location":"econ/potions/#nature-potion","text":"Main Effect: A 50% chance to multiply the drop by 4 times while chopping. Passive Effect: Lower the maximum damage by 5 while chopping. Durability: 20","title":"Nature Potion"},{"location":"econ/potions/#strength-potion","text":"Main Effect: A 50% chance to roll the drop 5 times and get all of them while exploring. Passive Effect: Lower the maximum damage by 2 while exploring. Durability: 20 Note that because it says \"roll\", you don't necessarily get x5 rewards, but your probability of getting an item is theoretically x5.","title":"Strength Potion"},{"location":"econ/potions/#looting-potion","text":"Main Effect: A 50% chance to multiply the drop by 4 times while exploring. Passive Effect: Lower the maximum damage by 5 while exploring. Durability: 20","title":"Looting Potion"},{"location":"econ/potions/#luck-potion","text":"Main Effect: A 50% chance to multiplies the drop by 2 times. Also ensure that 1. If a possible drop is already dropped, it'll then drop max_amount and 2. If a possible drop is not dropped, it'll then drop min_amount . Passive Effect: Lower the maximum damage by 10 on all dimensions. As a Legendary equipment, this cannot be lost upon death while equipped. Durability: 50 This is a powerful potion that basically removes the rate in which an item drops. It'd be basically 50%, completely based on whether the potion activates or not. However, note that there's a chance an item won't be dropped if its min_amount is 0.","title":"Luck Potion"},{"location":"econ/potions/#undying-potion","text":"Main Effect: When the user receives a lethal damage or a damage over 40, there is a 100% chance this potion will activate, negating the said damage to the user. If Fire Potion is activated, Fire Potion will be prioritized over this potion. Passive Effect: While equipped, this potion will allow the user to equip 1 more potion. As a Legendary equipment, this cannot be lost upon death while equipped. Durability: 20 This is an extremely useful potion that guarantees you to not die, while essentially costing you no potion slot. It also renders some locations no longer dangerous, since most of the damage dealt by those location are typically well over 50. Definitely useful to get.","title":"Undying Potion"},{"location":"econ/start/","text":"Economy System MichaelBot has its own economy system that's heavily inspired by Minecraft. This document is written to serve a brief intro to this system, as it can be confusing where to start. Guide Currently, the only valid way to get started is to use the command daily . This will gives you a pre-determined amount of money (or emerald) and some woods. Next, you'll need to craft some items to move on. Like Minecraft, you usually first craft some sticks, then a wooden pickaxe to mine stone, then craft stone tools, etc. The process follows somewhat similarly using the command craft . It's recommended to use the slash command version, since it gives a list of items you can craft as you type. /craft Stick /craft Wood Pickaxe Note that for prefix commands, some items' name need to be enclosed inside \"\" like \"Wood Pickaxe\" . This is not a problem for slash commands. A pickaxe (in this case, the Wood Pickaxe ) is considered to be an equipment, a subset of items that can be equipped and used. Other equipment can include a sword, axe, and potion (some of these are mere concept and not yet added). To use certain equipments, you'll need to equip them using equip . Sword, pickaxe, and axe are considered as tools , while potions are on their own. /equip tool Wood Pickaxe Now that you have your wooden pickaxe equipped, time to go mining. /mine These are considered to be action commands . These need certain equipments to be equipped before performing the action. In this case, mine requires a pickaxe equipped before using it, otherwise, it'll send an error. After the mining, you'll have some stone. Use them to craft more tools like in Minecraft. At this point, the progression is similar to Minecraft, so you should be able to progress. If not, feel free to explore what the system can do.","title":"Getting Started"},{"location":"econ/start/#economy-system","text":"MichaelBot has its own economy system that's heavily inspired by Minecraft. This document is written to serve a brief intro to this system, as it can be confusing where to start.","title":"Economy System"},{"location":"econ/start/#guide","text":"Currently, the only valid way to get started is to use the command daily . This will gives you a pre-determined amount of money (or emerald) and some woods. Next, you'll need to craft some items to move on. Like Minecraft, you usually first craft some sticks, then a wooden pickaxe to mine stone, then craft stone tools, etc. The process follows somewhat similarly using the command craft . It's recommended to use the slash command version, since it gives a list of items you can craft as you type. /craft Stick /craft Wood Pickaxe Note that for prefix commands, some items' name need to be enclosed inside \"\" like \"Wood Pickaxe\" . This is not a problem for slash commands. A pickaxe (in this case, the Wood Pickaxe ) is considered to be an equipment, a subset of items that can be equipped and used. Other equipment can include a sword, axe, and potion (some of these are mere concept and not yet added). To use certain equipments, you'll need to equip them using equip . Sword, pickaxe, and axe are considered as tools , while potions are on their own. /equip tool Wood Pickaxe Now that you have your wooden pickaxe equipped, time to go mining. /mine These are considered to be action commands . These need certain equipments to be equipped before performing the action. In this case, mine requires a pickaxe equipped before using it, otherwise, it'll send an error. After the mining, you'll have some stone. Use them to craft more tools like in Minecraft. At this point, the progression is similar to Minecraft, so you should be able to progress. If not, feel free to explore what the system can do.","title":"Guide"},{"location":"econ/trade/","text":"Trading System The trading system refers to a non-conventional way to convert item into money and vice versa. By the conventional way, it is to browse market (view) , then make any purchases using market buy and market sell . This is very stable; price are always the same unless the bot receives a balance update. However, the trading system has deals that are unconventional to market . These deals are fragile, and you only have around 4 hours before new deals arrive, overriding the old ones. Each deal has a limit a user can use the deal before it's expired. For example, a deal can have up to 20 trades permitted. After using the deal the 20th time, it is locked. The user would have to wait until the deals refresh or take a look at other deals. This limit is tracked per user per offer , not globally. As of now, trade and barter are the commands that use this system. From a design standpoint, they're practically the same. There are multiple deals, they all refresh every 4 hours, they use the same interface to interact with, etc. As for the interface, the trading system will use an embed that list all the offers along with a select menu the user can choose from. The user would then choose the offer they like to deal, which the bot would then perform the action. This cannot be undone. As the user keeps trading, the embed will edit itself to reflect the trading limit per each offer. Once the limit is reached, that offer will no longer appear in the menu, and you'd have to choose a different one or ignore for the menu to time out. trade The trade command pops up 6 deals for you to choose from. Out of these 6 deals, the first deal (or the first trade) is guaranteed to be an item-to-money trade. The next 4 deals are guaranteed to be money-to-item, and the last deal is guaranteed to be item-to-item. It can only be used in the Overworld. barter The barter command can be considered as a superior version of trade . It will pop up 9 deals for you to choose from. Out of these 9 deals, the first deal is guaranteed to be an item-to-gold trade. The next 7 deals are guaranteed to be gold-to-item, and the last deal is guaranteed to be item-to-item. Generally, barter offers are higher in value since the value cap for barter is bigger than trade . It can only be used in the Nether.","title":"Trading System"},{"location":"econ/trade/#trading-system","text":"The trading system refers to a non-conventional way to convert item into money and vice versa. By the conventional way, it is to browse market (view) , then make any purchases using market buy and market sell . This is very stable; price are always the same unless the bot receives a balance update. However, the trading system has deals that are unconventional to market . These deals are fragile, and you only have around 4 hours before new deals arrive, overriding the old ones. Each deal has a limit a user can use the deal before it's expired. For example, a deal can have up to 20 trades permitted. After using the deal the 20th time, it is locked. The user would have to wait until the deals refresh or take a look at other deals. This limit is tracked per user per offer , not globally. As of now, trade and barter are the commands that use this system. From a design standpoint, they're practically the same. There are multiple deals, they all refresh every 4 hours, they use the same interface to interact with, etc. As for the interface, the trading system will use an embed that list all the offers along with a select menu the user can choose from. The user would then choose the offer they like to deal, which the bot would then perform the action. This cannot be undone. As the user keeps trading, the embed will edit itself to reflect the trading limit per each offer. Once the limit is reached, that offer will no longer appear in the menu, and you'd have to choose a different one or ignore for the menu to time out.","title":"Trading System"},{"location":"econ/trade/#trade","text":"The trade command pops up 6 deals for you to choose from. Out of these 6 deals, the first deal (or the first trade) is guaranteed to be an item-to-money trade. The next 4 deals are guaranteed to be money-to-item, and the last deal is guaranteed to be item-to-item. It can only be used in the Overworld.","title":"trade"},{"location":"econ/trade/#barter","text":"The barter command can be considered as a superior version of trade . It will pop up 9 deals for you to choose from. Out of these 9 deals, the first deal is guaranteed to be an item-to-gold trade. The next 7 deals are guaranteed to be gold-to-item, and the last deal is guaranteed to be item-to-item. Generally, barter offers are higher in value since the value cap for barter is bigger than trade . It can only be used in the Nether.","title":"barter"},{"location":"user/bot/","text":"Bot Category Bot-related Commands changelog [option = stable] Show 10 latest stable changes to the bot. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: option : Additional options. Valid options are dev / development and stable . Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command. help [*name = None] Get help information for the bot. Type: Prefix Command , Slash Command Aliases: h Parameters: name : Category name or command name. Is case-sensitive. info Show information about the bot. Type: Prefix Command , Slash Command Aliases: about info bot Show information about the bot. Type: Prefix Command , Slash Command info host Show information about the machine hosting the bot. Type: Prefix Command , Slash Command info item Show information for an item. Type: Prefix Command , Slash Command Additional Note: Refer to this to have context on this command. info member [member] Show information about yourself or another member. Type: Prefix Command , Slash Command Parameters: member : A Discord member. Default to yourself. info role <role> Show information about a role. Type: Prefix Command , Slash Command Parameters: role : A Discord role. info server Show information about this server. Type: Prefix Command , Slash Command ping Check the bot if it's alive. Type: Prefix Command , Slash Command prefix [new_prefix = None] View or edit the bot prefix for the guild. This only affects Prefix Commands. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: new_prefix : The new prefix. Should not be longer than 5 characters or contain spaces. Additional Info: Author needs to have Manage Server permission. report <type> <*reason> Report a bug or suggest a feature for the bot. Please be constructive. Type: Prefix Command , Slash Command (recommended). Cooldown: 5 seconds after 1 use per user. Parameters: type : The type of report you're making. Either bug or suggest . reason : The content you're trying to send. Last updated on Jul 25, 2022","title":"Bot"},{"location":"user/bot/#bot-category","text":"Bot-related Commands","title":"Bot Category"},{"location":"user/bot/#changelog-option-stable","text":"Show 10 latest stable changes to the bot. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: option : Additional options. Valid options are dev / development and stable . Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command.","title":"changelog [option = stable]"},{"location":"user/bot/#help-name-none","text":"Get help information for the bot. Type: Prefix Command , Slash Command Aliases: h Parameters: name : Category name or command name. Is case-sensitive.","title":"help [*name = None]"},{"location":"user/bot/#info","text":"Show information about the bot. Type: Prefix Command , Slash Command Aliases: about","title":"info"},{"location":"user/bot/#info-bot","text":"Show information about the bot. Type: Prefix Command , Slash Command","title":"info bot"},{"location":"user/bot/#info-host","text":"Show information about the machine hosting the bot. Type: Prefix Command , Slash Command","title":"info host"},{"location":"user/bot/#info-item","text":"Show information for an item. Type: Prefix Command , Slash Command Additional Note: Refer to this to have context on this command.","title":"info item"},{"location":"user/bot/#info-member-member","text":"Show information about yourself or another member. Type: Prefix Command , Slash Command Parameters: member : A Discord member. Default to yourself.","title":"info member [member]"},{"location":"user/bot/#info-role-role","text":"Show information about a role. Type: Prefix Command , Slash Command Parameters: role : A Discord role.","title":"info role &lt;role&gt;"},{"location":"user/bot/#info-server","text":"Show information about this server. Type: Prefix Command , Slash Command","title":"info server"},{"location":"user/bot/#ping","text":"Check the bot if it's alive. Type: Prefix Command , Slash Command","title":"ping"},{"location":"user/bot/#prefix-new_prefix-none","text":"View or edit the bot prefix for the guild. This only affects Prefix Commands. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: new_prefix : The new prefix. Should not be longer than 5 characters or contain spaces. Additional Info: Author needs to have Manage Server permission.","title":"prefix [new_prefix = None]"},{"location":"user/bot/#report-type-reason","text":"Report a bug or suggest a feature for the bot. Please be constructive. Type: Prefix Command , Slash Command (recommended). Cooldown: 5 seconds after 1 use per user. Parameters: type : The type of report you're making. Either bug or suggest . reason : The content you're trying to send. Last updated on Jul 25, 2022","title":"report &lt;type&gt; &lt;*reason&gt;"},{"location":"user/economy/","text":"Economy Category Economy Commands balance View your balance. Type: Prefix Command , Slash Command Aliases: bal barter View and/or perform a barter. Get your gold ready. Type: Prefix Command , Slash Command Cooldown: 5 seconds per 1 use per user. Additional Info: Barters can contains purchases that can't be made via market . Barters will reset every 4 hours. This can only be used when you're in the Nether. bet <number> [money = 1] Bet your money to guess a number in the range 0-50. Don't worry, I won't cheat :) Type: Prefix Command , Slash Command Parameters: number : Your guessing number. Stay within 0-50! money : The amount to bet. You'll either lose this or get 2x back. At least 1. craft <item> [times = 1] Craft various items. Type: Prefix Command , Slash Command (recommended) Cooldown: 1 second per 1 use per user. Parameters: item : The name or alias of the item to craft. times : How many times this command is executed. Default to 1. Max is 100. daily Receive rewards everyday. Don't miss it though! Type: Prefix Command , Slash Command Cooldown: 1 day per 1 use per user (hard). Additional Info: The higher the daily streak, the better your reward will be. If you don't collect your daily within 48 hours since the last time you collect, your streak will be reset to 1. equip <equipment> Equip a tool. Get to work! Type: Prefix Command , Slash Command (recommended) Cooldown: 10 seconds per 1 use per user. Parameters: equipment : The equipment's name or alias to equip. equipments View your current equipments. Type: Prefix Command , Slash Command Cooldown: 10 seconds per 1 use per user. explore Explore the world and get resources by killing monsters. You'll need a sword equipped. Type: Prefix Command , Slash Command Cooldown: 300 seconds per 1 use per user. inventory [view_option = compact] View your inventory. Type: Prefix Command , Slash Command Cooldown: 10 seconds per 1 use per user. Aliases: inv Parameters: view_option : Options to view inventory. Valid options are full , compact , and value . Default to compact . market View public purchases. Type: Prefix Command , Slash Command market view View public purchases. Type: Prefix Command , Slash Command market buy <item> [amount = 1] Buy an item from the market. Type: Prefix Command , Slash Command Parameters: item : The item to purchase. amount : The amount to purchase. Default to 1. market sell <item> [amount = 1] Sell an item from your inventory. Type: Prefix Command , Slash Command Parameters: item : The item to sell. amount : The amount to sell, or 0 to sell all. Default to 1. mine Mine for resources. You'll need a pickaxe equipped. Type: Prefix Command , Slash Command Cooldown: 300 seconds per 1 use per user. trade View and/or perform a trade. Get your money ready. Type: Prefix Command , Slash Command Cooldown: 5 seconds per 1 use per user. Additional Info: Trades can contains purchases that can't be made via market . Trades will reset every 4 hours. This can only be used when you're in the Overworld. travel <world> Travel to another world. Type: Prefix Command , Slash Command Cooldown: 1 day per 1 use per user (hard). Parameters: world : The world to travel to. Valid options are overworld and nether . Last updated on Jul 25, 2022","title":"Economy"},{"location":"user/economy/#economy-category","text":"Economy Commands","title":"Economy Category"},{"location":"user/economy/#balance","text":"View your balance. Type: Prefix Command , Slash Command Aliases: bal","title":"balance"},{"location":"user/economy/#barter","text":"View and/or perform a barter. Get your gold ready. Type: Prefix Command , Slash Command Cooldown: 5 seconds per 1 use per user. Additional Info: Barters can contains purchases that can't be made via market . Barters will reset every 4 hours. This can only be used when you're in the Nether.","title":"barter"},{"location":"user/economy/#bet-number-money-1","text":"Bet your money to guess a number in the range 0-50. Don't worry, I won't cheat :) Type: Prefix Command , Slash Command Parameters: number : Your guessing number. Stay within 0-50! money : The amount to bet. You'll either lose this or get 2x back. At least 1.","title":"bet &lt;number&gt; [money = 1]"},{"location":"user/economy/#craft-item-times-1","text":"Craft various items. Type: Prefix Command , Slash Command (recommended) Cooldown: 1 second per 1 use per user. Parameters: item : The name or alias of the item to craft. times : How many times this command is executed. Default to 1. Max is 100.","title":"craft &lt;item&gt; [times = 1]"},{"location":"user/economy/#daily","text":"Receive rewards everyday. Don't miss it though! Type: Prefix Command , Slash Command Cooldown: 1 day per 1 use per user (hard). Additional Info: The higher the daily streak, the better your reward will be. If you don't collect your daily within 48 hours since the last time you collect, your streak will be reset to 1.","title":"daily"},{"location":"user/economy/#equip-equipment","text":"Equip a tool. Get to work! Type: Prefix Command , Slash Command (recommended) Cooldown: 10 seconds per 1 use per user. Parameters: equipment : The equipment's name or alias to equip.","title":"equip &lt;equipment&gt;"},{"location":"user/economy/#equipments","text":"View your current equipments. Type: Prefix Command , Slash Command Cooldown: 10 seconds per 1 use per user.","title":"equipments"},{"location":"user/economy/#explore","text":"Explore the world and get resources by killing monsters. You'll need a sword equipped. Type: Prefix Command , Slash Command Cooldown: 300 seconds per 1 use per user.","title":"explore"},{"location":"user/economy/#inventory-view_option-compact","text":"View your inventory. Type: Prefix Command , Slash Command Cooldown: 10 seconds per 1 use per user. Aliases: inv Parameters: view_option : Options to view inventory. Valid options are full , compact , and value . Default to compact .","title":"inventory [view_option = compact]"},{"location":"user/economy/#market","text":"View public purchases. Type: Prefix Command , Slash Command","title":"market"},{"location":"user/economy/#market-view","text":"View public purchases. Type: Prefix Command , Slash Command","title":"market view"},{"location":"user/economy/#market-buy-item-amount-1","text":"Buy an item from the market. Type: Prefix Command , Slash Command Parameters: item : The item to purchase. amount : The amount to purchase. Default to 1.","title":"market buy &lt;item&gt; [amount = 1]"},{"location":"user/economy/#market-sell-item-amount-1","text":"Sell an item from your inventory. Type: Prefix Command , Slash Command Parameters: item : The item to sell. amount : The amount to sell, or 0 to sell all. Default to 1.","title":"market sell &lt;item&gt; [amount = 1]"},{"location":"user/economy/#mine","text":"Mine for resources. You'll need a pickaxe equipped. Type: Prefix Command , Slash Command Cooldown: 300 seconds per 1 use per user.","title":"mine"},{"location":"user/economy/#trade","text":"View and/or perform a trade. Get your money ready. Type: Prefix Command , Slash Command Cooldown: 5 seconds per 1 use per user. Additional Info: Trades can contains purchases that can't be made via market . Trades will reset every 4 hours. This can only be used when you're in the Overworld.","title":"trade"},{"location":"user/economy/#travel-world","text":"Travel to another world. Type: Prefix Command , Slash Command Cooldown: 1 day per 1 use per user (hard). Parameters: world : The world to travel to. Valid options are overworld and nether . Last updated on Jul 25, 2022","title":"travel &lt;world&gt;"},{"location":"user/fun/","text":"Fun Category Fun Commands copypasta <type> My favorite copypasta. Type: Prefix Command Cooldown: 10 seconds after 1 use per user. Parameters: type : Which copypasta to show. Dig into the bot's code to see available options ;) dadjoke Give you a dad joke. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Aliases: ina-of-the-mountain-what-is-your-wisdom dice Roll a 6-face dice for you. Type: Prefix Command , Slash Command echo <content> Echo echo echo echo. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per user. Parameters: content : The string to echo. Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command. how <measure_unit> <*target> An ultimate measurement to measure everything. Type: Prefix Command , Slash Command (recommended) Parameters: measure_unit : The unit to measure. target : The target to measure. mock <*text> tuRn A teXT INtO MOCk teXt. Type: Prefix Command , Slash Command (recommended) Cooldown: 3 seconds after 1 use per user. Parameters: text : Text to mock. Additional Info: The text will be sent through DM if it exceeds 1500 characters. pekofy Pekofy a message peko. Type: Message Command Cooldown: 5 seconds after 1 use per user. speak <*content> Speak the message. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per user. Parameters: content : The string to speak. Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command. uwu <*text> Turn a text into uwu text. Type: Prefix Command , Slash Command , Message Command (recommended) Cooldown: 3 seconds after 1 use per user. Parameters: text : Text to uwuify. Last updated on Jul 25, 2022","title":"Fun"},{"location":"user/fun/#fun-category","text":"Fun Commands","title":"Fun Category"},{"location":"user/fun/#copypasta-type","text":"My favorite copypasta. Type: Prefix Command Cooldown: 10 seconds after 1 use per user. Parameters: type : Which copypasta to show. Dig into the bot's code to see available options ;)","title":"copypasta &lt;type&gt;"},{"location":"user/fun/#dadjoke","text":"Give you a dad joke. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Aliases: ina-of-the-mountain-what-is-your-wisdom","title":"dadjoke"},{"location":"user/fun/#dice","text":"Roll a 6-face dice for you. Type: Prefix Command , Slash Command","title":"dice"},{"location":"user/fun/#echo-content","text":"Echo echo echo echo. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per user. Parameters: content : The string to echo. Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command.","title":"echo &lt;content&gt;"},{"location":"user/fun/#how-measure_unit-target","text":"An ultimate measurement to measure everything. Type: Prefix Command , Slash Command (recommended) Parameters: measure_unit : The unit to measure. target : The target to measure.","title":"how &lt;measure_unit&gt; &lt;*target&gt;"},{"location":"user/fun/#mock-text","text":"tuRn A teXT INtO MOCk teXt. Type: Prefix Command , Slash Command (recommended) Cooldown: 3 seconds after 1 use per user. Parameters: text : Text to mock. Additional Info: The text will be sent through DM if it exceeds 1500 characters.","title":"mock &lt;*text&gt;"},{"location":"user/fun/#pekofy","text":"Pekofy a message peko. Type: Message Command Cooldown: 5 seconds after 1 use per user.","title":"pekofy"},{"location":"user/fun/#speak-content","text":"Speak the message. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per user. Parameters: content : The string to speak. Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command.","title":"speak &lt;*content&gt;"},{"location":"user/fun/#uwu-text","text":"Turn a text into uwu text. Type: Prefix Command , Slash Command , Message Command (recommended) Cooldown: 3 seconds after 1 use per user. Parameters: text : Text to uwuify. Last updated on Jul 25, 2022","title":"uwu &lt;*text&gt;"},{"location":"user/logger/","text":"Logs Category Logging commands. log-set Set a channel as a log channel. Type: Prefix Command Additional Info: This command doesn't do anything. Please use the subcommands. log-set all [channel = None] Set a channel to dump all the logs. This automatically enables logging system. Type: Prefix Command , Slash Command Parameters: channel : The Discord channel to dump all the logs. Default to current channel. Additional Info: Author needs to have Manage Server . log-set option <logging_option> Enable a logging option. Type: Prefix Command , Slash Command (recommended) Parameters: logging_option : Log type to turn on. Check log-view to see all options. Additional Info: Author needs to have Manage Server . It is recommended to use the Slash Command version of the command. log-disable Disable logging or part of the logging system. Type: Prefix Command Additional Info: This command doesn't do anything. Please use the subcommands. log-disable all Disable logging system. Type: Prefix Command , Slash Command log-disable option <logging_option> Disable a logging option. Type: Prefix Command , Slash Command (recommended) Parameters: logging_option : Log type to turn off. Check log-view to see all options. Additional Info: Author needs to have Manage Server . It is recommended to use the Slash Command version of the command. log-view View all log settings. Type: Prefix Command , Slash Command Additional Info: Author needs to have Manage Server . Last updated on Apr 1, 2022","title":"Logs"},{"location":"user/logger/#logs-category","text":"Logging commands.","title":"Logs Category"},{"location":"user/logger/#log-set","text":"Set a channel as a log channel. Type: Prefix Command Additional Info: This command doesn't do anything. Please use the subcommands.","title":"log-set"},{"location":"user/logger/#log-set-all-channel-none","text":"Set a channel to dump all the logs. This automatically enables logging system. Type: Prefix Command , Slash Command Parameters: channel : The Discord channel to dump all the logs. Default to current channel. Additional Info: Author needs to have Manage Server .","title":"log-set all [channel = None]"},{"location":"user/logger/#log-set-option-logging_option","text":"Enable a logging option. Type: Prefix Command , Slash Command (recommended) Parameters: logging_option : Log type to turn on. Check log-view to see all options. Additional Info: Author needs to have Manage Server . It is recommended to use the Slash Command version of the command.","title":"log-set option &lt;logging_option&gt;"},{"location":"user/logger/#log-disable","text":"Disable logging or part of the logging system. Type: Prefix Command Additional Info: This command doesn't do anything. Please use the subcommands.","title":"log-disable"},{"location":"user/logger/#log-disable-all","text":"Disable logging system. Type: Prefix Command , Slash Command","title":"log-disable all"},{"location":"user/logger/#log-disable-option-logging_option","text":"Disable a logging option. Type: Prefix Command , Slash Command (recommended) Parameters: logging_option : Log type to turn off. Check log-view to see all options. Additional Info: Author needs to have Manage Server . It is recommended to use the Slash Command version of the command.","title":"log-disable option &lt;logging_option&gt;"},{"location":"user/logger/#log-view","text":"View all log settings. Type: Prefix Command , Slash Command Additional Info: Author needs to have Manage Server . Last updated on Apr 1, 2022","title":"log-view"},{"location":"user/music/","text":"Music Category Music commands. join [voice_channel = None] Join a voice channel. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: voice_channel : The voice channel to join. Default to the VC you're in. Aliases: connect leave Leave the voice channel. Type: Prefix Command , Slash Command Aliases: dc (recommended), disconnect np Get info about the current track. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild. Aliases: now_playing play <*query> Play the query or add it to the queue. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 5 uses per guild. Parameters: query : The query to play (url, name, etc.) Aliases: p (recommended) pause Toggle pausing the player. Type: Prefix Command , Slash Command c search <*track> Search and return 10 relevant results. You can then copy the desired link into play . Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild. Parameters: track : Keywords to search. Example: blend w . seek <position> Jump to the provided timestamp. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild. Parameters: position : Timestamp to jump to. repeat Toggle repeating the track. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild. volume <vol> Set the volume of the player. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: vol : Volume to set (0-200). Additional Info: It's recommended to use the built-in feature User Volume instead of this command. queue Display the song queue. Type: Prefix Command Cooldown: 2 seconds after 1 use per guild. Aliases: q (recommended) queue view Display the song queue. This exists for Slash Commands. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild. queue clear Clear the entire queue but the current track. Type: Prefix Command , Slash Command queue shuffle Shuffle the queue. Type: Prefix Command , Slash Command queue loop Toggle queue loop. Type: Prefix Command , Slash Command queue move <from_index> <to_index> Move a track in queue to a new order index. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: from_index : The index in the queue to move. to_index : The index in the queue where you want the track to be. queue remove <index> Remove a track in the queue. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: index : The index in the queue to remove. skip Skip the current track. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild. Aliases: s (recommended) stop Stop the player. Type: Prefix Command , Slash Command Last updated on Apr 1, 2022","title":"Music"},{"location":"user/music/#music-category","text":"Music commands.","title":"Music Category"},{"location":"user/music/#join-voice_channel-none","text":"Join a voice channel. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: voice_channel : The voice channel to join. Default to the VC you're in. Aliases: connect","title":"join [voice_channel = None]"},{"location":"user/music/#leave","text":"Leave the voice channel. Type: Prefix Command , Slash Command Aliases: dc (recommended), disconnect","title":"leave"},{"location":"user/music/#np","text":"Get info about the current track. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild. Aliases: now_playing","title":"np"},{"location":"user/music/#play-query","text":"Play the query or add it to the queue. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 5 uses per guild. Parameters: query : The query to play (url, name, etc.) Aliases: p (recommended)","title":"play &lt;*query&gt;"},{"location":"user/music/#pause","text":"Toggle pausing the player. Type: Prefix Command , Slash Command c","title":"pause"},{"location":"user/music/#search-track","text":"Search and return 10 relevant results. You can then copy the desired link into play . Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild. Parameters: track : Keywords to search. Example: blend w .","title":"search &lt;*track&gt;"},{"location":"user/music/#seek-position","text":"Jump to the provided timestamp. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild. Parameters: position : Timestamp to jump to.","title":"seek &lt;position&gt;"},{"location":"user/music/#repeat","text":"Toggle repeating the track. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild.","title":"repeat"},{"location":"user/music/#volume-vol","text":"Set the volume of the player. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: vol : Volume to set (0-200). Additional Info: It's recommended to use the built-in feature User Volume instead of this command.","title":"volume &lt;vol&gt;"},{"location":"user/music/#queue","text":"Display the song queue. Type: Prefix Command Cooldown: 2 seconds after 1 use per guild. Aliases: q (recommended)","title":"queue"},{"location":"user/music/#queue-view","text":"Display the song queue. This exists for Slash Commands. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild.","title":"queue view"},{"location":"user/music/#queue-clear","text":"Clear the entire queue but the current track. Type: Prefix Command , Slash Command","title":"queue clear"},{"location":"user/music/#queue-shuffle","text":"Shuffle the queue. Type: Prefix Command , Slash Command","title":"queue shuffle"},{"location":"user/music/#queue-loop","text":"Toggle queue loop. Type: Prefix Command , Slash Command","title":"queue loop"},{"location":"user/music/#queue-move-from_index-to_index","text":"Move a track in queue to a new order index. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: from_index : The index in the queue to move. to_index : The index in the queue where you want the track to be.","title":"queue move &lt;from_index&gt; &lt;to_index&gt;"},{"location":"user/music/#queue-remove-index","text":"Remove a track in the queue. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: index : The index in the queue to remove.","title":"queue remove &lt;index&gt;"},{"location":"user/music/#skip","text":"Skip the current track. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild. Aliases: s (recommended)","title":"skip"},{"location":"user/music/#stop","text":"Stop the player. Type: Prefix Command , Slash Command Last updated on Apr 1, 2022","title":"stop"},{"location":"user/utilities/","text":"Utilities Category Utility Commands. base-convert <from_base> <to_base> <number> Convert a number to the desired base. Type: Prefix Command , Slash Command Parameters: from_base : The base the number you're converting. Valid options are 2 , 8 , 10 , and 16 . to_base : The base you want to convert to. Valid options are the same as from_base . number : The number you're converting. calc <expression> Calculate a math expression. Type: Prefix Command , Slash Command Parameters: expression : The math expression. Additional Info: Rounding errors, along with other debatable values such as 0^0 is incorrect due to language limitation. embed Send an embed. Additional Info: This command only works with subcommands. embed from-json <raw_embed> Send an embed from a JSON object. Check out https://embedbuilder.nadekobot.me/ for easier time. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: raw_embed : The embed in JSON format. embed to-json <message_id> [channel] Take the embed from a message and convert it to a JSON object. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: message_id : The message ID. The bot can't get a message that's too old. channel : The channel the message is in. Default to the current channel. Additional Info: This is useful when you want to change slightly from an existing embed. embed simple [title = None] [description = None] [color = green] [channel = None] Create and send a simple embed. Useful for quick embeds. Type: Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: title : The title of the embed. description : The description of the embed. color : Your choice of color. Default to green. channel : The channel to send this embed. Default to the current one. Additional Info: This is an alternative to embed interactive . Either title or description must be non-empty. embed interactive Create a simple embed with prompts. Type: Prefix Command Cooldown: 3 seconds after 1 use per user. Additional Info: Bot needs to have Manage Messages . This is an alternative to embed simple . embed interactive2 Create a simple embed with visual prompts. Type: Prefix Command Cooldown: 3 seconds after 1 use per user. Additional Info: Bot needs to have Manage Messages . This is an alternative to embed simple . profile [member = None] Information about yourself or another member. Type: Prefix Command , Slash Command Parameters: member : A Discord member. Default to you. remindme Create a reminder. Make sure your DM is open to the bot. Type: None Aliases: rmd , notify , timer Additional Info: This command only works with subcommands. remindme create <interval> <*message> Create a reminder. Make sure your DM is open to the bot. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: interval : How long until the bot reminds you. Must be between 1 minute and 30 days. Example: 3d2m1s message : The message the bot will send after the interval. Additional Info: An interval of less than 120 seconds is considered to be a \"short reminder\". remindme view View all your long reminders. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Additional Info: Due to optimization, this command won't display short reminders. remindme remove <remind_id> Remove a long reminder. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: remind_id : The reminder's id. You can find it in remindme view . Additional Info: Due to optimization, this command won't remove short reminders. urban <*term> Search a term on urbandictionary. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: term : The term to search. Example: rickroll . weather <*city_name> Display weather information for a location. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: city_name : The city to check. Example: Paris . Last updated on Jul 25, 2022","title":"Utilities"},{"location":"user/utilities/#utilities-category","text":"Utility Commands.","title":"Utilities Category"},{"location":"user/utilities/#base-convert-from_base-to_base-number","text":"Convert a number to the desired base. Type: Prefix Command , Slash Command Parameters: from_base : The base the number you're converting. Valid options are 2 , 8 , 10 , and 16 . to_base : The base you want to convert to. Valid options are the same as from_base . number : The number you're converting.","title":"base-convert &lt;from_base&gt; &lt;to_base&gt; &lt;number&gt;"},{"location":"user/utilities/#calc-expression","text":"Calculate a math expression. Type: Prefix Command , Slash Command Parameters: expression : The math expression. Additional Info: Rounding errors, along with other debatable values such as 0^0 is incorrect due to language limitation.","title":"calc &lt;expression&gt;"},{"location":"user/utilities/#embed","text":"Send an embed. Additional Info: This command only works with subcommands.","title":"embed"},{"location":"user/utilities/#embed-from-json-raw_embed","text":"Send an embed from a JSON object. Check out https://embedbuilder.nadekobot.me/ for easier time. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: raw_embed : The embed in JSON format.","title":"embed from-json &lt;raw_embed&gt;"},{"location":"user/utilities/#embed-to-json-message_id-channel","text":"Take the embed from a message and convert it to a JSON object. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: message_id : The message ID. The bot can't get a message that's too old. channel : The channel the message is in. Default to the current channel. Additional Info: This is useful when you want to change slightly from an existing embed.","title":"embed to-json &lt;message_id&gt; [channel]"},{"location":"user/utilities/#embed-simple-title-none-description-none-color-green-channel-none","text":"Create and send a simple embed. Useful for quick embeds. Type: Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: title : The title of the embed. description : The description of the embed. color : Your choice of color. Default to green. channel : The channel to send this embed. Default to the current one. Additional Info: This is an alternative to embed interactive . Either title or description must be non-empty.","title":"embed simple [title = None] [description = None] [color = green] [channel = None]"},{"location":"user/utilities/#embed-interactive","text":"Create a simple embed with prompts. Type: Prefix Command Cooldown: 3 seconds after 1 use per user. Additional Info: Bot needs to have Manage Messages . This is an alternative to embed simple .","title":"embed interactive"},{"location":"user/utilities/#embed-interactive2","text":"Create a simple embed with visual prompts. Type: Prefix Command Cooldown: 3 seconds after 1 use per user. Additional Info: Bot needs to have Manage Messages . This is an alternative to embed simple .","title":"embed interactive2"},{"location":"user/utilities/#profile-member-none","text":"Information about yourself or another member. Type: Prefix Command , Slash Command Parameters: member : A Discord member. Default to you.","title":"profile [member = None]"},{"location":"user/utilities/#remindme","text":"Create a reminder. Make sure your DM is open to the bot. Type: None Aliases: rmd , notify , timer Additional Info: This command only works with subcommands.","title":"remindme"},{"location":"user/utilities/#remindme-create-interval-message","text":"Create a reminder. Make sure your DM is open to the bot. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: interval : How long until the bot reminds you. Must be between 1 minute and 30 days. Example: 3d2m1s message : The message the bot will send after the interval. Additional Info: An interval of less than 120 seconds is considered to be a \"short reminder\".","title":"remindme create &lt;interval&gt; &lt;*message&gt;"},{"location":"user/utilities/#remindme-view","text":"View all your long reminders. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Additional Info: Due to optimization, this command won't display short reminders.","title":"remindme view"},{"location":"user/utilities/#remindme-remove-remind_id","text":"Remove a long reminder. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: remind_id : The reminder's id. You can find it in remindme view . Additional Info: Due to optimization, this command won't remove short reminders.","title":"remindme remove &lt;remind_id&gt;"},{"location":"user/utilities/#urban-term","text":"Search a term on urbandictionary. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: term : The term to search. Example: rickroll .","title":"urban &lt;*term&gt;"},{"location":"user/utilities/#weather-city_name","text":"Display weather information for a location. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: city_name : The city to check. Example: Paris . Last updated on Jul 25, 2022","title":"weather &lt;*city_name&gt;"}]}