{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MichaelBot Documentation Welcome to MichaelBot's documentation. This documents all the bot's commands along with its features. For general purposes, please refers to the Commands heading. For those who are interested in some of the more secret stuffs, feel free to look at the bot source code. Below are some of the topics that are might not obvious from a user perspective. Prefix vs Slash MichaelBot has 2 main types of command: prefix command and slash command. Prefix command is the OG \"command system\" that's been widely implemented for pretty much every single bot. Slash command is the official command system in Discord that's been implemented fairly recently. MichaelBot tries to balance these 2, but there are some pros and cons to them: Slash > Prefix: Is officially supported by Discord and is super newbie-friendly. Can use Tab to autocomplete. This makes it somewhat unnecessary for the user to remember the arguments. This is excellent when the user need to input some sort of choice into the command. Arguments are generally easier to deal with since Discord do all the necessary text parsing. Prefix commands don't work without verifying the bot after reaching 100 servers. This is technically not the case for slash commands. Prefix > Slash: Is familiar to a lot of people. Can alias commands. This allows users to smash commands super fast. Slash commands have a hard limit of 100 commands per bot. Prefix commands don't have such thing. Slash commands don't have hidden commands; all commands are public. Slash commands' parent can't be invoked ( queue cannot be invoked if a subcommand queue clear is registered). This is not the case for prefix commands. With these pros and cons, sometimes some commands are exclusive to slash or prefix only. This will be mentioned in each command entry. Besides slash commands, Discord also have user commands and message commands . However, the bot rarely uses them for important features, so you can safely ignore them for the most part. By default, I'll recommend you to use the Prefix version of the command. However, in some cases, Slash command might performs the job easier. I'll sometimes put my preferences if that's the case. Cooldown Some commands have cooldown. This is to ensure the bot has time to do things first before it is invoked again. This is quite common for commands that deal with heavy stuffs such as music or communicating with servers. Some cooldown are simply to avoid spamming potential. Cooldown is applied to a certain target. There are 4 targets a cooldown can apply: A user. This means the user can't execute the command within an interval. A channel. This means the command can't be executed in the same channel within an interval. A guild. This means the command can't be executed in the same guild within an interval. Everywhere. This means the command can't be executed by anyone within an interval. Technical: Most cooldown are soft; they can be reset by resetting the bot or use some commands to reset. Some cooldown are hard-coded; they're saved within the database and you might need to edit the table (and the cache) to remove it. Parameters Many commands require parameters to be passed in. Although the help command already provide a good amount of info, it is still limited because it is auto-generated. Note that these are mostly applied to Prefix Commands; Slash Commands is super user-friendly so you might not even need to care about most of these stuffs. Take the command signature foo <bar> [bar2 = bla] [bar3 = 1] [*baz = None] All parameters are separated by space. Which means if you invoke foo 1 2 3 , it'll store as bar = 1, bar2 = 2, bar3 = 3 and not bar = 1 2 3 . <parameter> means this parameter is required. That means bar is a required parameter. [parameter] or [parameter = None] means this parameter is optional. That means bar2 , bar3 , and baz are optional parameters. parameter = sth means the default value of a parameter is set to whatever sth is. This usually appears in optional parameters. *parameter means it'll consume all the remaining text. This means if you invoke foo 1 2 3 4 5 6 , it'll store as bar = 1, bar2 = 2, bar3 = 3, baz = 4 5 6 . Slash Commands have none of the above problem since parameters are separated by Tab, and they also have indication which parameters are required. Parameter Type There are several types the bot will work with. The most common one is plain text, followed by numbers. These are pretty straightforward. The less obvious types are such as a Discord User or a Discord Guild. There are several ways to pass in such types, which will be shown in this table. Type Pass into Prefix Commands Pass into Slash Commands Plain text Literally any text you type. Literally any text you type. Numbers Literally any numbers you type. Literally any numbers you type. Discord User/Member/Channel/Role ID > Mention > Name > Nickname Choose from the option (you might need to partially type the name for it to show up). Discord Guild ID ID Time 1d10h10m10s or hh:mm:ss 1d10h10m10s or hh:mm:ss","title":"Home"},{"location":"#welcome-to-michaelbot-documentation","text":"Welcome to MichaelBot's documentation. This documents all the bot's commands along with its features. For general purposes, please refers to the Commands heading. For those who are interested in some of the more secret stuffs, feel free to look at the bot source code. Below are some of the topics that are might not obvious from a user perspective.","title":"Welcome to MichaelBot Documentation"},{"location":"#prefix-vs-slash","text":"MichaelBot has 2 main types of command: prefix command and slash command. Prefix command is the OG \"command system\" that's been widely implemented for pretty much every single bot. Slash command is the official command system in Discord that's been implemented fairly recently. MichaelBot tries to balance these 2, but there are some pros and cons to them: Slash > Prefix: Is officially supported by Discord and is super newbie-friendly. Can use Tab to autocomplete. This makes it somewhat unnecessary for the user to remember the arguments. This is excellent when the user need to input some sort of choice into the command. Arguments are generally easier to deal with since Discord do all the necessary text parsing. Prefix commands don't work without verifying the bot after reaching 100 servers. This is technically not the case for slash commands. Prefix > Slash: Is familiar to a lot of people. Can alias commands. This allows users to smash commands super fast. Slash commands have a hard limit of 100 commands per bot. Prefix commands don't have such thing. Slash commands don't have hidden commands; all commands are public. Slash commands' parent can't be invoked ( queue cannot be invoked if a subcommand queue clear is registered). This is not the case for prefix commands. With these pros and cons, sometimes some commands are exclusive to slash or prefix only. This will be mentioned in each command entry. Besides slash commands, Discord also have user commands and message commands . However, the bot rarely uses them for important features, so you can safely ignore them for the most part. By default, I'll recommend you to use the Prefix version of the command. However, in some cases, Slash command might performs the job easier. I'll sometimes put my preferences if that's the case.","title":"Prefix vs Slash"},{"location":"#cooldown","text":"Some commands have cooldown. This is to ensure the bot has time to do things first before it is invoked again. This is quite common for commands that deal with heavy stuffs such as music or communicating with servers. Some cooldown are simply to avoid spamming potential. Cooldown is applied to a certain target. There are 4 targets a cooldown can apply: A user. This means the user can't execute the command within an interval. A channel. This means the command can't be executed in the same channel within an interval. A guild. This means the command can't be executed in the same guild within an interval. Everywhere. This means the command can't be executed by anyone within an interval. Technical: Most cooldown are soft; they can be reset by resetting the bot or use some commands to reset. Some cooldown are hard-coded; they're saved within the database and you might need to edit the table (and the cache) to remove it.","title":"Cooldown"},{"location":"#parameters","text":"Many commands require parameters to be passed in. Although the help command already provide a good amount of info, it is still limited because it is auto-generated. Note that these are mostly applied to Prefix Commands; Slash Commands is super user-friendly so you might not even need to care about most of these stuffs. Take the command signature foo <bar> [bar2 = bla] [bar3 = 1] [*baz = None] All parameters are separated by space. Which means if you invoke foo 1 2 3 , it'll store as bar = 1, bar2 = 2, bar3 = 3 and not bar = 1 2 3 . <parameter> means this parameter is required. That means bar is a required parameter. [parameter] or [parameter = None] means this parameter is optional. That means bar2 , bar3 , and baz are optional parameters. parameter = sth means the default value of a parameter is set to whatever sth is. This usually appears in optional parameters. *parameter means it'll consume all the remaining text. This means if you invoke foo 1 2 3 4 5 6 , it'll store as bar = 1, bar2 = 2, bar3 = 3, baz = 4 5 6 . Slash Commands have none of the above problem since parameters are separated by Tab, and they also have indication which parameters are required.","title":"Parameters"},{"location":"#parameter-type","text":"There are several types the bot will work with. The most common one is plain text, followed by numbers. These are pretty straightforward. The less obvious types are such as a Discord User or a Discord Guild. There are several ways to pass in such types, which will be shown in this table. Type Pass into Prefix Commands Pass into Slash Commands Plain text Literally any text you type. Literally any text you type. Numbers Literally any numbers you type. Literally any numbers you type. Discord User/Member/Channel/Role ID > Mention > Name > Nickname Choose from the option (you might need to partially type the name for it to show up). Discord Guild ID ID Time 1d10h10m10s or hh:mm:ss 1d10h10m10s or hh:mm:ss","title":"Parameter Type"},{"location":"INSTALLATION/","text":"Installation All instructions are geared towards Ubuntu (Kubuntu specifically) because that's what I use. Instructions for Windows is available, but be aware I don't test them often. Prerequisites Requires: Python 3.8+ (ideally latest), Git, pip , virtualenv / python3-venv under Python. Optional: Lavalink (more information below), Docker (for Lavalink), PostgreSQL (more information below). About Lavalink Lavalink is optional for the bot. If you don't plan to use the music functionality, you can simply edit main.py the EXTENSION variable to exclude categories.music . Then you can completely ignore this section and move on. Otherwise, you'll need to finish setting up Lavalink and get it running. There are 2 options to host Lavalink: you can host it directly using the .jar file or use Docker. I personally switched to Docker recently so I won't tell which one you should go. In either cases, you'll need a file application.yml to configure the server. An example is provided in ./lib/Lavalink . You'll also need Java 13+, which can be downloaded here or somewhere else (there are a billion places to download a billion java versions I'm not gonna even bother). Running Lavalink (.jar) Download Lavalink.jar , or use the one currently in ./lib/Lavalink/ . Run java -jar <path to Lavalink.jar> . Lavalink server should start running now. By default, it'll run on localhost:2333 unless you configure it in application.yml . Running Lavalink (Docker) This is not tested on Windows. Download Docker. Here is the guide for Ubuntu. Run docker pull fredboat/lavalink:master . This will pull the stable image. Run docker run --name <name> -p <port>:<port> -d -v <path-to-application.yml>:/opt/Lavalink/application.yml fredboat/lavalink:master , where <name> is the name of the process, <port> is the port the server is on, and <path-to-application.yml> is the absolute path to the config file. To stop the process, run docker stop <name> . About PostgreSQL PostgreSQL is optional for the bot, but is strongly recommended. Without a database, some features will be missing, such as prefix config, blacklisting, logging, etc. In addition to that, although the code can handle no database scenario on its own, it is not well-tested for such cases, so there might be some edge cases here and there. This is a pretty fine guide to install PostgreSQL on Ubuntu: https://linuxhint.com/postgresql_installation_guide_ubuntu_20-04/ After installing Postgres, create a database and check the connection info. You'll need this later. Build Instructions The following instructions has been tested with bash and Powershell . You'll need to replace the python command mentioned below with whatever your system has ( python3 or python3.x for Linux, python for Windows). Clone the repository into the current folder. git clone https://github.com/MikeJollie2707/MichaelBot.git . Activate virtual environment and install libraries. # Linux python -m pip venv venv source ./venv/bin/activate python -m pip install -r requirement.txt # Windows # From my experience, / still works, but if it doesn't, use \\ python -m pip venv venv ./venv/Scripts/Activate.ps1 # This is important; uvloop is not available on Windows. python -m pip install -r win_requirement.txt Configure the bot. Inside ./setup , create a .json file. I'll call it secret.json . // secret.json { \"token\": \"Bot token here\", \"host\": \"localhost\", \"port\": 5432, \"database\": \"database name\", \"user\": \"user name\", \"password\": \"password\", \"weather_api_key\": \"api key\" } If you don't have a database and/or weather_api_key , leave them as dummy values ( \"\" and 0 ). Within ./setup , there's also another file called config.json . The file has the following structure: // config.json { \"BotIndex\": { \"version\": \"Required\", \"description\": \"Required\", \"prefix\": \"Required\", \"launch_options\": \"Optional\", \"default_guilds\": [123456], \"secret\": \"secret.json\" } } BotIndex : the index you'll refer to the bot when you launch it from the terminal. Usually the bot name without space. version : the bot version. Just fake something up like 69.69beta if you don't really care about this. description : the bot's about me. Discord doesn't have a way to retrieve this so this is required for now. prefix : the bot's default prefix. launch_options : an optional string to pass into the bot when it launches. This mostly affects terminal logging. Acceptable options are: -d or --debug : Launch the bot in debug mode. This will set the log level to DEBUG but more importantly, it'll apply slash commands to default_guilds immediately (no need to wait at most 1 hour). If this is passed, default_guilds must also be non-empty. -q or --quiet : Launch the bot in quiet mode. This will disable terminal logging, but any uncaught exceptions will still spawn in stderr . default_guilds : a list of guilds' ids to apply slash commands immediately. This is required if the bot is launched in debug mode. secret : the file name that contains your bot's secret like token. You can view my bot config as an example. (Optional) If you have a database, you'll need to set up the tables beforehand. You only need to do this once. python dbsetup.py BotIndex Run the bot. python -OO main.py BotIndex What's next? For personal convenience, I also have a template script to run the bot in different modes. You can check it out at run.sh (Kubuntu) or run.ps1 (Windows). It'll only run the bot. You'll need to run Lavalink and PostgreSQL on your own.","title":"Installation"},{"location":"INSTALLATION/#installation","text":"All instructions are geared towards Ubuntu (Kubuntu specifically) because that's what I use. Instructions for Windows is available, but be aware I don't test them often.","title":"Installation"},{"location":"INSTALLATION/#prerequisites","text":"Requires: Python 3.8+ (ideally latest), Git, pip , virtualenv / python3-venv under Python. Optional: Lavalink (more information below), Docker (for Lavalink), PostgreSQL (more information below).","title":"Prerequisites"},{"location":"INSTALLATION/#about-lavalink","text":"Lavalink is optional for the bot. If you don't plan to use the music functionality, you can simply edit main.py the EXTENSION variable to exclude categories.music . Then you can completely ignore this section and move on. Otherwise, you'll need to finish setting up Lavalink and get it running. There are 2 options to host Lavalink: you can host it directly using the .jar file or use Docker. I personally switched to Docker recently so I won't tell which one you should go. In either cases, you'll need a file application.yml to configure the server. An example is provided in ./lib/Lavalink . You'll also need Java 13+, which can be downloaded here or somewhere else (there are a billion places to download a billion java versions I'm not gonna even bother).","title":"About Lavalink"},{"location":"INSTALLATION/#running-lavalink-jar","text":"Download Lavalink.jar , or use the one currently in ./lib/Lavalink/ . Run java -jar <path to Lavalink.jar> . Lavalink server should start running now. By default, it'll run on localhost:2333 unless you configure it in application.yml .","title":"Running Lavalink (.jar)"},{"location":"INSTALLATION/#running-lavalink-docker","text":"This is not tested on Windows. Download Docker. Here is the guide for Ubuntu. Run docker pull fredboat/lavalink:master . This will pull the stable image. Run docker run --name <name> -p <port>:<port> -d -v <path-to-application.yml>:/opt/Lavalink/application.yml fredboat/lavalink:master , where <name> is the name of the process, <port> is the port the server is on, and <path-to-application.yml> is the absolute path to the config file. To stop the process, run docker stop <name> .","title":"Running Lavalink (Docker)"},{"location":"INSTALLATION/#about-postgresql","text":"PostgreSQL is optional for the bot, but is strongly recommended. Without a database, some features will be missing, such as prefix config, blacklisting, logging, etc. In addition to that, although the code can handle no database scenario on its own, it is not well-tested for such cases, so there might be some edge cases here and there. This is a pretty fine guide to install PostgreSQL on Ubuntu: https://linuxhint.com/postgresql_installation_guide_ubuntu_20-04/ After installing Postgres, create a database and check the connection info. You'll need this later.","title":"About PostgreSQL"},{"location":"INSTALLATION/#build-instructions","text":"The following instructions has been tested with bash and Powershell . You'll need to replace the python command mentioned below with whatever your system has ( python3 or python3.x for Linux, python for Windows). Clone the repository into the current folder. git clone https://github.com/MikeJollie2707/MichaelBot.git . Activate virtual environment and install libraries. # Linux python -m pip venv venv source ./venv/bin/activate python -m pip install -r requirement.txt # Windows # From my experience, / still works, but if it doesn't, use \\ python -m pip venv venv ./venv/Scripts/Activate.ps1 # This is important; uvloop is not available on Windows. python -m pip install -r win_requirement.txt Configure the bot. Inside ./setup , create a .json file. I'll call it secret.json . // secret.json { \"token\": \"Bot token here\", \"host\": \"localhost\", \"port\": 5432, \"database\": \"database name\", \"user\": \"user name\", \"password\": \"password\", \"weather_api_key\": \"api key\" } If you don't have a database and/or weather_api_key , leave them as dummy values ( \"\" and 0 ). Within ./setup , there's also another file called config.json . The file has the following structure: // config.json { \"BotIndex\": { \"version\": \"Required\", \"description\": \"Required\", \"prefix\": \"Required\", \"launch_options\": \"Optional\", \"default_guilds\": [123456], \"secret\": \"secret.json\" } } BotIndex : the index you'll refer to the bot when you launch it from the terminal. Usually the bot name without space. version : the bot version. Just fake something up like 69.69beta if you don't really care about this. description : the bot's about me. Discord doesn't have a way to retrieve this so this is required for now. prefix : the bot's default prefix. launch_options : an optional string to pass into the bot when it launches. This mostly affects terminal logging. Acceptable options are: -d or --debug : Launch the bot in debug mode. This will set the log level to DEBUG but more importantly, it'll apply slash commands to default_guilds immediately (no need to wait at most 1 hour). If this is passed, default_guilds must also be non-empty. -q or --quiet : Launch the bot in quiet mode. This will disable terminal logging, but any uncaught exceptions will still spawn in stderr . default_guilds : a list of guilds' ids to apply slash commands immediately. This is required if the bot is launched in debug mode. secret : the file name that contains your bot's secret like token. You can view my bot config as an example. (Optional) If you have a database, you'll need to set up the tables beforehand. You only need to do this once. python dbsetup.py BotIndex Run the bot. python -OO main.py BotIndex","title":"Build Instructions"},{"location":"INSTALLATION/#whats-next","text":"For personal convenience, I also have a template script to run the bot in different modes. You can check it out at run.sh (Kubuntu) or run.ps1 (Windows). It'll only run the bot. You'll need to run Lavalink and PostgreSQL on your own.","title":"What's next?"},{"location":"dev/errors/","text":"Custom exceptions (errors) to handle in global error handler. CustomAPIFailed Bases: hikari . HTTPError Exception raised when a third-party API call failed (not status 200). CustomCheckFailed Bases: lightbulb . CheckFailure Exception raised when a custom check (not lightbulb check) failed. NoDatabase Bases: CustomCheckFailed Exception raised when the bot doesn't have a database connection pool. NoHTTPClient Bases: CustomCheckFailed Exception raised when the bot doesn't have a http client. GuildDisabled Bases: CustomCheckFailed Exception raised when the guild disable the command. GuildBlacklisted Bases: CustomCheckFailed Exception raised when the guild is blacklisted by the bot's owner. UserBlacklisted Bases: CustomCheckFailed Exception raised when the user is blacklisted by the bot's owner.","title":"errors.py"},{"location":"dev/errors/#utils.errors.CustomAPIFailed","text":"Bases: hikari . HTTPError Exception raised when a third-party API call failed (not status 200).","title":"CustomAPIFailed"},{"location":"dev/errors/#utils.errors.CustomCheckFailed","text":"Bases: lightbulb . CheckFailure Exception raised when a custom check (not lightbulb check) failed.","title":"CustomCheckFailed"},{"location":"dev/errors/#utils.errors.NoDatabase","text":"Bases: CustomCheckFailed Exception raised when the bot doesn't have a database connection pool.","title":"NoDatabase"},{"location":"dev/errors/#utils.errors.NoHTTPClient","text":"Bases: CustomCheckFailed Exception raised when the bot doesn't have a http client.","title":"NoHTTPClient"},{"location":"dev/errors/#utils.errors.GuildDisabled","text":"Bases: CustomCheckFailed Exception raised when the guild disable the command.","title":"GuildDisabled"},{"location":"dev/errors/#utils.errors.GuildBlacklisted","text":"Bases: CustomCheckFailed Exception raised when the guild is blacklisted by the bot's owner.","title":"GuildBlacklisted"},{"location":"dev/errors/#utils.errors.UserBlacklisted","text":"Bases: CustomCheckFailed Exception raised when the user is blacklisted by the bot's owner.","title":"UserBlacklisted"},{"location":"dev/funtext/","text":"Contains funny text manipulations. pekofy ( / , text : str ) -> str A simple implementation of pekofy which simply adds peko at the end of a sentence. Parameters: Name Type Description Default text str The text to transform. required Returns: Type Description str The pekofy text. Source code in utils\\funtext.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def pekofy ( text : str , / ) -> str : '''A simple implementation of `pekofy` which simply adds `peko` at the end of a sentence. Parameters ---------- text : str The text to transform. Returns ------- str The pekofy text. ''' words = text . split () for index , word in enumerate ( words ): for punc in [ '.' , '!' , '?' ]: if word . endswith ( punc ): words [ index ] = words [ index ][: - 1 ] + f \" peko { punc } \" if word == words [ - 1 ]: words [ index ] += \" peko\" return ' ' . join ( words ) uwuify ( / , text : str , * , allow_nyvowels = True , stutter_chance : float = 0.2 , emote_chance : float = 0.8 , action_chance : float = 0.05 ) -> str Transform a text into uwu text. Parameters: Name Type Description Default text str The text to transform. required allow_nyvowels bool , optional Whether or not to transform na , no , etc. into nya , nyo , etc. Default to True . True stutter_chance float , optional The chance to stutter a word. Must be [0, 1] . Default to 0.20 . 0.2 emote_chance float , optional The chance to put an emote after a punctuation like , or . Must be [0, 1] . Default to 0.8 . 0.8 action_chance float , optional The chance to put an action string after a word. Must be [0, 1] . Default to 0.05 . 0.05 Returns: Type Description str The uwu text. Source code in utils\\funtext.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def uwuify ( text : str , / , * , allow_nyvowels = True , stutter_chance : float = 0.20 , emote_chance : float = 0.8 , action_chance : float = 0.05 ) -> str : '''Transform a text into uwu text. Parameters ---------- text : str The text to transform. allow_nyvowels : bool, optional Whether or not to transform `na`, `no`, etc. into `nya`, `nyo`, etc. Default to `True`. stutter_chance : float, optional The chance to stutter a word. Must be `[0, 1]`. Default to `0.20`. emote_chance : float, optional The chance to put an emote after a punctuation like `,` or `.` Must be `[0, 1]`. Default to `0.8`. action_chance : float, optional The chance to put an action string after a word. Must be `[0, 1]`. Default to `0.05`. Returns ------- str The uwu text. ''' words = text . split () for index , word in enumerate ( words ): words [ index ] = words [ index ] . replace ( 'l' , 'w' ) words [ index ] = words [ index ] . replace ( 'L' , 'W' ) words [ index ] = words [ index ] . replace ( 'r' , 'w' ) words [ index ] = words [ index ] . replace ( 'R' , 'W' ) if allow_nyvowels : words [ index ] = words [ index ] . replace ( \"na\" , \"nya\" ) words [ index ] = words [ index ] . replace ( \"Na\" , \"Nya\" ) words [ index ] = words [ index ] . replace ( \"NA\" , \"NyA\" ) words [ index ] = words [ index ] . replace ( \"ne\" , \"nye\" ) words [ index ] = words [ index ] . replace ( \"Ne\" , \"Nye\" ) words [ index ] = words [ index ] . replace ( \"NE\" , \"NyE\" ) words [ index ] = words [ index ] . replace ( \"no\" , \"nyo\" ) words [ index ] = words [ index ] . replace ( \"No\" , \"Nyo\" ) words [ index ] = words [ index ] . replace ( \"NO\" , \"NyO\" ) words [ index ] = words [ index ] . replace ( \"nu\" , \"yu\" ) words [ index ] = words [ index ] . replace ( \"Nu\" , \"Nyu\" ) words [ index ] = words [ index ] . replace ( \"NU\" , \"NyU\" ) if word in __REPLACE_WORDS : words [ index ] = __REPLACE_WORDS [ word ] is_stutter = random . random () if is_stutter <= stutter_chance : words [ index ] = f \" { words [ index ][ 0 ] } - { words [ index ] } \" is_emote = random . random () if is_emote <= emote_chance and words [ index ] . endswith (( '.' , '?' , '!' , ',' )): words [ index ] += random . choice ( __RANDOM_EMOTES ) is_action = random . random () if is_action <= action_chance : words [ index ] += random . choice ( __RANDOM_ACTIONS ) return ' ' . join ( words )","title":"funtext.py"},{"location":"dev/funtext/#utils.funtext.pekofy","text":"A simple implementation of pekofy which simply adds peko at the end of a sentence. Parameters: Name Type Description Default text str The text to transform. required Returns: Type Description str The pekofy text. Source code in utils\\funtext.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def pekofy ( text : str , / ) -> str : '''A simple implementation of `pekofy` which simply adds `peko` at the end of a sentence. Parameters ---------- text : str The text to transform. Returns ------- str The pekofy text. ''' words = text . split () for index , word in enumerate ( words ): for punc in [ '.' , '!' , '?' ]: if word . endswith ( punc ): words [ index ] = words [ index ][: - 1 ] + f \" peko { punc } \" if word == words [ - 1 ]: words [ index ] += \" peko\" return ' ' . join ( words )","title":"pekofy()"},{"location":"dev/funtext/#utils.funtext.uwuify","text":"Transform a text into uwu text. Parameters: Name Type Description Default text str The text to transform. required allow_nyvowels bool , optional Whether or not to transform na , no , etc. into nya , nyo , etc. Default to True . True stutter_chance float , optional The chance to stutter a word. Must be [0, 1] . Default to 0.20 . 0.2 emote_chance float , optional The chance to put an emote after a punctuation like , or . Must be [0, 1] . Default to 0.8 . 0.8 action_chance float , optional The chance to put an action string after a word. Must be [0, 1] . Default to 0.05 . 0.05 Returns: Type Description str The uwu text. Source code in utils\\funtext.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def uwuify ( text : str , / , * , allow_nyvowels = True , stutter_chance : float = 0.20 , emote_chance : float = 0.8 , action_chance : float = 0.05 ) -> str : '''Transform a text into uwu text. Parameters ---------- text : str The text to transform. allow_nyvowels : bool, optional Whether or not to transform `na`, `no`, etc. into `nya`, `nyo`, etc. Default to `True`. stutter_chance : float, optional The chance to stutter a word. Must be `[0, 1]`. Default to `0.20`. emote_chance : float, optional The chance to put an emote after a punctuation like `,` or `.` Must be `[0, 1]`. Default to `0.8`. action_chance : float, optional The chance to put an action string after a word. Must be `[0, 1]`. Default to `0.05`. Returns ------- str The uwu text. ''' words = text . split () for index , word in enumerate ( words ): words [ index ] = words [ index ] . replace ( 'l' , 'w' ) words [ index ] = words [ index ] . replace ( 'L' , 'W' ) words [ index ] = words [ index ] . replace ( 'r' , 'w' ) words [ index ] = words [ index ] . replace ( 'R' , 'W' ) if allow_nyvowels : words [ index ] = words [ index ] . replace ( \"na\" , \"nya\" ) words [ index ] = words [ index ] . replace ( \"Na\" , \"Nya\" ) words [ index ] = words [ index ] . replace ( \"NA\" , \"NyA\" ) words [ index ] = words [ index ] . replace ( \"ne\" , \"nye\" ) words [ index ] = words [ index ] . replace ( \"Ne\" , \"Nye\" ) words [ index ] = words [ index ] . replace ( \"NE\" , \"NyE\" ) words [ index ] = words [ index ] . replace ( \"no\" , \"nyo\" ) words [ index ] = words [ index ] . replace ( \"No\" , \"Nyo\" ) words [ index ] = words [ index ] . replace ( \"NO\" , \"NyO\" ) words [ index ] = words [ index ] . replace ( \"nu\" , \"yu\" ) words [ index ] = words [ index ] . replace ( \"Nu\" , \"Nyu\" ) words [ index ] = words [ index ] . replace ( \"NU\" , \"NyU\" ) if word in __REPLACE_WORDS : words [ index ] = __REPLACE_WORDS [ word ] is_stutter = random . random () if is_stutter <= stutter_chance : words [ index ] = f \" { words [ index ][ 0 ] } - { words [ index ] } \" is_emote = random . random () if is_emote <= emote_chance and words [ index ] . endswith (( '.' , '?' , '!' , ',' )): words [ index ] += random . choice ( __RANDOM_EMOTES ) is_action = random . random () if is_action <= action_chance : words [ index ] += random . choice ( __RANDOM_ACTIONS ) return ' ' . join ( words )","title":"uwuify()"},{"location":"dev/help/","text":"Define the behavior of the 'help' command for the bot. Includes help-specific utilities. MenuLikeHelp Bases: lightbulb . DefaultHelpCommand A custom help command that's tailored for MichaelBot . Source code in categories\\help.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 class MenuLikeHelp ( lightbulb . DefaultHelpCommand ): ''' A custom help command that's tailored for `MichaelBot`. ''' async def send_help ( self , ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None : ''' The main logic for the help command. ''' bot : models . MichaelBot = self . bot # Reference: https://github.com/tandemdude/hikari-lightbulb/blob/development/lightbulb/help_command.py#L100 if obj is None : await self . send_bot_help ( ctx ) return # Prioritize searching command based on context. if isinstance ( ctx , lightbulb . PrefixContext ): cmd = bot . get_prefix_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . PrefixCommandGroup , lightbulb . PrefixSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) if isinstance ( ctx , lightbulb . SlashContext ): cmd = bot . get_slash_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) # We don't have user/message commands yet. await super () . send_help ( ctx , obj ) async def send_bot_help ( self , ctx : lightbulb . Context ) -> None : ''' Send a generic help message. ''' if isinstance ( ctx , lightbulb . PrefixContext ): await ctx . event . message . delete () main_page = helpers . get_default_embed ( title = \"Help\" , description = \"\" , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) plugins = ctx . bot . plugins # {plugin_name: command_count} plugin_info : dict [ str , int ] = {} for plugin in plugins . values (): public_commands = [] if isinstance ( ctx , lightbulb . PrefixContext ): public_commands = filter_command_type ( plugin . all_commands , __PREFIX_COMMAND_TYPES__ , True ) else : public_commands = filter_command_type ( plugin . all_commands , __SLASH_COMMAND_TYPES__ , True ) public_commands_len = len ( public_commands ) if public_commands_len > 0 : embed_name = f \" { plugin . d . emote } { plugin . name } ( { public_commands_len } commands)\" embed_description = \"*No description provided*\" if bool ( plugin . description ): embed_description = plugin . description main_page . add_field ( name = embed_name , value = embed_description , inline = False ) plugin_info [ plugin . name ] = public_commands_len menu_root = menu . MenuComponent ( main_page ) for name in plugin_info : menu_root . add_list_options ( menu . MenuButton ( label = name , emoji = plugins [ name ] . d . emote , ), plugin_help_format ( ctx , plugins [ name ]) ) await menu . ComplexView ( menu_root ) . run ( ctx ) async def send_plugin_help ( self , ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None : ''' Send a plugin help that contains all commands. ''' embeds = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ public_commands = filter_command_type ( plugin . all_commands , types , True ) for command in sorted ( public_commands , key = lambda cmd : cmd . name ): page = command_help_format ( ctx , command ) if page is not None : embeds . append ( page ) page_nav = navigator . ButtonNavigator ( pages = embeds ) await navigator . run_view ( page_nav , ctx ) async def send_command_help ( self , ctx : lightbulb . Context , command : lightbulb . Command ) -> None : ''' Send a command help. ''' await ctx . respond ( embed = command_help_format ( ctx , command )) async def send_group_help ( self , ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None : ''' Send a group help. Internally, this does the same as `send_command_help()`. ''' await ctx . respond ( embed = command_help_format ( ctx , group )) send_help ( ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None async The main logic for the help command. Source code in categories\\help.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 async def send_help ( self , ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None : ''' The main logic for the help command. ''' bot : models . MichaelBot = self . bot # Reference: https://github.com/tandemdude/hikari-lightbulb/blob/development/lightbulb/help_command.py#L100 if obj is None : await self . send_bot_help ( ctx ) return # Prioritize searching command based on context. if isinstance ( ctx , lightbulb . PrefixContext ): cmd = bot . get_prefix_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . PrefixCommandGroup , lightbulb . PrefixSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) if isinstance ( ctx , lightbulb . SlashContext ): cmd = bot . get_slash_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) # We don't have user/message commands yet. await super () . send_help ( ctx , obj ) send_bot_help ( ctx : lightbulb . Context ) -> None async Send a generic help message. Source code in categories\\help.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 async def send_bot_help ( self , ctx : lightbulb . Context ) -> None : ''' Send a generic help message. ''' if isinstance ( ctx , lightbulb . PrefixContext ): await ctx . event . message . delete () main_page = helpers . get_default_embed ( title = \"Help\" , description = \"\" , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) plugins = ctx . bot . plugins # {plugin_name: command_count} plugin_info : dict [ str , int ] = {} for plugin in plugins . values (): public_commands = [] if isinstance ( ctx , lightbulb . PrefixContext ): public_commands = filter_command_type ( plugin . all_commands , __PREFIX_COMMAND_TYPES__ , True ) else : public_commands = filter_command_type ( plugin . all_commands , __SLASH_COMMAND_TYPES__ , True ) public_commands_len = len ( public_commands ) if public_commands_len > 0 : embed_name = f \" { plugin . d . emote } { plugin . name } ( { public_commands_len } commands)\" embed_description = \"*No description provided*\" if bool ( plugin . description ): embed_description = plugin . description main_page . add_field ( name = embed_name , value = embed_description , inline = False ) plugin_info [ plugin . name ] = public_commands_len menu_root = menu . MenuComponent ( main_page ) for name in plugin_info : menu_root . add_list_options ( menu . MenuButton ( label = name , emoji = plugins [ name ] . d . emote , ), plugin_help_format ( ctx , plugins [ name ]) ) await menu . ComplexView ( menu_root ) . run ( ctx ) send_plugin_help ( ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None async Send a plugin help that contains all commands. Source code in categories\\help.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 async def send_plugin_help ( self , ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None : ''' Send a plugin help that contains all commands. ''' embeds = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ public_commands = filter_command_type ( plugin . all_commands , types , True ) for command in sorted ( public_commands , key = lambda cmd : cmd . name ): page = command_help_format ( ctx , command ) if page is not None : embeds . append ( page ) page_nav = navigator . ButtonNavigator ( pages = embeds ) await navigator . run_view ( page_nav , ctx ) send_command_help ( ctx : lightbulb . Context , command : lightbulb . Command ) -> None async Send a command help. Source code in categories\\help.py 319 320 321 322 323 async def send_command_help ( self , ctx : lightbulb . Context , command : lightbulb . Command ) -> None : ''' Send a command help. ''' await ctx . respond ( embed = command_help_format ( ctx , command )) send_group_help ( ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None async Send a group help. Internally, this does the same as send_command_help() . Source code in categories\\help.py 324 325 326 327 328 329 330 async def send_group_help ( self , ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None : ''' Send a group help. Internally, this does the same as `send_command_help()`. ''' await ctx . respond ( embed = command_help_format ( ctx , group )) filter_command_type ( commands : t . Sequence [ lightbulb . Command ], types : t . Sequence [ t . Type ], remove_hidden : bool = False ) -> t . List [ lightbulb . Command ] Filter commands with one of the type mentioned in types . Parameters: Name Type Description Default commands t . Sequence [ lightbulb . Command ] A sequence of commands. required types t . Sequence [ t . Type ] A sequence of command's types to filter. Example: (lightbulb.PrefixCommand, lightbulb.SlashCommand) . required remove_hidden bool , optional Whether or not to remove hidden commands. Default to False . False Returns: Type Description t . List [ lightbulb . Command ] A list of commands filtered out by types. Source code in categories\\help.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def filter_command_type ( commands : t . Sequence [ lightbulb . Command ], types : t . Sequence [ t . Type ], remove_hidden : bool = False ) -> t . List [ lightbulb . Command ]: '''Filter commands with one of the type mentioned in `types`. Parameters ---------- commands : t.Sequence[lightbulb.Command] A sequence of commands. types : t.Sequence[t.Type] A sequence of command's types to filter. Example: `(lightbulb.PrefixCommand, lightbulb.SlashCommand)`. remove_hidden : bool, optional Whether or not to remove hidden commands. Default to `False`. Returns ------- t.List[lightbulb.Command] A list of commands filtered out by types. ''' l = [] for command in commands : if isinstance ( command , types ): if ( not remove_hidden ) or ( remove_hidden and not command . hidden ): l . append ( command ) return l plugin_help_format ( ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> t . List [ hikari . Embed ] Return a list of formatted embed for a plugin help. This list can be passed into a paginator to display. Parameters: Name Type Description Default ctx lightbulb . Context The context. required plugin lightbulb . Plugin The plugin to display the help. required Returns: Type Description t . List [ hikari . Embed ] A list of formatted embed for a plugin help. Source code in categories\\help.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def plugin_help_format ( ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> t . List [ hikari . Embed ]: '''Return a list of formatted embed for a plugin help. This list can be passed into a paginator to display. Parameters ---------- ctx : lightbulb.Context The context. plugin : lightbulb.Plugin The plugin to display the help. Returns ------- t.List[hikari.Embed] A list of formatted embed for a plugin help. ''' MAX_COMMANDS = 10 display = \"\" plugins = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ commands : t . List [ lightbulb . Command ] = filter_command_type ( plugin . all_commands , types , True ) commands . sort ( key = lambda command : command . name ) for index , command in enumerate ( commands ): # Signature includes command name. command_title = command . signature . replace ( '=' , ' = ' ) display += f \"** { command_title } :** \\n \" description = command . description if not description : description = \"*No help provided*\" display += f \"- { description } \\n\\n \" if index == MAX_COMMANDS - 1 or index == len ( commands ) - 1 : title = f \" { plugin . name } ( { len ( commands ) } commands):\" embed = helpers . get_default_embed ( title = title , description = display , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) . set_thumbnail ( ctx . bot . get_me () . avatar_url ) plugins . append ( embed ) display = \"\" return plugins command_help_format ( ctx : lightbulb . Context , command : lightbulb . Command ) -> hikari . Embed Return a formatted embed for a command help. Notes For command group, the embed will also include all subcommands. Parameters: Name Type Description Default ctx lightbulb . Context The context. required command lightbulb . Command The command to display the help. Can also be a command group/subcommand/... required Returns: Type Description hikari . Embed The formatted embed for a command help. Source code in categories\\help.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def command_help_format ( ctx : lightbulb . Context , command : lightbulb . Command ) -> hikari . Embed : '''Return a formatted embed for a command help. Notes ----- For command group, the embed will also include all subcommands. Parameters ---------- ctx : lightbulb.Context The context. command : lightbulb.Command The command to display the help. Can also be a command group/subcommand/... Returns ------- hikari.Embed The formatted embed for a command help. ''' bot : models . MichaelBot = ctx . bot # Signature includes full command name. embed_title = command . signature . replace ( '=' , ' = ' ) embed_description = \"*No help provided*\" if command . description != \"\" : embed_description = command . description + ' \\n ' embed = helpers . get_default_embed ( title = embed_title , description = embed_description , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) command_type = [] p_cmd = bot . get_prefix_command ( command . qualname ) s_cmd = bot . get_slash_command ( command . qualname ) m_cmd = bot . get_message_command ( command . qualname ) u_cmd = bot . get_user_command ( command . qualname ) if p_cmd is not None : command_type . append ( \"`Prefix Command`\" ) if s_cmd is not None and not isinstance ( s_cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): command_type . append ( \"`Slash Command`\" ) if m_cmd is not None : command_type . append ( \"`Message Command`\" ) if u_cmd is not None : command_type . append ( \"`User Command`\" ) embed . add_field ( name = \"Type\" , value = ' ' . join ( command_type ) ) if len ( command . options ) > 0 : option_field = \"\" for option in command . options . values (): option_field += f \"- ` { option . name } `: { option . description } \\n \" embed . add_field ( name = \"Parameters\" , value = option_field ) if len ( command . aliases ) > 0 and isinstance ( command , __PREFIX_COMMAND_TYPES__ ): embed . add_field ( name = \"Aliases (Prefix Command only)\" , value = \"- \" + ', ' . join ( f \"` { alias } `\" for alias in command . aliases ) ) if bool ( command . get_help ( ctx )): embed . add_field ( name = \"Note\" , value = dedent ( command . get_help ( ctx )) ) if isinstance ( command , __COMMAND_GROUPS_TYPES__ ): field_value = \"\" subcommands = command . subcommands . values () types = __PREFIX_COMMAND_TYPES__ # Can't check with ctx, since SlashContext can call a PrefixCommandGroup. if isinstance ( command , __SLASH_COMMAND_TYPES__ ): types = __SLASH_COMMAND_TYPES__ for subcommand in sorted ( filter_command_type ( subcommands , types , True ), key = lambda cmd : cmd . name ): field_value += f \"- ` { subcommand . name } `: { subcommand . description } \\n \" if len ( command . subcommands ) > 0 : embed . add_field ( name = \"**Subcommands:**\" , value = field_value , inline = False ) return embed","title":"help.py"},{"location":"dev/help/#categories.help.MenuLikeHelp","text":"Bases: lightbulb . DefaultHelpCommand A custom help command that's tailored for MichaelBot . Source code in categories\\help.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 class MenuLikeHelp ( lightbulb . DefaultHelpCommand ): ''' A custom help command that's tailored for `MichaelBot`. ''' async def send_help ( self , ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None : ''' The main logic for the help command. ''' bot : models . MichaelBot = self . bot # Reference: https://github.com/tandemdude/hikari-lightbulb/blob/development/lightbulb/help_command.py#L100 if obj is None : await self . send_bot_help ( ctx ) return # Prioritize searching command based on context. if isinstance ( ctx , lightbulb . PrefixContext ): cmd = bot . get_prefix_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . PrefixCommandGroup , lightbulb . PrefixSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) if isinstance ( ctx , lightbulb . SlashContext ): cmd = bot . get_slash_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) # We don't have user/message commands yet. await super () . send_help ( ctx , obj ) async def send_bot_help ( self , ctx : lightbulb . Context ) -> None : ''' Send a generic help message. ''' if isinstance ( ctx , lightbulb . PrefixContext ): await ctx . event . message . delete () main_page = helpers . get_default_embed ( title = \"Help\" , description = \"\" , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) plugins = ctx . bot . plugins # {plugin_name: command_count} plugin_info : dict [ str , int ] = {} for plugin in plugins . values (): public_commands = [] if isinstance ( ctx , lightbulb . PrefixContext ): public_commands = filter_command_type ( plugin . all_commands , __PREFIX_COMMAND_TYPES__ , True ) else : public_commands = filter_command_type ( plugin . all_commands , __SLASH_COMMAND_TYPES__ , True ) public_commands_len = len ( public_commands ) if public_commands_len > 0 : embed_name = f \" { plugin . d . emote } { plugin . name } ( { public_commands_len } commands)\" embed_description = \"*No description provided*\" if bool ( plugin . description ): embed_description = plugin . description main_page . add_field ( name = embed_name , value = embed_description , inline = False ) plugin_info [ plugin . name ] = public_commands_len menu_root = menu . MenuComponent ( main_page ) for name in plugin_info : menu_root . add_list_options ( menu . MenuButton ( label = name , emoji = plugins [ name ] . d . emote , ), plugin_help_format ( ctx , plugins [ name ]) ) await menu . ComplexView ( menu_root ) . run ( ctx ) async def send_plugin_help ( self , ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None : ''' Send a plugin help that contains all commands. ''' embeds = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ public_commands = filter_command_type ( plugin . all_commands , types , True ) for command in sorted ( public_commands , key = lambda cmd : cmd . name ): page = command_help_format ( ctx , command ) if page is not None : embeds . append ( page ) page_nav = navigator . ButtonNavigator ( pages = embeds ) await navigator . run_view ( page_nav , ctx ) async def send_command_help ( self , ctx : lightbulb . Context , command : lightbulb . Command ) -> None : ''' Send a command help. ''' await ctx . respond ( embed = command_help_format ( ctx , command )) async def send_group_help ( self , ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None : ''' Send a group help. Internally, this does the same as `send_command_help()`. ''' await ctx . respond ( embed = command_help_format ( ctx , group ))","title":"MenuLikeHelp"},{"location":"dev/help/#categories.help.MenuLikeHelp.send_help","text":"The main logic for the help command. Source code in categories\\help.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 async def send_help ( self , ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None : ''' The main logic for the help command. ''' bot : models . MichaelBot = self . bot # Reference: https://github.com/tandemdude/hikari-lightbulb/blob/development/lightbulb/help_command.py#L100 if obj is None : await self . send_bot_help ( ctx ) return # Prioritize searching command based on context. if isinstance ( ctx , lightbulb . PrefixContext ): cmd = bot . get_prefix_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . PrefixCommandGroup , lightbulb . PrefixSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) if isinstance ( ctx , lightbulb . SlashContext ): cmd = bot . get_slash_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) # We don't have user/message commands yet. await super () . send_help ( ctx , obj )","title":"send_help()"},{"location":"dev/help/#categories.help.MenuLikeHelp.send_bot_help","text":"Send a generic help message. Source code in categories\\help.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 async def send_bot_help ( self , ctx : lightbulb . Context ) -> None : ''' Send a generic help message. ''' if isinstance ( ctx , lightbulb . PrefixContext ): await ctx . event . message . delete () main_page = helpers . get_default_embed ( title = \"Help\" , description = \"\" , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) plugins = ctx . bot . plugins # {plugin_name: command_count} plugin_info : dict [ str , int ] = {} for plugin in plugins . values (): public_commands = [] if isinstance ( ctx , lightbulb . PrefixContext ): public_commands = filter_command_type ( plugin . all_commands , __PREFIX_COMMAND_TYPES__ , True ) else : public_commands = filter_command_type ( plugin . all_commands , __SLASH_COMMAND_TYPES__ , True ) public_commands_len = len ( public_commands ) if public_commands_len > 0 : embed_name = f \" { plugin . d . emote } { plugin . name } ( { public_commands_len } commands)\" embed_description = \"*No description provided*\" if bool ( plugin . description ): embed_description = plugin . description main_page . add_field ( name = embed_name , value = embed_description , inline = False ) plugin_info [ plugin . name ] = public_commands_len menu_root = menu . MenuComponent ( main_page ) for name in plugin_info : menu_root . add_list_options ( menu . MenuButton ( label = name , emoji = plugins [ name ] . d . emote , ), plugin_help_format ( ctx , plugins [ name ]) ) await menu . ComplexView ( menu_root ) . run ( ctx )","title":"send_bot_help()"},{"location":"dev/help/#categories.help.MenuLikeHelp.send_plugin_help","text":"Send a plugin help that contains all commands. Source code in categories\\help.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 async def send_plugin_help ( self , ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None : ''' Send a plugin help that contains all commands. ''' embeds = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ public_commands = filter_command_type ( plugin . all_commands , types , True ) for command in sorted ( public_commands , key = lambda cmd : cmd . name ): page = command_help_format ( ctx , command ) if page is not None : embeds . append ( page ) page_nav = navigator . ButtonNavigator ( pages = embeds ) await navigator . run_view ( page_nav , ctx )","title":"send_plugin_help()"},{"location":"dev/help/#categories.help.MenuLikeHelp.send_command_help","text":"Send a command help. Source code in categories\\help.py 319 320 321 322 323 async def send_command_help ( self , ctx : lightbulb . Context , command : lightbulb . Command ) -> None : ''' Send a command help. ''' await ctx . respond ( embed = command_help_format ( ctx , command ))","title":"send_command_help()"},{"location":"dev/help/#categories.help.MenuLikeHelp.send_group_help","text":"Send a group help. Internally, this does the same as send_command_help() . Source code in categories\\help.py 324 325 326 327 328 329 330 async def send_group_help ( self , ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None : ''' Send a group help. Internally, this does the same as `send_command_help()`. ''' await ctx . respond ( embed = command_help_format ( ctx , group ))","title":"send_group_help()"},{"location":"dev/help/#categories.help.filter_command_type","text":"Filter commands with one of the type mentioned in types . Parameters: Name Type Description Default commands t . Sequence [ lightbulb . Command ] A sequence of commands. required types t . Sequence [ t . Type ] A sequence of command's types to filter. Example: (lightbulb.PrefixCommand, lightbulb.SlashCommand) . required remove_hidden bool , optional Whether or not to remove hidden commands. Default to False . False Returns: Type Description t . List [ lightbulb . Command ] A list of commands filtered out by types. Source code in categories\\help.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def filter_command_type ( commands : t . Sequence [ lightbulb . Command ], types : t . Sequence [ t . Type ], remove_hidden : bool = False ) -> t . List [ lightbulb . Command ]: '''Filter commands with one of the type mentioned in `types`. Parameters ---------- commands : t.Sequence[lightbulb.Command] A sequence of commands. types : t.Sequence[t.Type] A sequence of command's types to filter. Example: `(lightbulb.PrefixCommand, lightbulb.SlashCommand)`. remove_hidden : bool, optional Whether or not to remove hidden commands. Default to `False`. Returns ------- t.List[lightbulb.Command] A list of commands filtered out by types. ''' l = [] for command in commands : if isinstance ( command , types ): if ( not remove_hidden ) or ( remove_hidden and not command . hidden ): l . append ( command ) return l","title":"filter_command_type()"},{"location":"dev/help/#categories.help.plugin_help_format","text":"Return a list of formatted embed for a plugin help. This list can be passed into a paginator to display. Parameters: Name Type Description Default ctx lightbulb . Context The context. required plugin lightbulb . Plugin The plugin to display the help. required Returns: Type Description t . List [ hikari . Embed ] A list of formatted embed for a plugin help. Source code in categories\\help.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def plugin_help_format ( ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> t . List [ hikari . Embed ]: '''Return a list of formatted embed for a plugin help. This list can be passed into a paginator to display. Parameters ---------- ctx : lightbulb.Context The context. plugin : lightbulb.Plugin The plugin to display the help. Returns ------- t.List[hikari.Embed] A list of formatted embed for a plugin help. ''' MAX_COMMANDS = 10 display = \"\" plugins = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ commands : t . List [ lightbulb . Command ] = filter_command_type ( plugin . all_commands , types , True ) commands . sort ( key = lambda command : command . name ) for index , command in enumerate ( commands ): # Signature includes command name. command_title = command . signature . replace ( '=' , ' = ' ) display += f \"** { command_title } :** \\n \" description = command . description if not description : description = \"*No help provided*\" display += f \"- { description } \\n\\n \" if index == MAX_COMMANDS - 1 or index == len ( commands ) - 1 : title = f \" { plugin . name } ( { len ( commands ) } commands):\" embed = helpers . get_default_embed ( title = title , description = display , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) . set_thumbnail ( ctx . bot . get_me () . avatar_url ) plugins . append ( embed ) display = \"\" return plugins","title":"plugin_help_format()"},{"location":"dev/help/#categories.help.command_help_format","text":"Return a formatted embed for a command help.","title":"command_help_format()"},{"location":"dev/help/#categories.help.command_help_format--notes","text":"For command group, the embed will also include all subcommands. Parameters: Name Type Description Default ctx lightbulb . Context The context. required command lightbulb . Command The command to display the help. Can also be a command group/subcommand/... required Returns: Type Description hikari . Embed The formatted embed for a command help. Source code in categories\\help.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def command_help_format ( ctx : lightbulb . Context , command : lightbulb . Command ) -> hikari . Embed : '''Return a formatted embed for a command help. Notes ----- For command group, the embed will also include all subcommands. Parameters ---------- ctx : lightbulb.Context The context. command : lightbulb.Command The command to display the help. Can also be a command group/subcommand/... Returns ------- hikari.Embed The formatted embed for a command help. ''' bot : models . MichaelBot = ctx . bot # Signature includes full command name. embed_title = command . signature . replace ( '=' , ' = ' ) embed_description = \"*No help provided*\" if command . description != \"\" : embed_description = command . description + ' \\n ' embed = helpers . get_default_embed ( title = embed_title , description = embed_description , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) command_type = [] p_cmd = bot . get_prefix_command ( command . qualname ) s_cmd = bot . get_slash_command ( command . qualname ) m_cmd = bot . get_message_command ( command . qualname ) u_cmd = bot . get_user_command ( command . qualname ) if p_cmd is not None : command_type . append ( \"`Prefix Command`\" ) if s_cmd is not None and not isinstance ( s_cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): command_type . append ( \"`Slash Command`\" ) if m_cmd is not None : command_type . append ( \"`Message Command`\" ) if u_cmd is not None : command_type . append ( \"`User Command`\" ) embed . add_field ( name = \"Type\" , value = ' ' . join ( command_type ) ) if len ( command . options ) > 0 : option_field = \"\" for option in command . options . values (): option_field += f \"- ` { option . name } `: { option . description } \\n \" embed . add_field ( name = \"Parameters\" , value = option_field ) if len ( command . aliases ) > 0 and isinstance ( command , __PREFIX_COMMAND_TYPES__ ): embed . add_field ( name = \"Aliases (Prefix Command only)\" , value = \"- \" + ', ' . join ( f \"` { alias } `\" for alias in command . aliases ) ) if bool ( command . get_help ( ctx )): embed . add_field ( name = \"Note\" , value = dedent ( command . get_help ( ctx )) ) if isinstance ( command , __COMMAND_GROUPS_TYPES__ ): field_value = \"\" subcommands = command . subcommands . values () types = __PREFIX_COMMAND_TYPES__ # Can't check with ctx, since SlashContext can call a PrefixCommandGroup. if isinstance ( command , __SLASH_COMMAND_TYPES__ ): types = __SLASH_COMMAND_TYPES__ for subcommand in sorted ( filter_command_type ( subcommands , types , True ), key = lambda cmd : cmd . name ): field_value += f \"- ` { subcommand . name } `: { subcommand . description } \\n \" if len ( command . subcommands ) > 0 : embed . add_field ( name = \"**Subcommands:**\" , value = field_value , inline = False ) return embed","title":"Notes"},{"location":"dev/helpers/","text":"Contains many useful functions. embed_from_dict ( / , data : dict [ str , t . Any ]) -> hikari . Embed Generate an embed from a dictionary. Parameters: Name Type Description Default data dict [ str , t . Any ] A valid dict representation of an embed. required Returns: Type Description hikari . Embed The embed from the dict. Source code in utils\\helpers.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def embed_from_dict ( data : dict [ str , t . Any ], / ) -> hikari . Embed : '''Generate an embed from a dictionary. Parameters ---------- data : dict[str, t.Any] A valid dict representation of an embed. Returns ------- hikari.Embed The embed from the dict. ''' embed = hikari . Embed () embed . title = data . get ( \"title\" , None ) embed . description = data . get ( \"description\" , None ) embed . url = data . get ( \"url\" , None ) if embed . title is not None : embed . title = str ( embed . title ) if embed . description is not None : embed . description = str ( embed . description ) if embed . url is not None : embed . url = str ( embed . url ) try : embed . color = hikari . Color ( data [ \"color\" ]) except KeyError : pass try : embed . timestamp = dt . datetime . fromtimestamp ( data [ 'timestamp' ], tz = dt . timezone . utc ) except KeyError : pass try : value = data [ \"thumbnail\" ] except KeyError : pass else : embed . set_thumbnail ( value ) try : value = data [ \"author\" ] except KeyError : pass else : embed . set_author ( ** value ) try : value = data [ \"fields\" ] except KeyError : pass else : for field in value : embed . add_field ( ** field ) try : value = data [ \"image\" ] except KeyError : pass else : embed . set_image ( value ) try : value = data [ \"footer\" ] except KeyError : pass else : embed . set_footer ( ** value ) return embed embed_to_dict ( / , embed : hikari . Embed ) -> dict [ str , t . Any ] Convert an embed into a dict object. Parameters: Name Type Description Default embed hikari . Embed An embed object to convert. required Returns: Type Description dict [ str , t . Any ] A dictionary that conforms Discord's structure. Source code in utils\\helpers.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def embed_to_dict ( embed : hikari . Embed , / ) -> dict [ str , t . Any ]: '''Convert an embed into a dict object. Parameters ---------- embed : hikari.Embed An embed object to convert. Returns ------- dict[str, t.Any] A dictionary that conforms Discord's structure. ''' d = {} if bool ( embed . title ): d [ \"title\" ] = embed . title if bool ( embed . description ): d [ \"description\" ] = embed . description if bool ( embed . url ): d [ \"url\" ] = embed . url if bool ( embed . color ): d [ \"color\" ] = int ( embed . color ) if bool ( embed . timestamp ): d [ \"timestamp\" ] = embed . timestamp . timestamp () if bool ( embed . thumbnail ): d [ \"thumbnail\" ] = embed . thumbnail . url if bool ( embed . author ): d [ \"author\" ] = { \"name\" : embed . author . name , \"url\" : embed . author . url } if bool ( embed . author . icon ): d [ \"author\" ][ \"icon\" ] = embed . author . icon . url if bool ( embed . fields ): d [ \"fields\" ] = [] for field in embed . fields : d [ \"fields\" ] . append ({ \"name\" : field . name , \"value\" : field . value , \"inline\" : field . is_inline }) if bool ( embed . image ): d [ \"image\" ] = embed . image . url if bool ( embed . footer ): d [ \"footer\" ] = { \"text\" : embed . footer . text } if bool ( embed . footer . icon ): d [ \"footer\" ][ \"icon\" ] = embed . footer . icon . url return d get_emote ( / , discord_text : str ) -> str Return the Unicode emoji based on the name provided. Parameters: Name Type Description Default discord_text str Discord/Twitter name of the emoji including : . Example: :grin: . required Returns: Type Description str The Unicode emoji matching the text. Raises: Type Description KeyError Cannot find the emoji based on the text. Source code in utils\\helpers.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def get_emote ( discord_text : str , / ) -> str : '''Return the Unicode emoji based on the name provided. Parameters ---------- discord_text : str Discord/Twitter name of the emoji including `:`. Example: `:grin:`. Returns ------- str The Unicode emoji matching the text. Raises ------ KeyError Cannot find the emoji based on the text. ''' ret = emoji . emojize ( discord_text , language = \"alias\" ) if ret == discord_text : raise KeyError ( f \"Emoji { discord_text } cannot be found.\" ) return ret get_friendly_permissions ( / , permissions : hikari . Permissions ) -> t . List [ str ] Return a list of highlighted permissions string presented in the permission provided. This returns the exact Discord's string of the permission. Parameters: Name Type Description Default permissions hikari . Permissions A permission object. required Returns: Type Description t . List [ str ] A list of highlighted permissions string represented in the permission provided. Notes Manage Events cannot be found in Hikari's documentation. Therefore, it is not included. Source code in utils\\helpers.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def get_friendly_permissions ( permissions : hikari . Permissions , / ) -> t . List [ str ]: '''Return a list of highlighted permissions string presented in the permission provided. This returns the exact Discord's string of the permission. Parameters ---------- permissions : hikari.Permissions A permission object. Returns ------- t.List[str] A list of highlighted permissions string represented in the permission provided. Notes ----- `Manage Events` cannot be found in Hikari's documentation. Therefore, it is not included. ''' l = [] for permission , text in __PERMISSIONS_MAPPING__ . items (): if permissions & permission : l . append ( f \"` { text } `\" ) return l get_default_embed ( * , author : hikari . Member = None , ** kwargs ) -> hikari . Embed Return a default embed to work with for consistency. Args: author: The author to set in the footer. **kwargs: hikari.Embed constructor. Parameters: Name Type Description Default author hikari . Member , optional The author to set in the footer. If not provided, the footer will not be edited. None **kwargs dict The options passed into hikari.Embed() . {} Returns: Type Description hikari . Embed The default embed. Source code in utils\\helpers.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 def get_default_embed ( * , author : hikari . Member = None , ** kwargs ) -> hikari . Embed : '''Return a default embed to work with for consistency. Args: author: The author to set in the footer. **kwargs: `hikari.Embed` constructor. Parameters ---------- author : hikari.Member, optional The author to set in the footer. If not provided, the footer will not be edited. **kwargs : dict The options passed into `hikari.Embed()`. Returns ------- hikari.Embed The default embed. ''' title = kwargs . get ( \"title\" ) url = kwargs . get ( \"url\" ) description = kwargs . get ( \"description\" ) color = kwargs . get ( \"color\" ) if kwargs . get ( \"color\" ) is not None else models . DefaultColor . green . value timestamp = kwargs . get ( \"timestamp\" ) embed = hikari . Embed ( title = title , url = url , description = description , color = color , timestamp = timestamp ) if author is not None : embed . set_footer ( text = f \"Requested by { author . username } \" , icon = author . avatar_url ) return embed mention ( / , mentionable_object : t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ]) -> str Return the appropriate mention string for a mentionable object. Parameters: Name Type Description Default mentionable_object t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ] The object to mention. required Returns: Type Description str The object's default mention string. Notes If the object is a hikari.PartialRole and it has the name @everyone , it'll return the name directly. Source code in utils\\helpers.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 def mention ( mentionable_object : t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ], / ) -> str : '''Return the appropriate mention string for a mentionable object. Parameters ---------- mentionable_object : t.Union[hikari.PartialUser, hikari.PartialRole, hikari.TextableGuildChannel] The object to mention. Returns ------- str The object's default mention string. Notes ----- If the object is a `hikari.PartialRole` and it has the name `@everyone`, it'll return the name directly. ''' if isinstance ( mentionable_object , hikari . PartialRole ): if mentionable_object . name == \"@everyone\" : return mentionable_object . name return mentionable_object . mention sleep_until ( / , when : dt . datetime ) async Wait until the specified time. Parameters: Name Type Description Default when dt . datetime The time to resume. Must be tz aware and in utc. required Source code in utils\\helpers.py 324 325 326 327 328 329 330 331 332 333 334 async def sleep_until ( when : dt . datetime , / ): '''Wait until the specified time. Parameters ---------- when : dt.datetime The time to resume. Must be tz aware and in utc. ''' time = when - dt . datetime . now () . astimezone () if time . total_seconds () > 0 : await asyncio . sleep ( time . total_seconds ()) striplist ( / , arr : t . Sequence [ str ]) -> str Return a string from a list, separated by comma. Parameters: Name Type Description Default arr t . Sequence [ str ] A sequence of objects that are convertible to str . required Returns: Type Description str The final string. Empty if sequence is empty. Source code in utils\\helpers.py 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 def striplist ( arr : t . Sequence [ str ], / ) -> str : '''Return a string from a list, separated by comma. Parameters ---------- arr : t.Sequence[str] A sequence of objects that are convertible to `str`. Returns ------- str The final string. Empty if sequence is empty. ''' return \", \" . join ( arr )","title":"helpers.py"},{"location":"dev/helpers/#utils.helpers.embed_from_dict","text":"Generate an embed from a dictionary. Parameters: Name Type Description Default data dict [ str , t . Any ] A valid dict representation of an embed. required Returns: Type Description hikari . Embed The embed from the dict. Source code in utils\\helpers.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def embed_from_dict ( data : dict [ str , t . Any ], / ) -> hikari . Embed : '''Generate an embed from a dictionary. Parameters ---------- data : dict[str, t.Any] A valid dict representation of an embed. Returns ------- hikari.Embed The embed from the dict. ''' embed = hikari . Embed () embed . title = data . get ( \"title\" , None ) embed . description = data . get ( \"description\" , None ) embed . url = data . get ( \"url\" , None ) if embed . title is not None : embed . title = str ( embed . title ) if embed . description is not None : embed . description = str ( embed . description ) if embed . url is not None : embed . url = str ( embed . url ) try : embed . color = hikari . Color ( data [ \"color\" ]) except KeyError : pass try : embed . timestamp = dt . datetime . fromtimestamp ( data [ 'timestamp' ], tz = dt . timezone . utc ) except KeyError : pass try : value = data [ \"thumbnail\" ] except KeyError : pass else : embed . set_thumbnail ( value ) try : value = data [ \"author\" ] except KeyError : pass else : embed . set_author ( ** value ) try : value = data [ \"fields\" ] except KeyError : pass else : for field in value : embed . add_field ( ** field ) try : value = data [ \"image\" ] except KeyError : pass else : embed . set_image ( value ) try : value = data [ \"footer\" ] except KeyError : pass else : embed . set_footer ( ** value ) return embed","title":"embed_from_dict()"},{"location":"dev/helpers/#utils.helpers.embed_to_dict","text":"Convert an embed into a dict object. Parameters: Name Type Description Default embed hikari . Embed An embed object to convert. required Returns: Type Description dict [ str , t . Any ] A dictionary that conforms Discord's structure. Source code in utils\\helpers.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def embed_to_dict ( embed : hikari . Embed , / ) -> dict [ str , t . Any ]: '''Convert an embed into a dict object. Parameters ---------- embed : hikari.Embed An embed object to convert. Returns ------- dict[str, t.Any] A dictionary that conforms Discord's structure. ''' d = {} if bool ( embed . title ): d [ \"title\" ] = embed . title if bool ( embed . description ): d [ \"description\" ] = embed . description if bool ( embed . url ): d [ \"url\" ] = embed . url if bool ( embed . color ): d [ \"color\" ] = int ( embed . color ) if bool ( embed . timestamp ): d [ \"timestamp\" ] = embed . timestamp . timestamp () if bool ( embed . thumbnail ): d [ \"thumbnail\" ] = embed . thumbnail . url if bool ( embed . author ): d [ \"author\" ] = { \"name\" : embed . author . name , \"url\" : embed . author . url } if bool ( embed . author . icon ): d [ \"author\" ][ \"icon\" ] = embed . author . icon . url if bool ( embed . fields ): d [ \"fields\" ] = [] for field in embed . fields : d [ \"fields\" ] . append ({ \"name\" : field . name , \"value\" : field . value , \"inline\" : field . is_inline }) if bool ( embed . image ): d [ \"image\" ] = embed . image . url if bool ( embed . footer ): d [ \"footer\" ] = { \"text\" : embed . footer . text } if bool ( embed . footer . icon ): d [ \"footer\" ][ \"icon\" ] = embed . footer . icon . url return d","title":"embed_to_dict()"},{"location":"dev/helpers/#utils.helpers.get_emote","text":"Return the Unicode emoji based on the name provided. Parameters: Name Type Description Default discord_text str Discord/Twitter name of the emoji including : . Example: :grin: . required Returns: Type Description str The Unicode emoji matching the text. Raises: Type Description KeyError Cannot find the emoji based on the text. Source code in utils\\helpers.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def get_emote ( discord_text : str , / ) -> str : '''Return the Unicode emoji based on the name provided. Parameters ---------- discord_text : str Discord/Twitter name of the emoji including `:`. Example: `:grin:`. Returns ------- str The Unicode emoji matching the text. Raises ------ KeyError Cannot find the emoji based on the text. ''' ret = emoji . emojize ( discord_text , language = \"alias\" ) if ret == discord_text : raise KeyError ( f \"Emoji { discord_text } cannot be found.\" ) return ret","title":"get_emote()"},{"location":"dev/helpers/#utils.helpers.get_friendly_permissions","text":"Return a list of highlighted permissions string presented in the permission provided. This returns the exact Discord's string of the permission. Parameters: Name Type Description Default permissions hikari . Permissions A permission object. required Returns: Type Description t . List [ str ] A list of highlighted permissions string represented in the permission provided.","title":"get_friendly_permissions()"},{"location":"dev/helpers/#utils.helpers.get_friendly_permissions--notes","text":"Manage Events cannot be found in Hikari's documentation. Therefore, it is not included. Source code in utils\\helpers.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def get_friendly_permissions ( permissions : hikari . Permissions , / ) -> t . List [ str ]: '''Return a list of highlighted permissions string presented in the permission provided. This returns the exact Discord's string of the permission. Parameters ---------- permissions : hikari.Permissions A permission object. Returns ------- t.List[str] A list of highlighted permissions string represented in the permission provided. Notes ----- `Manage Events` cannot be found in Hikari's documentation. Therefore, it is not included. ''' l = [] for permission , text in __PERMISSIONS_MAPPING__ . items (): if permissions & permission : l . append ( f \"` { text } `\" ) return l","title":"Notes"},{"location":"dev/helpers/#utils.helpers.get_default_embed","text":"Return a default embed to work with for consistency. Args: author: The author to set in the footer. **kwargs: hikari.Embed constructor. Parameters: Name Type Description Default author hikari . Member , optional The author to set in the footer. If not provided, the footer will not be edited. None **kwargs dict The options passed into hikari.Embed() . {} Returns: Type Description hikari . Embed The default embed. Source code in utils\\helpers.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 def get_default_embed ( * , author : hikari . Member = None , ** kwargs ) -> hikari . Embed : '''Return a default embed to work with for consistency. Args: author: The author to set in the footer. **kwargs: `hikari.Embed` constructor. Parameters ---------- author : hikari.Member, optional The author to set in the footer. If not provided, the footer will not be edited. **kwargs : dict The options passed into `hikari.Embed()`. Returns ------- hikari.Embed The default embed. ''' title = kwargs . get ( \"title\" ) url = kwargs . get ( \"url\" ) description = kwargs . get ( \"description\" ) color = kwargs . get ( \"color\" ) if kwargs . get ( \"color\" ) is not None else models . DefaultColor . green . value timestamp = kwargs . get ( \"timestamp\" ) embed = hikari . Embed ( title = title , url = url , description = description , color = color , timestamp = timestamp ) if author is not None : embed . set_footer ( text = f \"Requested by { author . username } \" , icon = author . avatar_url ) return embed","title":"get_default_embed()"},{"location":"dev/helpers/#utils.helpers.mention","text":"Return the appropriate mention string for a mentionable object. Parameters: Name Type Description Default mentionable_object t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ] The object to mention. required Returns: Type Description str The object's default mention string.","title":"mention()"},{"location":"dev/helpers/#utils.helpers.mention--notes","text":"If the object is a hikari.PartialRole and it has the name @everyone , it'll return the name directly. Source code in utils\\helpers.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 def mention ( mentionable_object : t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ], / ) -> str : '''Return the appropriate mention string for a mentionable object. Parameters ---------- mentionable_object : t.Union[hikari.PartialUser, hikari.PartialRole, hikari.TextableGuildChannel] The object to mention. Returns ------- str The object's default mention string. Notes ----- If the object is a `hikari.PartialRole` and it has the name `@everyone`, it'll return the name directly. ''' if isinstance ( mentionable_object , hikari . PartialRole ): if mentionable_object . name == \"@everyone\" : return mentionable_object . name return mentionable_object . mention","title":"Notes"},{"location":"dev/helpers/#utils.helpers.sleep_until","text":"Wait until the specified time. Parameters: Name Type Description Default when dt . datetime The time to resume. Must be tz aware and in utc. required Source code in utils\\helpers.py 324 325 326 327 328 329 330 331 332 333 334 async def sleep_until ( when : dt . datetime , / ): '''Wait until the specified time. Parameters ---------- when : dt.datetime The time to resume. Must be tz aware and in utc. ''' time = when - dt . datetime . now () . astimezone () if time . total_seconds () > 0 : await asyncio . sleep ( time . total_seconds ())","title":"sleep_until()"},{"location":"dev/helpers/#utils.helpers.striplist","text":"Return a string from a list, separated by comma. Parameters: Name Type Description Default arr t . Sequence [ str ] A sequence of objects that are convertible to str . required Returns: Type Description str The final string. Empty if sequence is empty. Source code in utils\\helpers.py 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 def striplist ( arr : t . Sequence [ str ], / ) -> str : '''Return a string from a list, separated by comma. Parameters ---------- arr : t.Sequence[str] A sequence of objects that are convertible to `str`. Returns ------- str The final string. Empty if sequence is empty. ''' return \", \" . join ( arr )","title":"striplist()"},{"location":"dev/menu/","text":"nav/navigator.py Contains common forms of menu navigator. StopButtonDelete Bases: nav . StopButton A custom button to stop the navigator AND delete the message. This button should only be used in nav.NavigatorView . Source code in utils\\nav\\navigator.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class StopButtonDelete ( nav . StopButton ): ''' A custom button to stop the navigator AND delete the message. This button should only be used in `nav.NavigatorView`. ''' async def callback ( self , context : miru . Context ) -> None : # Reference: https://github.com/HyperGH/hikari-miru/blob/main/miru/ext/nav/buttons.py#L239 #pylint: disable=protected-access view : nav . NavigatorView = self . view if not view . message and not view . _inter : return if view . _inter and view . ephemeral : await view . _inter . delete_initial_response () elif view . message : await view . message . delete () #pylint: enable=protected-access view . stop () ButtonNavigator Bases: nav . NavigatorView The default navigator. Source code in utils\\nav\\navigator.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 class ButtonNavigator ( nav . NavigatorView ): ''' The default navigator. ''' def __init__ ( self , * args , ** kwargs ) -> None : super () . __init__ ( * args , ** kwargs ) for index , item in enumerate ( self . pages ): if isinstance ( item , hikari . Embed ): item . set_footer ( f \"Page { index + 1 } / { len ( self . pages ) } \" ) def get_default_buttons ( self ) -> t . List [ nav . NavButton [ nav . NavigatorView ]]: ''' Returns a list of default buttons. These are `FirstButton()`, `PrevButton()`, `NextButton()`, `LastButton()`, and `StopButtonDelete()`. Returns ------- t.List[nav.NavButton[nav.NavigatorView]] A list of default buttons. ''' return [ nav . FirstButton (), nav . PrevButton (), nav . NextButton (), nav . LastButton (), StopButtonDelete ()] async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout () get_default_buttons () -> t . List [ nav . NavButton [ nav . NavigatorView ]] Returns a list of default buttons. These are FirstButton() , PrevButton() , NextButton() , LastButton() , and StopButtonDelete() . Returns: Type Description t . List [ nav . NavButton [ nav . NavigatorView ]] A list of default buttons. Source code in utils\\nav\\navigator.py 100 101 102 103 104 105 106 107 108 109 110 111 def get_default_buttons ( self ) -> t . List [ nav . NavButton [ nav . NavigatorView ]]: ''' Returns a list of default buttons. These are `FirstButton()`, `PrevButton()`, `NextButton()`, `LastButton()`, and `StopButtonDelete()`. Returns ------- t.List[nav.NavButton[nav.NavigatorView]] A list of default buttons. ''' return [ nav . FirstButton (), nav . PrevButton (), nav . NextButton (), nav . LastButton (), StopButtonDelete ()] on_timeout () -> None async Called when the view times out. Notes This adds the timeout button into the menu. Source code in utils\\nav\\navigator.py 113 114 115 116 117 118 119 120 121 122 async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout () ItemListBuilder A builder to fit a list of item into a navigator appropriately. (This is experimental and can be removed at any time). Source code in utils\\nav\\navigator.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 class ItemListBuilder : '''A builder to fit a list of item into a navigator appropriately. (This is experimental and can be removed at any time).''' def __init__ ( self , items : list [ T ], max_item_per_page : int ): '''Construct the builder. Parameters ---------- items : list[T] A list of items. max_item_per_page : int The max amount of item to display before moving to a new page. ''' self . items = items self . max_item = max_item_per_page self . page_start_formatter : t . Callable [[ int , T ], hikari . Embed ] = None self . entry_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = None self . page_end_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = lambda embed , index , item : None def set_page_start_formatter ( self , callback : t . Callable [[ int , T ], hikari . Embed ], / ): '''Set this callback as the formatter to run whenever a new page is requested to be created. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[int, T], hikari.Embed] The callback to use. It must accept an `int` (index of the item), the item itself, and return a `hikari.Embed`. ''' self . page_start_formatter = callback def set_entry_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run while iterating through the item list. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . entry_formatter = callback def set_page_end_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run once adding items to a page is finished. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . page_end_formatter = callback def build ( self , * , page_type = ButtonNavigator ): '''Start the formatting process and return an object of `page_type`. Warnings -------- The builder must provide at least `page_start_formatter` and either `entry_formatter` or `page_end_formatter` before this method is called. Parameters ---------- page_type : t.Type, optional The type of navigator to use, by default ButtonNavigator. This must have a `pages` argument accepting a list of `hikari.Embed`. Returns ------- t.Any The type passed into the constructor, by default ButtonNavigator. Raises ------ NotImplementedError `page_start_formatter` is empty or both `entry_formatter` and `page_end_formatter` are empty. ''' if self . page_start_formatter is None or ( self . entry_formatter is None and self . page_end_formatter is None ): raise NotImplementedError ( \"Not enough formatters are defined.\" ) embeds : list [ hikari . Embed ] = [] embed : hikari . Embed = None for index , item in enumerate ( self . items ): if embed is None : embed = self . page_start_formatter ( index , item ) self . entry_formatter ( embed , index , item ) if index % self . max_item == self . max_item - 1 : self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) embed = None if embed is not None : # TODO: Fix undefined-loop-variable self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) return page_type ( pages = embeds ) __init__ ( items : list [ T ], max_item_per_page : int ) Construct the builder. Parameters: Name Type Description Default items list [ T ] A list of items. required max_item_per_page int The max amount of item to display before moving to a new page. required Source code in utils\\nav\\navigator.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def __init__ ( self , items : list [ T ], max_item_per_page : int ): '''Construct the builder. Parameters ---------- items : list[T] A list of items. max_item_per_page : int The max amount of item to display before moving to a new page. ''' self . items = items self . max_item = max_item_per_page self . page_start_formatter : t . Callable [[ int , T ], hikari . Embed ] = None self . entry_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = None self . page_end_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = lambda embed , index , item : None set_page_start_formatter ( / , callback : t . Callable [[ int , T ], hikari . Embed ]) Set this callback as the formatter to run whenever a new page is requested to be created. Notes This is recommended to use as a decorator. Parameters: Name Type Description Default callback t . Callable [[ int , T ], hikari . Embed ] The callback to use. It must accept an int (index of the item), the item itself, and return a hikari.Embed . required Source code in utils\\nav\\navigator.py 144 145 146 147 148 149 150 151 152 153 154 155 156 def set_page_start_formatter ( self , callback : t . Callable [[ int , T ], hikari . Embed ], / ): '''Set this callback as the formatter to run whenever a new page is requested to be created. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[int, T], hikari.Embed] The callback to use. It must accept an `int` (index of the item), the item itself, and return a `hikari.Embed`. ''' self . page_start_formatter = callback set_entry_formatter ( / , callback : t . Callable [[ hikari . Embed , int , T ], None ]) Set this callback as the formatter to run while iterating through the item list. Notes This is recommended to use as a decorator. Parameters: Name Type Description Default callback t . Callable [[ hikari . Embed , int , T ], None] The callback to use. It must accept a hikari.Embed (the page it's editing), an int (index of the item), and the item itself. required Source code in utils\\nav\\navigator.py 157 158 159 160 161 162 163 164 165 166 167 168 169 def set_entry_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run while iterating through the item list. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . entry_formatter = callback set_page_end_formatter ( / , callback : t . Callable [[ hikari . Embed , int , T ], None ]) Set this callback as the formatter to run once adding items to a page is finished. Notes This is recommended to use as a decorator. Parameters: Name Type Description Default callback t . Callable [[ hikari . Embed , int , T ], None] The callback to use. It must accept a hikari.Embed (the page it's editing), an int (index of the item), and the item itself. required Source code in utils\\nav\\navigator.py 170 171 172 173 174 175 176 177 178 179 180 181 182 def set_page_end_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run once adding items to a page is finished. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . page_end_formatter = callback build ( * , page_type = ButtonNavigator ) Start the formatting process and return an object of page_type . Warnings The builder must provide at least page_start_formatter and either entry_formatter or page_end_formatter before this method is called. Parameters: Name Type Description Default page_type t . Type , optional The type of navigator to use, by default ButtonNavigator. This must have a pages argument accepting a list of hikari.Embed . ButtonNavigator Returns: Type Description t . Any The type passed into the constructor, by default ButtonNavigator. Raises: Type Description NotImplementedError page_start_formatter is empty or both entry_formatter and page_end_formatter are empty. Source code in utils\\nav\\navigator.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def build ( self , * , page_type = ButtonNavigator ): '''Start the formatting process and return an object of `page_type`. Warnings -------- The builder must provide at least `page_start_formatter` and either `entry_formatter` or `page_end_formatter` before this method is called. Parameters ---------- page_type : t.Type, optional The type of navigator to use, by default ButtonNavigator. This must have a `pages` argument accepting a list of `hikari.Embed`. Returns ------- t.Any The type passed into the constructor, by default ButtonNavigator. Raises ------ NotImplementedError `page_start_formatter` is empty or both `entry_formatter` and `page_end_formatter` are empty. ''' if self . page_start_formatter is None or ( self . entry_formatter is None and self . page_end_formatter is None ): raise NotImplementedError ( \"Not enough formatters are defined.\" ) embeds : list [ hikari . Embed ] = [] embed : hikari . Embed = None for index , item in enumerate ( self . items ): if embed is None : embed = self . page_start_formatter ( index , item ) self . entry_formatter ( embed , index , item ) if index % self . max_item == self . max_item - 1 : self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) embed = None if embed is not None : # TODO: Fix undefined-loop-variable self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) return page_type ( pages = embeds ) run_view ( view : miru . View , ctx : lightbulb . Context , initial_content : t . Union [ str , hikari . Embed ] = None ) -> None async A simplified way to run a miru.View . Parameters: Name Type Description Default view miru . View A miru.View or its subclasses. required ctx lightbulb . Context A context to send the view. required initial_content t . Union [ str , hikari . Embed ], optional The content to first display. This is optional for nav.NavigatorView and its subclasses. None Raises: Type Description TypeError initial_content is not provided, but view is not type nav.NavigatorView . hikari . BadRequestError Maybe ctx is deferred. Source code in utils\\nav\\navigator.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 async def run_view ( view : miru . View , ctx : lightbulb . Context , initial_content : t . Union [ str , hikari . Embed ] = None ) -> None : '''A simplified way to run a `miru.View`. Parameters ---------- view : miru.View A `miru.View` or its subclasses. ctx : lightbulb.Context A context to send the view. initial_content : t.Union[str, hikari.Embed], optional The content to first display. This is optional for `nav.NavigatorView` and its subclasses. Raises ------ TypeError `initial_content` is not provided, but `view` is not type `nav.NavigatorView`. hikari.BadRequestError Maybe `ctx` is deferred. ''' if initial_content is None : if isinstance ( view , nav . NavigatorView ): # nav.NavigatorView cannot be run on an interaction with a response already (typically deferring) # so we have to do things manually here. # Reference: https://github.com/HyperGH/hikari-miru/blob/main/miru/ext/nav/navigator.py#L227 for button in view . children : if isinstance ( button , nav . NavButton ): await button . before_page_change () initial_content = view . pages [ view . current_page ] #await view.send(ctx.interaction) #return else : raise TypeError ( \"'initial_content' must be provided if 'view' is not type 'NavigatorView'.\" ) resp_proxy = await ctx . respond ( initial_content , components = view . build ()) view . start ( await resp_proxy . message ()) await view . wait () timeout_button () -> nav . NavButton Return a nav.NavButton to be use in nav.NavigatorView . This button is safe to use in miru.View . Returns: Type Description nav . NavButton The default timeout button. Source code in utils\\nav\\navigator.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def timeout_button () -> nav . NavButton : '''Return a `nav.NavButton` to be use in `nav.NavigatorView`. This button is safe to use in `miru.View`. Returns ------- nav.NavButton The default timeout button. ''' return nav . NavButton ( style = hikari . ButtonStyle . SECONDARY , emoji = helpers . get_emote ( \":clock12:\" ), custom_id = \"timeout_button\" , disabled = True ) nav/confirm.py Contains a confirmation menu. ConfirmView Bases: miru . View A confirmation menu. Source code in utils\\nav\\confirm.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class ConfirmView ( miru . View ): ''' A confirmation menu. ''' def __init__ ( self , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None : super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . result : t . Optional [ bool ] = None @miru . button ( label = \"Yes\" , emoji = helpers . get_emote ( \":white_check_mark:\" ), style = hikari . ButtonStyle . SUCCESS , custom_id = \"yes_button\" ) async def yes_button ( self , _ : miru . Button , __ : miru . Context ): self . result = True self . stop () @miru . button ( label = \"No\" , emoji = helpers . get_emote ( \":negative_squared_cross_mark:\" ), style = hikari . ButtonStyle . DANGER , custom_id = \"no_button\" ) async def no_button ( self , _ : miru . Button , __ : miru . Context ): self . result = False self . stop () async def wait ( self ) -> t . Optional [ bool ]: ''' Wait until the view times out or stops manually. Return the result of the confirmation, or `None` if it times out. ''' await super () . wait () await self . message . delete () return self . result wait () -> t . Optional [ bool ] async Wait until the view times out or stops manually. Return the result of the confirmation, or None if it times out. Source code in utils\\nav\\confirm.py 28 29 30 31 32 33 34 35 36 37 async def wait ( self ) -> t . Optional [ bool ]: ''' Wait until the view times out or stops manually. Return the result of the confirmation, or `None` if it times out. ''' await super () . wait () await self . message . delete () return self . result nav/menu.py Contains everything needed to build a complex menu. MenuComponent A tree-like node that represents the menu's option structure. The node has two \"states\": a regular node state and a fake node. A regular node state is when the options is a dictionary, which will determine the child nodes. A fake node state is when the options is a list of contents to display. In this case, the node's content is set to None , and no further child nodes can be created from this node. The child nodes can be accessed using dictionary notation IF there are child nodes. Source code in utils\\nav\\menu.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class MenuComponent : ''' A tree-like node that represents the menu's option structure. The node has two \"states\": a regular node state and a fake node. A regular node state is when the `options` is a dictionary, which will determine the child nodes. A fake node state is when the `options` is a list of contents to display. In this case, the node's content is set to `None`, and no further child nodes can be created from this node. The child nodes can be accessed using dictionary notation IF there are child nodes. ''' def __init__ ( self , content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ): ''' Create a node that stores the content and optionally, its options. The `options` can be a list, which will set the content to `None` regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a `dict` through `options`, but instead, use `.add_options()`. ''' self . content = content self . options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = options self . __parent__ : t . Optional [ MenuComponent ] = None if isinstance ( self . options , list ): self . content = None def add_option ( self , key : MenuButton , content : PageLike ) -> MenuComponent : '''Add an option into the current node. Return the newly added node to further add more layers. Warnings -------- The returned object is the newly added object, not the current object. Parameters ---------- key : MenuButton The button for the new option. content : PageLike The content of the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. ''' if isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) if self . options is None : self . options = { key : MenuComponent ( content )} self . options [ key ] . __parent__ = self return self . options [ key ] elif self . options . get ( key ) is None : component = MenuComponent ( content ) component . __parent__ = self self . options [ key ] = component return self . options [ key ] else : raise LookupError ( \"Duplicated keys.\" ) def add_options ( self , options : t . Dict [ MenuButton , PageLike ]): '''Add multiple options into the current node. Warnings -------- This will overwrite any possible duplicate keys. Parameters ---------- options : t.Dict[MenuButton, PageLike] A mapping of {button: content}. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) for key in options : self . options [ key ] = MenuComponent ( options [ key ]) self . options [ key ] . __parent__ = self def add_list_options ( self , key : str , contents : t . List [ PageLike ]) -> MenuComponent : '''Append a fake node to this node. Return the newly added node to do whatever you want. Parameters ---------- key : str The button for the new option. contents : t.List[PageLike] A list of content for the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) component = None if len ( contents ) == 1 : component = MenuComponent ( content = contents [ 0 ]) else : component = MenuComponent ( content = None , options = contents ) component . __parent__ = self self . options [ key ] = component return component def force_add_list_options ( self , contents : t . List [ PageLike ]): '''Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters ---------- contents : t.List[PageLike] A list of content for the option. ''' if self . options is None : self . options = [] for content in contents : self . options . append ( content ) self . content = None def __getitem__ ( self , key : MenuButton ) -> t . Optional [ MenuComponent ]: '''Return the MenuComponent with the matching key, or `None` if none was found. Parameters ---------- key : MenuButton The option you're retrieving. Returns ------- t.Optional[MenuComponent] The option with matching key, or `None` if none was found. Raises ------ IndexError The current MenuComponent is already a fake node. ''' if isinstance ( self . options , dict ): return self . options . get ( key ) raise IndexError ( \"Index doesn't exist.\" ) __init__ ( content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ) Create a node that stores the content and optionally, its options. The options can be a list, which will set the content to None regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a dict through options , but instead, use .add_options() . Source code in utils\\nav\\menu.py 26 27 28 29 30 31 32 33 34 35 36 37 38 def __init__ ( self , content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ): ''' Create a node that stores the content and optionally, its options. The `options` can be a list, which will set the content to `None` regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a `dict` through `options`, but instead, use `.add_options()`. ''' self . content = content self . options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = options self . __parent__ : t . Optional [ MenuComponent ] = None if isinstance ( self . options , list ): self . content = None add_option ( key : MenuButton , content : PageLike ) -> MenuComponent Add an option into the current node. Return the newly added node to further add more layers. Warnings The returned object is the newly added object, not the current object. Parameters: Name Type Description Default key MenuButton The button for the new option. required content PageLike The content of the new option. required Returns: Type Description MenuComponent The newly added option. Raises: Type Description KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. Source code in utils\\nav\\menu.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def add_option ( self , key : MenuButton , content : PageLike ) -> MenuComponent : '''Add an option into the current node. Return the newly added node to further add more layers. Warnings -------- The returned object is the newly added object, not the current object. Parameters ---------- key : MenuButton The button for the new option. content : PageLike The content of the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. ''' if isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) if self . options is None : self . options = { key : MenuComponent ( content )} self . options [ key ] . __parent__ = self return self . options [ key ] elif self . options . get ( key ) is None : component = MenuComponent ( content ) component . __parent__ = self self . options [ key ] = component return self . options [ key ] else : raise LookupError ( \"Duplicated keys.\" ) add_options ( options : t . Dict [ MenuButton , PageLike ]) Add multiple options into the current node. Warnings This will overwrite any possible duplicate keys. Parameters: Name Type Description Default options t . Dict [ MenuButton , PageLike ] A mapping of {button: content}. required Raises: Type Description KeyError The current MenuComponent is already a fake node. Source code in utils\\nav\\menu.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def add_options ( self , options : t . Dict [ MenuButton , PageLike ]): '''Add multiple options into the current node. Warnings -------- This will overwrite any possible duplicate keys. Parameters ---------- options : t.Dict[MenuButton, PageLike] A mapping of {button: content}. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) for key in options : self . options [ key ] = MenuComponent ( options [ key ]) self . options [ key ] . __parent__ = self add_list_options ( key : str , contents : t . List [ PageLike ]) -> MenuComponent Append a fake node to this node. Return the newly added node to do whatever you want. Parameters: Name Type Description Default key str The button for the new option. required contents t . List [ PageLike ] A list of content for the new option. required Returns: Type Description MenuComponent The newly added option. Raises: Type Description KeyError The current MenuComponent is already a fake node. Source code in utils\\nav\\menu.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def add_list_options ( self , key : str , contents : t . List [ PageLike ]) -> MenuComponent : '''Append a fake node to this node. Return the newly added node to do whatever you want. Parameters ---------- key : str The button for the new option. contents : t.List[PageLike] A list of content for the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) component = None if len ( contents ) == 1 : component = MenuComponent ( content = contents [ 0 ]) else : component = MenuComponent ( content = None , options = contents ) component . __parent__ = self self . options [ key ] = component return component force_add_list_options ( contents : t . List [ PageLike ]) Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters: Name Type Description Default contents t . List [ PageLike ] A list of content for the option. required Source code in utils\\nav\\menu.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def force_add_list_options ( self , contents : t . List [ PageLike ]): '''Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters ---------- contents : t.List[PageLike] A list of content for the option. ''' if self . options is None : self . options = [] for content in contents : self . options . append ( content ) self . content = None __getitem__ ( key : MenuButton ) -> t . Optional [ MenuComponent ] Return the MenuComponent with the matching key, or None if none was found. Parameters: Name Type Description Default key MenuButton The option you're retrieving. required Returns: Type Description t . Optional [ MenuComponent ] The option with matching key, or None if none was found. Raises: Type Description IndexError The current MenuComponent is already a fake node. Source code in utils\\nav\\menu.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def __getitem__ ( self , key : MenuButton ) -> t . Optional [ MenuComponent ]: '''Return the MenuComponent with the matching key, or `None` if none was found. Parameters ---------- key : MenuButton The option you're retrieving. Returns ------- t.Optional[MenuComponent] The option with matching key, or `None` if none was found. Raises ------ IndexError The current MenuComponent is already a fake node. ''' if isinstance ( self . options , dict ): return self . options . get ( key ) raise IndexError ( \"Index doesn't exist.\" ) MenuButton Bases: miru . Button Represents a generic button inside ComplexView . This should only be used in ComplexView . Source code in utils\\nav\\menu.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 class MenuButton ( miru . Button ): '''Represents a generic button inside `ComplexView`. This should only be used in `ComplexView`.''' async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the option if the current `MenuComponent` is not a fake node. ''' view : ComplexView = self . view if isinstance ( view . menu . options , dict ): view . menu = view . menu . options [ self ] await view . update () callback ( _ : miru . Context ) -> None async Calls when the button is pressed. It'll move to the option if the current MenuComponent is not a fake node. Source code in utils\\nav\\menu.py 186 187 188 189 190 191 192 193 194 195 196 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the option if the current `MenuComponent` is not a fake node. ''' view : ComplexView = self . view if isinstance ( view . menu . options , dict ): view . menu = view . menu . options [ self ] await view . update () ReturnMenuButton Bases: MenuButton Represents a return button. Source code in utils\\nav\\menu.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 class ReturnMenuButton ( MenuButton ): '''Represents a return button.''' def __init__ ( self ) -> None : super () . __init__ ( style = hikari . ButtonStyle . SECONDARY , emoji = helpers . get_emote ( \":arrow_up_small:\" ), custom_id = \"return_button\" ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the parent node if it is not `None`. Raises ------ RuntimeError The return button is in the root menu. ''' view : ComplexView = self . view if view . menu . __parent__ is not None : view . menu = view . menu . __parent__ view . current_page = 0 else : raise RuntimeError ( \"A return button is available in the root menu.\" ) await view . update () callback ( _ : miru . Context ) -> None async Calls when the button is pressed. It'll move to the parent node if it is not None . Raises: Type Description RuntimeError The return button is in the root menu. Source code in utils\\nav\\menu.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the parent node if it is not `None`. Raises ------ RuntimeError The return button is in the root menu. ''' view : ComplexView = self . view if view . menu . __parent__ is not None : view . menu = view . menu . __parent__ view . current_page = 0 else : raise RuntimeError ( \"A return button is available in the root menu.\" ) await view . update () StopMenuButton Bases: MenuButton Represents a terminate button. Source code in utils\\nav\\menu.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 class StopMenuButton ( MenuButton ): '''Represents a terminate button.''' def __init__ ( self ) -> None : super () . __init__ ( style = hikari . ButtonStyle . DANGER , emoji = helpers . get_emote ( \":stop_button:\" ), custom_id = \"stop_button\" ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll stop the `ComplexView` and delete the menu. ''' view : ComplexView = self . view view . stop () if view . message : await view . message . delete () callback ( _ : miru . Context ) -> None async Calls when the button is pressed. It'll stop the ComplexView and delete the menu. Source code in utils\\nav\\menu.py 236 237 238 239 240 241 242 243 244 245 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll stop the `ComplexView` and delete the menu. ''' view : ComplexView = self . view view . stop () if view . message : await view . message . delete () NextMenuButton Bases: MenuButton A button to move to the next page list. This behaves similarly to nav.NextButton() . Source code in utils\\nav\\menu.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 class NextMenuButton ( MenuButton ): '''A button to move to the next page list. This behaves similarly to `nav.NextButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"next_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":arrow_forward:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. ''' view : ComplexView = self . view view . current_page += 1 if view . current_page > len ( view . menu . options ) - 1 : view . current_page = 0 await view . update () callback ( _ : miru . Context ) -> None async Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. Source code in utils\\nav\\menu.py 262 263 264 265 266 267 268 269 270 271 272 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. ''' view : ComplexView = self . view view . current_page += 1 if view . current_page > len ( view . menu . options ) - 1 : view . current_page = 0 await view . update () PrevMenuButton Bases: MenuButton A button to move to the previous page list. This behaves similarly to nav.PrevButton() . Source code in utils\\nav\\menu.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 class PrevMenuButton ( MenuButton ): '''A button to move to the previous page list. This behaves similarly to `nav.PrevButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"prev_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":arrow_backward:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. ''' view : ComplexView = self . view view . current_page -= 1 if view . current_page < 0 : view . current_page = len ( view . menu . options ) - 1 await view . update () callback ( _ : miru . Context ) -> None async Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. Source code in utils\\nav\\menu.py 289 290 291 292 293 294 295 296 297 298 299 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. ''' view : ComplexView = self . view view . current_page -= 1 if view . current_page < 0 : view . current_page = len ( view . menu . options ) - 1 await view . update () FirstMenuButton Bases: MenuButton A button to move to the first page list. This behaves similarly to nav.FirstButton() . Source code in utils\\nav\\menu.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 class FirstMenuButton ( MenuButton ): '''A button to move to the first page list. This behaves similarly to `nav.FirstButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"first_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":last_track_button:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the first page. ''' view : ComplexView = self . view view . current_page = 0 await view . update () callback ( _ : miru . Context ) -> None async Calls when the button is pressed. Move to the first page. Source code in utils\\nav\\menu.py 316 317 318 319 320 321 322 323 324 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the first page. ''' view : ComplexView = self . view view . current_page = 0 await view . update () LastMenuButton Bases: MenuButton A button to move to the last page list. This behaves similarly to nav.LastButton() . Source code in utils\\nav\\menu.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 class LastMenuButton ( MenuButton ): '''A button to move to the last page list. This behaves similarly to `nav.LastButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"last_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":next_track_button:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the last page. ''' view : ComplexView = self . view view . current_page = len ( view . menu . options ) - 1 await view . update () callback ( _ : miru . Context ) -> None async Calls when the button is pressed. Move to the last page. Source code in utils\\nav\\menu.py 341 342 343 344 345 346 347 348 349 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the last page. ''' view : ComplexView = self . view view . current_page = len ( view . menu . options ) - 1 await view . update () ComplexView Bases: miru . View A complex menu. Source code in utils\\nav\\menu.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 class ComplexView ( miru . View ): '''A complex menu.''' def __init__ ( self , menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None : '''Construct a complex menu. Parameters ---------- menu : MenuComponent A `MenuComponent` tree. This must be a root node. timeout : t.Optional[float], optional How long (in seconds) the menu should accept interactions. Default to `120`. autodefer : bool, optional Whether or not the menu should defer when possible. Default to `True`. ''' super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . menu = menu # For list menu self . current_page : int = 0 def _update_button ( self ) -> None : ''' Update the button based on the current menu state. ''' self . clear_items () if isinstance ( self . menu . options , dict ): for button in self . menu . options : self . add_item ( button ) elif isinstance ( self . menu . options , list ): # TODO: Might optimize this so it wouldn't reset the buttons. self . add_item ( FirstMenuButton ()) self . add_item ( PrevMenuButton ()) self . add_item ( NextMenuButton ()) self . add_item ( LastMenuButton ()) for index , item in enumerate ( self . menu . options ): if isinstance ( item , hikari . Embed ): item . set_footer ( f \"Page { index + 1 } / { len ( self . menu . options ) } \" ) if self . menu . __parent__ is None : self . add_item ( StopMenuButton ()) else : self . add_item ( ReturnMenuButton ()) async def update ( self ) -> None : '''Update the menu. This shouldn't be called by the user. Raises ------ RuntimeError The message is not found (for unknown reasons). Notes ----- All `MenuButton` should call this method inside their callbacks once it's done with everything. ''' self . _update_button () content = self . menu . content # If view is in a list menu. Can also check if menu.content is None instead. if isinstance ( self . menu . options , list ): content = self . menu . options [ self . current_page ] if self . message : await self . message . edit ( content , components = self . build ()) else : raise RuntimeError ( \"Oops ComplexView.update() failed.\" ) async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout () async def run ( self , ctx : lightbulb . Context ) -> None : '''Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters ---------- ctx : lightbulb.Context A `lightbulb` context. ''' self . _update_button () await run_view ( self , ctx , self . menu . content ) __init__ ( menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None Construct a complex menu. Parameters: Name Type Description Default menu MenuComponent A MenuComponent tree. This must be a root node. required timeout t . Optional [ float ], optional How long (in seconds) the menu should accept interactions. Default to 120 . 120 autodefer bool , optional Whether or not the menu should defer when possible. Default to True . True Source code in utils\\nav\\menu.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 def __init__ ( self , menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None : '''Construct a complex menu. Parameters ---------- menu : MenuComponent A `MenuComponent` tree. This must be a root node. timeout : t.Optional[float], optional How long (in seconds) the menu should accept interactions. Default to `120`. autodefer : bool, optional Whether or not the menu should defer when possible. Default to `True`. ''' super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . menu = menu # For list menu self . current_page : int = 0 update () -> None async Update the menu. This shouldn't be called by the user. Raises: Type Description RuntimeError The message is not found (for unknown reasons). Notes All MenuButton should call this method inside their callbacks once it's done with everything. Source code in utils\\nav\\menu.py 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 async def update ( self ) -> None : '''Update the menu. This shouldn't be called by the user. Raises ------ RuntimeError The message is not found (for unknown reasons). Notes ----- All `MenuButton` should call this method inside their callbacks once it's done with everything. ''' self . _update_button () content = self . menu . content # If view is in a list menu. Can also check if menu.content is None instead. if isinstance ( self . menu . options , list ): content = self . menu . options [ self . current_page ] if self . message : await self . message . edit ( content , components = self . build ()) else : raise RuntimeError ( \"Oops ComplexView.update() failed.\" ) on_timeout () -> None async Called when the view times out. Notes This adds the timeout button into the menu. Source code in utils\\nav\\menu.py 421 422 423 424 425 426 427 428 429 430 async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout () run ( ctx : lightbulb . Context ) -> None async Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters: Name Type Description Default ctx lightbulb . Context A lightbulb context. required Source code in utils\\nav\\menu.py 432 433 434 435 436 437 438 439 440 441 442 443 444 async def run ( self , ctx : lightbulb . Context ) -> None : '''Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters ---------- ctx : lightbulb.Context A `lightbulb` context. ''' self . _update_button () await run_view ( self , ctx , self . menu . content )","title":"nav"},{"location":"dev/menu/#navnavigatorpy","text":"Contains common forms of menu navigator.","title":"nav/navigator.py"},{"location":"dev/menu/#utils.nav.navigator.StopButtonDelete","text":"Bases: nav . StopButton A custom button to stop the navigator AND delete the message. This button should only be used in nav.NavigatorView . Source code in utils\\nav\\navigator.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class StopButtonDelete ( nav . StopButton ): ''' A custom button to stop the navigator AND delete the message. This button should only be used in `nav.NavigatorView`. ''' async def callback ( self , context : miru . Context ) -> None : # Reference: https://github.com/HyperGH/hikari-miru/blob/main/miru/ext/nav/buttons.py#L239 #pylint: disable=protected-access view : nav . NavigatorView = self . view if not view . message and not view . _inter : return if view . _inter and view . ephemeral : await view . _inter . delete_initial_response () elif view . message : await view . message . delete () #pylint: enable=protected-access view . stop ()","title":"StopButtonDelete"},{"location":"dev/menu/#utils.nav.navigator.ButtonNavigator","text":"Bases: nav . NavigatorView The default navigator. Source code in utils\\nav\\navigator.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 class ButtonNavigator ( nav . NavigatorView ): ''' The default navigator. ''' def __init__ ( self , * args , ** kwargs ) -> None : super () . __init__ ( * args , ** kwargs ) for index , item in enumerate ( self . pages ): if isinstance ( item , hikari . Embed ): item . set_footer ( f \"Page { index + 1 } / { len ( self . pages ) } \" ) def get_default_buttons ( self ) -> t . List [ nav . NavButton [ nav . NavigatorView ]]: ''' Returns a list of default buttons. These are `FirstButton()`, `PrevButton()`, `NextButton()`, `LastButton()`, and `StopButtonDelete()`. Returns ------- t.List[nav.NavButton[nav.NavigatorView]] A list of default buttons. ''' return [ nav . FirstButton (), nav . PrevButton (), nav . NextButton (), nav . LastButton (), StopButtonDelete ()] async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout ()","title":"ButtonNavigator"},{"location":"dev/menu/#utils.nav.navigator.ButtonNavigator.get_default_buttons","text":"Returns a list of default buttons. These are FirstButton() , PrevButton() , NextButton() , LastButton() , and StopButtonDelete() . Returns: Type Description t . List [ nav . NavButton [ nav . NavigatorView ]] A list of default buttons. Source code in utils\\nav\\navigator.py 100 101 102 103 104 105 106 107 108 109 110 111 def get_default_buttons ( self ) -> t . List [ nav . NavButton [ nav . NavigatorView ]]: ''' Returns a list of default buttons. These are `FirstButton()`, `PrevButton()`, `NextButton()`, `LastButton()`, and `StopButtonDelete()`. Returns ------- t.List[nav.NavButton[nav.NavigatorView]] A list of default buttons. ''' return [ nav . FirstButton (), nav . PrevButton (), nav . NextButton (), nav . LastButton (), StopButtonDelete ()]","title":"get_default_buttons()"},{"location":"dev/menu/#utils.nav.navigator.ButtonNavigator.on_timeout","text":"Called when the view times out.","title":"on_timeout()"},{"location":"dev/menu/#utils.nav.navigator.ButtonNavigator.on_timeout--notes","text":"This adds the timeout button into the menu. Source code in utils\\nav\\navigator.py 113 114 115 116 117 118 119 120 121 122 async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout ()","title":"Notes"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder","text":"A builder to fit a list of item into a navigator appropriately. (This is experimental and can be removed at any time). Source code in utils\\nav\\navigator.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 class ItemListBuilder : '''A builder to fit a list of item into a navigator appropriately. (This is experimental and can be removed at any time).''' def __init__ ( self , items : list [ T ], max_item_per_page : int ): '''Construct the builder. Parameters ---------- items : list[T] A list of items. max_item_per_page : int The max amount of item to display before moving to a new page. ''' self . items = items self . max_item = max_item_per_page self . page_start_formatter : t . Callable [[ int , T ], hikari . Embed ] = None self . entry_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = None self . page_end_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = lambda embed , index , item : None def set_page_start_formatter ( self , callback : t . Callable [[ int , T ], hikari . Embed ], / ): '''Set this callback as the formatter to run whenever a new page is requested to be created. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[int, T], hikari.Embed] The callback to use. It must accept an `int` (index of the item), the item itself, and return a `hikari.Embed`. ''' self . page_start_formatter = callback def set_entry_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run while iterating through the item list. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . entry_formatter = callback def set_page_end_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run once adding items to a page is finished. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . page_end_formatter = callback def build ( self , * , page_type = ButtonNavigator ): '''Start the formatting process and return an object of `page_type`. Warnings -------- The builder must provide at least `page_start_formatter` and either `entry_formatter` or `page_end_formatter` before this method is called. Parameters ---------- page_type : t.Type, optional The type of navigator to use, by default ButtonNavigator. This must have a `pages` argument accepting a list of `hikari.Embed`. Returns ------- t.Any The type passed into the constructor, by default ButtonNavigator. Raises ------ NotImplementedError `page_start_formatter` is empty or both `entry_formatter` and `page_end_formatter` are empty. ''' if self . page_start_formatter is None or ( self . entry_formatter is None and self . page_end_formatter is None ): raise NotImplementedError ( \"Not enough formatters are defined.\" ) embeds : list [ hikari . Embed ] = [] embed : hikari . Embed = None for index , item in enumerate ( self . items ): if embed is None : embed = self . page_start_formatter ( index , item ) self . entry_formatter ( embed , index , item ) if index % self . max_item == self . max_item - 1 : self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) embed = None if embed is not None : # TODO: Fix undefined-loop-variable self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) return page_type ( pages = embeds )","title":"ItemListBuilder"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.__init__","text":"Construct the builder. Parameters: Name Type Description Default items list [ T ] A list of items. required max_item_per_page int The max amount of item to display before moving to a new page. required Source code in utils\\nav\\navigator.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def __init__ ( self , items : list [ T ], max_item_per_page : int ): '''Construct the builder. Parameters ---------- items : list[T] A list of items. max_item_per_page : int The max amount of item to display before moving to a new page. ''' self . items = items self . max_item = max_item_per_page self . page_start_formatter : t . Callable [[ int , T ], hikari . Embed ] = None self . entry_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = None self . page_end_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = lambda embed , index , item : None","title":"__init__()"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.set_page_start_formatter","text":"Set this callback as the formatter to run whenever a new page is requested to be created.","title":"set_page_start_formatter()"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.set_page_start_formatter--notes","text":"This is recommended to use as a decorator. Parameters: Name Type Description Default callback t . Callable [[ int , T ], hikari . Embed ] The callback to use. It must accept an int (index of the item), the item itself, and return a hikari.Embed . required Source code in utils\\nav\\navigator.py 144 145 146 147 148 149 150 151 152 153 154 155 156 def set_page_start_formatter ( self , callback : t . Callable [[ int , T ], hikari . Embed ], / ): '''Set this callback as the formatter to run whenever a new page is requested to be created. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[int, T], hikari.Embed] The callback to use. It must accept an `int` (index of the item), the item itself, and return a `hikari.Embed`. ''' self . page_start_formatter = callback","title":"Notes"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.set_entry_formatter","text":"Set this callback as the formatter to run while iterating through the item list.","title":"set_entry_formatter()"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.set_entry_formatter--notes","text":"This is recommended to use as a decorator. Parameters: Name Type Description Default callback t . Callable [[ hikari . Embed , int , T ], None] The callback to use. It must accept a hikari.Embed (the page it's editing), an int (index of the item), and the item itself. required Source code in utils\\nav\\navigator.py 157 158 159 160 161 162 163 164 165 166 167 168 169 def set_entry_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run while iterating through the item list. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . entry_formatter = callback","title":"Notes"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.set_page_end_formatter","text":"Set this callback as the formatter to run once adding items to a page is finished.","title":"set_page_end_formatter()"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.set_page_end_formatter--notes","text":"This is recommended to use as a decorator. Parameters: Name Type Description Default callback t . Callable [[ hikari . Embed , int , T ], None] The callback to use. It must accept a hikari.Embed (the page it's editing), an int (index of the item), and the item itself. required Source code in utils\\nav\\navigator.py 170 171 172 173 174 175 176 177 178 179 180 181 182 def set_page_end_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run once adding items to a page is finished. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . page_end_formatter = callback","title":"Notes"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.build","text":"Start the formatting process and return an object of page_type .","title":"build()"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.build--warnings","text":"The builder must provide at least page_start_formatter and either entry_formatter or page_end_formatter before this method is called. Parameters: Name Type Description Default page_type t . Type , optional The type of navigator to use, by default ButtonNavigator. This must have a pages argument accepting a list of hikari.Embed . ButtonNavigator Returns: Type Description t . Any The type passed into the constructor, by default ButtonNavigator. Raises: Type Description NotImplementedError page_start_formatter is empty or both entry_formatter and page_end_formatter are empty. Source code in utils\\nav\\navigator.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def build ( self , * , page_type = ButtonNavigator ): '''Start the formatting process and return an object of `page_type`. Warnings -------- The builder must provide at least `page_start_formatter` and either `entry_formatter` or `page_end_formatter` before this method is called. Parameters ---------- page_type : t.Type, optional The type of navigator to use, by default ButtonNavigator. This must have a `pages` argument accepting a list of `hikari.Embed`. Returns ------- t.Any The type passed into the constructor, by default ButtonNavigator. Raises ------ NotImplementedError `page_start_formatter` is empty or both `entry_formatter` and `page_end_formatter` are empty. ''' if self . page_start_formatter is None or ( self . entry_formatter is None and self . page_end_formatter is None ): raise NotImplementedError ( \"Not enough formatters are defined.\" ) embeds : list [ hikari . Embed ] = [] embed : hikari . Embed = None for index , item in enumerate ( self . items ): if embed is None : embed = self . page_start_formatter ( index , item ) self . entry_formatter ( embed , index , item ) if index % self . max_item == self . max_item - 1 : self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) embed = None if embed is not None : # TODO: Fix undefined-loop-variable self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) return page_type ( pages = embeds )","title":"Warnings"},{"location":"dev/menu/#utils.nav.navigator.run_view","text":"A simplified way to run a miru.View . Parameters: Name Type Description Default view miru . View A miru.View or its subclasses. required ctx lightbulb . Context A context to send the view. required initial_content t . Union [ str , hikari . Embed ], optional The content to first display. This is optional for nav.NavigatorView and its subclasses. None Raises: Type Description TypeError initial_content is not provided, but view is not type nav.NavigatorView . hikari . BadRequestError Maybe ctx is deferred. Source code in utils\\nav\\navigator.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 async def run_view ( view : miru . View , ctx : lightbulb . Context , initial_content : t . Union [ str , hikari . Embed ] = None ) -> None : '''A simplified way to run a `miru.View`. Parameters ---------- view : miru.View A `miru.View` or its subclasses. ctx : lightbulb.Context A context to send the view. initial_content : t.Union[str, hikari.Embed], optional The content to first display. This is optional for `nav.NavigatorView` and its subclasses. Raises ------ TypeError `initial_content` is not provided, but `view` is not type `nav.NavigatorView`. hikari.BadRequestError Maybe `ctx` is deferred. ''' if initial_content is None : if isinstance ( view , nav . NavigatorView ): # nav.NavigatorView cannot be run on an interaction with a response already (typically deferring) # so we have to do things manually here. # Reference: https://github.com/HyperGH/hikari-miru/blob/main/miru/ext/nav/navigator.py#L227 for button in view . children : if isinstance ( button , nav . NavButton ): await button . before_page_change () initial_content = view . pages [ view . current_page ] #await view.send(ctx.interaction) #return else : raise TypeError ( \"'initial_content' must be provided if 'view' is not type 'NavigatorView'.\" ) resp_proxy = await ctx . respond ( initial_content , components = view . build ()) view . start ( await resp_proxy . message ()) await view . wait ()","title":"run_view()"},{"location":"dev/menu/#utils.nav.navigator.timeout_button","text":"Return a nav.NavButton to be use in nav.NavigatorView . This button is safe to use in miru.View . Returns: Type Description nav . NavButton The default timeout button. Source code in utils\\nav\\navigator.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def timeout_button () -> nav . NavButton : '''Return a `nav.NavButton` to be use in `nav.NavigatorView`. This button is safe to use in `miru.View`. Returns ------- nav.NavButton The default timeout button. ''' return nav . NavButton ( style = hikari . ButtonStyle . SECONDARY , emoji = helpers . get_emote ( \":clock12:\" ), custom_id = \"timeout_button\" , disabled = True )","title":"timeout_button()"},{"location":"dev/menu/#navconfirmpy","text":"Contains a confirmation menu.","title":"nav/confirm.py"},{"location":"dev/menu/#utils.nav.confirm.ConfirmView","text":"Bases: miru . View A confirmation menu. Source code in utils\\nav\\confirm.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class ConfirmView ( miru . View ): ''' A confirmation menu. ''' def __init__ ( self , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None : super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . result : t . Optional [ bool ] = None @miru . button ( label = \"Yes\" , emoji = helpers . get_emote ( \":white_check_mark:\" ), style = hikari . ButtonStyle . SUCCESS , custom_id = \"yes_button\" ) async def yes_button ( self , _ : miru . Button , __ : miru . Context ): self . result = True self . stop () @miru . button ( label = \"No\" , emoji = helpers . get_emote ( \":negative_squared_cross_mark:\" ), style = hikari . ButtonStyle . DANGER , custom_id = \"no_button\" ) async def no_button ( self , _ : miru . Button , __ : miru . Context ): self . result = False self . stop () async def wait ( self ) -> t . Optional [ bool ]: ''' Wait until the view times out or stops manually. Return the result of the confirmation, or `None` if it times out. ''' await super () . wait () await self . message . delete () return self . result","title":"ConfirmView"},{"location":"dev/menu/#utils.nav.confirm.ConfirmView.wait","text":"Wait until the view times out or stops manually. Return the result of the confirmation, or None if it times out. Source code in utils\\nav\\confirm.py 28 29 30 31 32 33 34 35 36 37 async def wait ( self ) -> t . Optional [ bool ]: ''' Wait until the view times out or stops manually. Return the result of the confirmation, or `None` if it times out. ''' await super () . wait () await self . message . delete () return self . result","title":"wait()"},{"location":"dev/menu/#navmenupy","text":"Contains everything needed to build a complex menu.","title":"nav/menu.py"},{"location":"dev/menu/#utils.nav.menu.MenuComponent","text":"A tree-like node that represents the menu's option structure. The node has two \"states\": a regular node state and a fake node. A regular node state is when the options is a dictionary, which will determine the child nodes. A fake node state is when the options is a list of contents to display. In this case, the node's content is set to None , and no further child nodes can be created from this node. The child nodes can be accessed using dictionary notation IF there are child nodes. Source code in utils\\nav\\menu.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class MenuComponent : ''' A tree-like node that represents the menu's option structure. The node has two \"states\": a regular node state and a fake node. A regular node state is when the `options` is a dictionary, which will determine the child nodes. A fake node state is when the `options` is a list of contents to display. In this case, the node's content is set to `None`, and no further child nodes can be created from this node. The child nodes can be accessed using dictionary notation IF there are child nodes. ''' def __init__ ( self , content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ): ''' Create a node that stores the content and optionally, its options. The `options` can be a list, which will set the content to `None` regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a `dict` through `options`, but instead, use `.add_options()`. ''' self . content = content self . options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = options self . __parent__ : t . Optional [ MenuComponent ] = None if isinstance ( self . options , list ): self . content = None def add_option ( self , key : MenuButton , content : PageLike ) -> MenuComponent : '''Add an option into the current node. Return the newly added node to further add more layers. Warnings -------- The returned object is the newly added object, not the current object. Parameters ---------- key : MenuButton The button for the new option. content : PageLike The content of the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. ''' if isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) if self . options is None : self . options = { key : MenuComponent ( content )} self . options [ key ] . __parent__ = self return self . options [ key ] elif self . options . get ( key ) is None : component = MenuComponent ( content ) component . __parent__ = self self . options [ key ] = component return self . options [ key ] else : raise LookupError ( \"Duplicated keys.\" ) def add_options ( self , options : t . Dict [ MenuButton , PageLike ]): '''Add multiple options into the current node. Warnings -------- This will overwrite any possible duplicate keys. Parameters ---------- options : t.Dict[MenuButton, PageLike] A mapping of {button: content}. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) for key in options : self . options [ key ] = MenuComponent ( options [ key ]) self . options [ key ] . __parent__ = self def add_list_options ( self , key : str , contents : t . List [ PageLike ]) -> MenuComponent : '''Append a fake node to this node. Return the newly added node to do whatever you want. Parameters ---------- key : str The button for the new option. contents : t.List[PageLike] A list of content for the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) component = None if len ( contents ) == 1 : component = MenuComponent ( content = contents [ 0 ]) else : component = MenuComponent ( content = None , options = contents ) component . __parent__ = self self . options [ key ] = component return component def force_add_list_options ( self , contents : t . List [ PageLike ]): '''Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters ---------- contents : t.List[PageLike] A list of content for the option. ''' if self . options is None : self . options = [] for content in contents : self . options . append ( content ) self . content = None def __getitem__ ( self , key : MenuButton ) -> t . Optional [ MenuComponent ]: '''Return the MenuComponent with the matching key, or `None` if none was found. Parameters ---------- key : MenuButton The option you're retrieving. Returns ------- t.Optional[MenuComponent] The option with matching key, or `None` if none was found. Raises ------ IndexError The current MenuComponent is already a fake node. ''' if isinstance ( self . options , dict ): return self . options . get ( key ) raise IndexError ( \"Index doesn't exist.\" )","title":"MenuComponent"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.__init__","text":"Create a node that stores the content and optionally, its options. The options can be a list, which will set the content to None regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a dict through options , but instead, use .add_options() . Source code in utils\\nav\\menu.py 26 27 28 29 30 31 32 33 34 35 36 37 38 def __init__ ( self , content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ): ''' Create a node that stores the content and optionally, its options. The `options` can be a list, which will set the content to `None` regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a `dict` through `options`, but instead, use `.add_options()`. ''' self . content = content self . options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = options self . __parent__ : t . Optional [ MenuComponent ] = None if isinstance ( self . options , list ): self . content = None","title":"__init__()"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.add_option","text":"Add an option into the current node. Return the newly added node to further add more layers.","title":"add_option()"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.add_option--warnings","text":"The returned object is the newly added object, not the current object. Parameters: Name Type Description Default key MenuButton The button for the new option. required content PageLike The content of the new option. required Returns: Type Description MenuComponent The newly added option. Raises: Type Description KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. Source code in utils\\nav\\menu.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def add_option ( self , key : MenuButton , content : PageLike ) -> MenuComponent : '''Add an option into the current node. Return the newly added node to further add more layers. Warnings -------- The returned object is the newly added object, not the current object. Parameters ---------- key : MenuButton The button for the new option. content : PageLike The content of the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. ''' if isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) if self . options is None : self . options = { key : MenuComponent ( content )} self . options [ key ] . __parent__ = self return self . options [ key ] elif self . options . get ( key ) is None : component = MenuComponent ( content ) component . __parent__ = self self . options [ key ] = component return self . options [ key ] else : raise LookupError ( \"Duplicated keys.\" )","title":"Warnings"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.add_options","text":"Add multiple options into the current node.","title":"add_options()"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.add_options--warnings","text":"This will overwrite any possible duplicate keys. Parameters: Name Type Description Default options t . Dict [ MenuButton , PageLike ] A mapping of {button: content}. required Raises: Type Description KeyError The current MenuComponent is already a fake node. Source code in utils\\nav\\menu.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def add_options ( self , options : t . Dict [ MenuButton , PageLike ]): '''Add multiple options into the current node. Warnings -------- This will overwrite any possible duplicate keys. Parameters ---------- options : t.Dict[MenuButton, PageLike] A mapping of {button: content}. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) for key in options : self . options [ key ] = MenuComponent ( options [ key ]) self . options [ key ] . __parent__ = self","title":"Warnings"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.add_list_options","text":"Append a fake node to this node. Return the newly added node to do whatever you want. Parameters: Name Type Description Default key str The button for the new option. required contents t . List [ PageLike ] A list of content for the new option. required Returns: Type Description MenuComponent The newly added option. Raises: Type Description KeyError The current MenuComponent is already a fake node. Source code in utils\\nav\\menu.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def add_list_options ( self , key : str , contents : t . List [ PageLike ]) -> MenuComponent : '''Append a fake node to this node. Return the newly added node to do whatever you want. Parameters ---------- key : str The button for the new option. contents : t.List[PageLike] A list of content for the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) component = None if len ( contents ) == 1 : component = MenuComponent ( content = contents [ 0 ]) else : component = MenuComponent ( content = None , options = contents ) component . __parent__ = self self . options [ key ] = component return component","title":"add_list_options()"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.force_add_list_options","text":"Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters: Name Type Description Default contents t . List [ PageLike ] A list of content for the option. required Source code in utils\\nav\\menu.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def force_add_list_options ( self , contents : t . List [ PageLike ]): '''Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters ---------- contents : t.List[PageLike] A list of content for the option. ''' if self . options is None : self . options = [] for content in contents : self . options . append ( content ) self . content = None","title":"force_add_list_options()"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.__getitem__","text":"Return the MenuComponent with the matching key, or None if none was found. Parameters: Name Type Description Default key MenuButton The option you're retrieving. required Returns: Type Description t . Optional [ MenuComponent ] The option with matching key, or None if none was found. Raises: Type Description IndexError The current MenuComponent is already a fake node. Source code in utils\\nav\\menu.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def __getitem__ ( self , key : MenuButton ) -> t . Optional [ MenuComponent ]: '''Return the MenuComponent with the matching key, or `None` if none was found. Parameters ---------- key : MenuButton The option you're retrieving. Returns ------- t.Optional[MenuComponent] The option with matching key, or `None` if none was found. Raises ------ IndexError The current MenuComponent is already a fake node. ''' if isinstance ( self . options , dict ): return self . options . get ( key ) raise IndexError ( \"Index doesn't exist.\" )","title":"__getitem__()"},{"location":"dev/menu/#utils.nav.menu.MenuButton","text":"Bases: miru . Button Represents a generic button inside ComplexView . This should only be used in ComplexView . Source code in utils\\nav\\menu.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 class MenuButton ( miru . Button ): '''Represents a generic button inside `ComplexView`. This should only be used in `ComplexView`.''' async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the option if the current `MenuComponent` is not a fake node. ''' view : ComplexView = self . view if isinstance ( view . menu . options , dict ): view . menu = view . menu . options [ self ] await view . update ()","title":"MenuButton"},{"location":"dev/menu/#utils.nav.menu.MenuButton.callback","text":"Calls when the button is pressed. It'll move to the option if the current MenuComponent is not a fake node. Source code in utils\\nav\\menu.py 186 187 188 189 190 191 192 193 194 195 196 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the option if the current `MenuComponent` is not a fake node. ''' view : ComplexView = self . view if isinstance ( view . menu . options , dict ): view . menu = view . menu . options [ self ] await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.ReturnMenuButton","text":"Bases: MenuButton Represents a return button. Source code in utils\\nav\\menu.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 class ReturnMenuButton ( MenuButton ): '''Represents a return button.''' def __init__ ( self ) -> None : super () . __init__ ( style = hikari . ButtonStyle . SECONDARY , emoji = helpers . get_emote ( \":arrow_up_small:\" ), custom_id = \"return_button\" ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the parent node if it is not `None`. Raises ------ RuntimeError The return button is in the root menu. ''' view : ComplexView = self . view if view . menu . __parent__ is not None : view . menu = view . menu . __parent__ view . current_page = 0 else : raise RuntimeError ( \"A return button is available in the root menu.\" ) await view . update ()","title":"ReturnMenuButton"},{"location":"dev/menu/#utils.nav.menu.ReturnMenuButton.callback","text":"Calls when the button is pressed. It'll move to the parent node if it is not None . Raises: Type Description RuntimeError The return button is in the root menu. Source code in utils\\nav\\menu.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the parent node if it is not `None`. Raises ------ RuntimeError The return button is in the root menu. ''' view : ComplexView = self . view if view . menu . __parent__ is not None : view . menu = view . menu . __parent__ view . current_page = 0 else : raise RuntimeError ( \"A return button is available in the root menu.\" ) await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.StopMenuButton","text":"Bases: MenuButton Represents a terminate button. Source code in utils\\nav\\menu.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 class StopMenuButton ( MenuButton ): '''Represents a terminate button.''' def __init__ ( self ) -> None : super () . __init__ ( style = hikari . ButtonStyle . DANGER , emoji = helpers . get_emote ( \":stop_button:\" ), custom_id = \"stop_button\" ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll stop the `ComplexView` and delete the menu. ''' view : ComplexView = self . view view . stop () if view . message : await view . message . delete ()","title":"StopMenuButton"},{"location":"dev/menu/#utils.nav.menu.StopMenuButton.callback","text":"Calls when the button is pressed. It'll stop the ComplexView and delete the menu. Source code in utils\\nav\\menu.py 236 237 238 239 240 241 242 243 244 245 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll stop the `ComplexView` and delete the menu. ''' view : ComplexView = self . view view . stop () if view . message : await view . message . delete ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.NextMenuButton","text":"Bases: MenuButton A button to move to the next page list. This behaves similarly to nav.NextButton() . Source code in utils\\nav\\menu.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 class NextMenuButton ( MenuButton ): '''A button to move to the next page list. This behaves similarly to `nav.NextButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"next_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":arrow_forward:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. ''' view : ComplexView = self . view view . current_page += 1 if view . current_page > len ( view . menu . options ) - 1 : view . current_page = 0 await view . update ()","title":"NextMenuButton"},{"location":"dev/menu/#utils.nav.menu.NextMenuButton.callback","text":"Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. Source code in utils\\nav\\menu.py 262 263 264 265 266 267 268 269 270 271 272 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. ''' view : ComplexView = self . view view . current_page += 1 if view . current_page > len ( view . menu . options ) - 1 : view . current_page = 0 await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.PrevMenuButton","text":"Bases: MenuButton A button to move to the previous page list. This behaves similarly to nav.PrevButton() . Source code in utils\\nav\\menu.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 class PrevMenuButton ( MenuButton ): '''A button to move to the previous page list. This behaves similarly to `nav.PrevButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"prev_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":arrow_backward:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. ''' view : ComplexView = self . view view . current_page -= 1 if view . current_page < 0 : view . current_page = len ( view . menu . options ) - 1 await view . update ()","title":"PrevMenuButton"},{"location":"dev/menu/#utils.nav.menu.PrevMenuButton.callback","text":"Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. Source code in utils\\nav\\menu.py 289 290 291 292 293 294 295 296 297 298 299 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. ''' view : ComplexView = self . view view . current_page -= 1 if view . current_page < 0 : view . current_page = len ( view . menu . options ) - 1 await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.FirstMenuButton","text":"Bases: MenuButton A button to move to the first page list. This behaves similarly to nav.FirstButton() . Source code in utils\\nav\\menu.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 class FirstMenuButton ( MenuButton ): '''A button to move to the first page list. This behaves similarly to `nav.FirstButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"first_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":last_track_button:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the first page. ''' view : ComplexView = self . view view . current_page = 0 await view . update ()","title":"FirstMenuButton"},{"location":"dev/menu/#utils.nav.menu.FirstMenuButton.callback","text":"Calls when the button is pressed. Move to the first page. Source code in utils\\nav\\menu.py 316 317 318 319 320 321 322 323 324 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the first page. ''' view : ComplexView = self . view view . current_page = 0 await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.LastMenuButton","text":"Bases: MenuButton A button to move to the last page list. This behaves similarly to nav.LastButton() . Source code in utils\\nav\\menu.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 class LastMenuButton ( MenuButton ): '''A button to move to the last page list. This behaves similarly to `nav.LastButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"last_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":next_track_button:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the last page. ''' view : ComplexView = self . view view . current_page = len ( view . menu . options ) - 1 await view . update ()","title":"LastMenuButton"},{"location":"dev/menu/#utils.nav.menu.LastMenuButton.callback","text":"Calls when the button is pressed. Move to the last page. Source code in utils\\nav\\menu.py 341 342 343 344 345 346 347 348 349 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the last page. ''' view : ComplexView = self . view view . current_page = len ( view . menu . options ) - 1 await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.ComplexView","text":"Bases: miru . View A complex menu. Source code in utils\\nav\\menu.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 class ComplexView ( miru . View ): '''A complex menu.''' def __init__ ( self , menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None : '''Construct a complex menu. Parameters ---------- menu : MenuComponent A `MenuComponent` tree. This must be a root node. timeout : t.Optional[float], optional How long (in seconds) the menu should accept interactions. Default to `120`. autodefer : bool, optional Whether or not the menu should defer when possible. Default to `True`. ''' super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . menu = menu # For list menu self . current_page : int = 0 def _update_button ( self ) -> None : ''' Update the button based on the current menu state. ''' self . clear_items () if isinstance ( self . menu . options , dict ): for button in self . menu . options : self . add_item ( button ) elif isinstance ( self . menu . options , list ): # TODO: Might optimize this so it wouldn't reset the buttons. self . add_item ( FirstMenuButton ()) self . add_item ( PrevMenuButton ()) self . add_item ( NextMenuButton ()) self . add_item ( LastMenuButton ()) for index , item in enumerate ( self . menu . options ): if isinstance ( item , hikari . Embed ): item . set_footer ( f \"Page { index + 1 } / { len ( self . menu . options ) } \" ) if self . menu . __parent__ is None : self . add_item ( StopMenuButton ()) else : self . add_item ( ReturnMenuButton ()) async def update ( self ) -> None : '''Update the menu. This shouldn't be called by the user. Raises ------ RuntimeError The message is not found (for unknown reasons). Notes ----- All `MenuButton` should call this method inside their callbacks once it's done with everything. ''' self . _update_button () content = self . menu . content # If view is in a list menu. Can also check if menu.content is None instead. if isinstance ( self . menu . options , list ): content = self . menu . options [ self . current_page ] if self . message : await self . message . edit ( content , components = self . build ()) else : raise RuntimeError ( \"Oops ComplexView.update() failed.\" ) async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout () async def run ( self , ctx : lightbulb . Context ) -> None : '''Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters ---------- ctx : lightbulb.Context A `lightbulb` context. ''' self . _update_button () await run_view ( self , ctx , self . menu . content )","title":"ComplexView"},{"location":"dev/menu/#utils.nav.menu.ComplexView.__init__","text":"Construct a complex menu. Parameters: Name Type Description Default menu MenuComponent A MenuComponent tree. This must be a root node. required timeout t . Optional [ float ], optional How long (in seconds) the menu should accept interactions. Default to 120 . 120 autodefer bool , optional Whether or not the menu should defer when possible. Default to True . True Source code in utils\\nav\\menu.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 def __init__ ( self , menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None : '''Construct a complex menu. Parameters ---------- menu : MenuComponent A `MenuComponent` tree. This must be a root node. timeout : t.Optional[float], optional How long (in seconds) the menu should accept interactions. Default to `120`. autodefer : bool, optional Whether or not the menu should defer when possible. Default to `True`. ''' super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . menu = menu # For list menu self . current_page : int = 0","title":"__init__()"},{"location":"dev/menu/#utils.nav.menu.ComplexView.update","text":"Update the menu. This shouldn't be called by the user. Raises: Type Description RuntimeError The message is not found (for unknown reasons).","title":"update()"},{"location":"dev/menu/#utils.nav.menu.ComplexView.update--notes","text":"All MenuButton should call this method inside their callbacks once it's done with everything. Source code in utils\\nav\\menu.py 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 async def update ( self ) -> None : '''Update the menu. This shouldn't be called by the user. Raises ------ RuntimeError The message is not found (for unknown reasons). Notes ----- All `MenuButton` should call this method inside their callbacks once it's done with everything. ''' self . _update_button () content = self . menu . content # If view is in a list menu. Can also check if menu.content is None instead. if isinstance ( self . menu . options , list ): content = self . menu . options [ self . current_page ] if self . message : await self . message . edit ( content , components = self . build ()) else : raise RuntimeError ( \"Oops ComplexView.update() failed.\" )","title":"Notes"},{"location":"dev/menu/#utils.nav.menu.ComplexView.on_timeout","text":"Called when the view times out.","title":"on_timeout()"},{"location":"dev/menu/#utils.nav.menu.ComplexView.on_timeout--notes","text":"This adds the timeout button into the menu. Source code in utils\\nav\\menu.py 421 422 423 424 425 426 427 428 429 430 async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout ()","title":"Notes"},{"location":"dev/menu/#utils.nav.menu.ComplexView.run","text":"Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters: Name Type Description Default ctx lightbulb . Context A lightbulb context. required Source code in utils\\nav\\menu.py 432 433 434 435 436 437 438 439 440 441 442 443 444 async def run ( self , ctx : lightbulb . Context ) -> None : '''Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters ---------- ctx : lightbulb.Context A `lightbulb` context. ''' self . _update_button () await run_view ( self , ctx , self . menu . content )","title":"run()"},{"location":"dev/models/","text":"Contains many data structures, including the customized MichaelBot class. UserCache Represent a user data in the database. This contains one module: user_module : Represent the Users table. Source code in utils\\models.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class UserCache : ''' Represent a user data in the database. This contains one module: - `user_module`: Represent the `Users` table. ''' def __init__ ( self , user_module : dict = None ): if user_module is None : user_module = {} else : user_module . pop ( \"id\" , None ) self . user_module = user_module async def add_user_module ( self , conn , user : hikari . User ): ''' Add a user into the cache and the database. ''' await psql . User . insert_one ( conn , psql . User ( user . id , user . username )) user_info = await psql . User . get_one ( conn , user . id , as_dict = True ) self . user_module = user_info async def update_user_module ( self , conn , user_id : int , column : str , new_value ): ''' Edit a user data in the cache and the database. ''' await psql . User . update_column ( conn , user_id , column , new_value ) self . user_module [ column ] = new_value async def force_sync ( self , conn , user_id : int ): ''' Force this object to update with database. If the method returns `None`, the entry for this user isn't on the database, thus you should use `add_user_module()` instead. Otherwise, it returns itself. ''' user = await psql . User . get_one ( conn , user_id , as_dict = True ) if user is None : return None else : user . pop ( \"id\" , None ) self . user_module = user return self add_user_module ( conn , user : hikari . User ) async Add a user into the cache and the database. Source code in utils\\models.py 32 33 34 35 36 37 38 async def add_user_module ( self , conn , user : hikari . User ): ''' Add a user into the cache and the database. ''' await psql . User . insert_one ( conn , psql . User ( user . id , user . username )) user_info = await psql . User . get_one ( conn , user . id , as_dict = True ) self . user_module = user_info update_user_module ( conn , user_id : int , column : str , new_value ) async Edit a user data in the cache and the database. Source code in utils\\models.py 39 40 41 42 43 44 async def update_user_module ( self , conn , user_id : int , column : str , new_value ): ''' Edit a user data in the cache and the database. ''' await psql . User . update_column ( conn , user_id , column , new_value ) self . user_module [ column ] = new_value force_sync ( conn , user_id : int ) async Force this object to update with database. If the method returns None , the entry for this user isn't on the database, thus you should use add_user_module() instead. Otherwise, it returns itself. Source code in utils\\models.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 async def force_sync ( self , conn , user_id : int ): ''' Force this object to update with database. If the method returns `None`, the entry for this user isn't on the database, thus you should use `add_user_module()` instead. Otherwise, it returns itself. ''' user = await psql . User . get_one ( conn , user_id , as_dict = True ) if user is None : return None else : user . pop ( \"id\" , None ) self . user_module = user return self GuildCache Represent a guild data in the database. This contains two module: guild_module : Represent the Guilds table. logging_module : Represent the GuildsLogs table. Source code in utils\\models.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class GuildCache : ''' Represent a guild data in the database. This contains two module: - `guild_module`: Represent the `Guilds` table. - `logging_module`: Represent the `GuildsLogs` table. ''' def __init__ ( self , guild_module : dict = None , logging_module : dict = None ): if guild_module is None : guild_module = {} else : guild_module . pop ( \"id\" , None ) if logging_module is None : logging_module = {} else : logging_module . pop ( \"guild_id\" , None ) self . guild_module = guild_module self . logging_module = logging_module async def add_guild_module ( self , conn , guild : hikari . Guild ): ''' Add a guild module into the cache and the database. ''' #await psql.Guilds._insert_one(conn, guild) await psql . Guild . insert_one ( conn , psql . Guild ( guild . id , guild . name )) guild_info = await psql . Guild . get_one ( conn , guild . id , as_dict = True ) self . guild_module = guild_info async def update_guild_module ( self , conn , guild_id : int , column : str , new_value ): ''' Edit a guild module data in the cache and the database. ''' await psql . Guild . update_column ( conn , guild_id , column , new_value ) self . guild_module [ column ] = new_value async def add_logging_module ( self , conn , guild : hikari . Guild ): ''' Add a logging module into the cache and the database. ''' await psql . GuildsLogs . insert_one ( conn , guild . id ) logging_info = await psql . GuildsLogs . get_one ( conn , guild . id , as_dict = True ) self . logging_module = logging_info async def update_logging_module ( self , conn , guild_id : int , column : str , new_value ): ''' Update a logging module in the cache and the database. ''' await psql . GuildsLogs . update_column ( conn , guild_id , column , new_value ) self . logging_module [ column ] = new_value async def force_sync ( self , conn , guild_id : int ): ''' Force this object to update with database. If the method returns `None`, the entry for this guild isn't on the database, thus you should use `add_guild_module()` instead. Otherwise, it returns itself. ''' guild = await psql . Guild . get_one ( conn , guild_id , as_dict = True ) if guild is None : return None else : guild . pop ( \"id\" , None ) guild_log = await psql . GuildsLogs . get_one ( conn , guild_id , as_dict = True ) if guild_log is None : guild_log = {} else : guild_log . pop ( \"guild_id\" , None ) self . guild_module = guild self . logging_module = guild_log return self add_guild_module ( conn , guild : hikari . Guild ) async Add a guild module into the cache and the database. Source code in utils\\models.py 85 86 87 88 89 90 91 92 async def add_guild_module ( self , conn , guild : hikari . Guild ): ''' Add a guild module into the cache and the database. ''' #await psql.Guilds._insert_one(conn, guild) await psql . Guild . insert_one ( conn , psql . Guild ( guild . id , guild . name )) guild_info = await psql . Guild . get_one ( conn , guild . id , as_dict = True ) self . guild_module = guild_info update_guild_module ( conn , guild_id : int , column : str , new_value ) async Edit a guild module data in the cache and the database. Source code in utils\\models.py 94 95 96 97 98 99 async def update_guild_module ( self , conn , guild_id : int , column : str , new_value ): ''' Edit a guild module data in the cache and the database. ''' await psql . Guild . update_column ( conn , guild_id , column , new_value ) self . guild_module [ column ] = new_value add_logging_module ( conn , guild : hikari . Guild ) async Add a logging module into the cache and the database. Source code in utils\\models.py 101 102 103 104 105 106 107 async def add_logging_module ( self , conn , guild : hikari . Guild ): ''' Add a logging module into the cache and the database. ''' await psql . GuildsLogs . insert_one ( conn , guild . id ) logging_info = await psql . GuildsLogs . get_one ( conn , guild . id , as_dict = True ) self . logging_module = logging_info update_logging_module ( conn , guild_id : int , column : str , new_value ) async Update a logging module in the cache and the database. Source code in utils\\models.py 109 110 111 112 113 114 async def update_logging_module ( self , conn , guild_id : int , column : str , new_value ): ''' Update a logging module in the cache and the database. ''' await psql . GuildsLogs . update_column ( conn , guild_id , column , new_value ) self . logging_module [ column ] = new_value force_sync ( conn , guild_id : int ) async Force this object to update with database. If the method returns None , the entry for this guild isn't on the database, thus you should use add_guild_module() instead. Otherwise, it returns itself. Source code in utils\\models.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 async def force_sync ( self , conn , guild_id : int ): ''' Force this object to update with database. If the method returns `None`, the entry for this guild isn't on the database, thus you should use `add_guild_module()` instead. Otherwise, it returns itself. ''' guild = await psql . Guild . get_one ( conn , guild_id , as_dict = True ) if guild is None : return None else : guild . pop ( \"id\" , None ) guild_log = await psql . GuildsLogs . get_one ( conn , guild_id , as_dict = True ) if guild_log is None : guild_log = {} else : guild_log . pop ( \"guild_id\" , None ) self . guild_module = guild self . logging_module = guild_log return self DefaultColor Bases: Enum Store several default colors to use instantly. Source code in utils\\models.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 class DefaultColor ( Enum ): ''' Store several default colors to use instantly. ''' teal = hikari . Color ( 0x1abc9c ) dark_teal = hikari . Color ( 0x11806a ) brand_green = hikari . Color ( 0x57F287 ) green = hikari . Color ( 0x2ecc71 ) dark_green = hikari . Color ( 0x1f8b4c ) blue = hikari . Color ( 0x3498db ) dark_blue = hikari . Color ( 0x206694 ) purple = hikari . Color ( 0x9b59b6 ) dark_purple = hikari . Color ( 0x71368a ) magenta = hikari . Color ( 0xe91e63 ) dark_magenta = hikari . Color ( 0xad1457 ) gold = hikari . Color ( 0xf1c40f ) dark_gold = hikari . Color ( 0xc27c0e ) orange = hikari . Color ( 0xe67e22 ) dark_orange = hikari . Color ( 0xa84300 ) brand_red = hikari . Color ( 0xED4245 ) red = hikari . Color ( 0xe74c3c ) dark_red = hikari . Color ( 0x992d22 ) lighter_gray = hikari . Color ( 0x95a5a6 ) dark_gray = hikari . Color ( 0x607d8b ) light_gray = hikari . Color ( 0x979c9f ) darker_gray = hikari . Color ( 0x546e7a ) og_blurple = hikari . Color ( 0x7289da ) blurple = hikari . Color ( 0x5865F2 ) greyple = hikari . Color ( 0x5865F2 ) dark_theme = hikari . Color ( 0x36393F ) fuchsia = hikari . Color ( 0xEB459E ) yellow = hikari . Color ( 0xFEE75C ) black = hikari . Color ( 0x000000 ) white = hikari . Color ( 0xFFFFFF ) NodeExtra dataclass A class to store extra data for the lavaplayer.Node Source code in utils\\models.py 176 177 178 179 180 @dataclass class NodeExtra : '''A class to store extra data for the `lavaplayer.Node`''' queue_loop : bool = False working_channel : int = 0 MichaelBot Bases: lightbulb . BotApp A subclass of lightbulb.BotApp . This allows syntax highlight on many custom attributes. Source code in utils\\models.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 class MichaelBot ( lightbulb . BotApp ): '''A subclass of `lightbulb.BotApp`. This allows syntax highlight on many custom attributes.''' __slots__ = ( \"info\" , \"secrets\" , \"online_at\" , \"logging\" , \"pool\" , \"aio_session\" , \"guild_cache\" , \"user_cache\" , \"lavalink\" , \"node_extra\" ) def __init__ ( self , token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None : ''' Parameters ----------------- info : dict The bot info. Store the one in `config.json`. secrets : dict The bot's secrets such as token, database info, etc. ''' self . info : dict = kwargs . pop ( \"info\" ) self . secrets : dict = kwargs . pop ( \"secrets\" ) self . online_at : dt . datetime = None self . pool : t . Optional [ asyncpg . Pool ] = None self . aio_session : t . Optional [ aiohttp . ClientSession ] = None # Store some db info. This allows read-only operation much cheaper. self . guild_cache : dict [ int , GuildCache ] = {} self . user_cache : dict [ int , UserCache ] = {} self . lavalink : t . Optional [ lavaplayer . LavalinkClient ] = None # Currently lavaplayer doesn't support adding attr to lavaplayer.objects.Node # so we'll make a dictionary to manually track additional info. self . node_extra : dict [ int , NodeExtra ] = {} launch_options = self . info . get ( \"launch_options\" ) log_level = \"INFO\" if launch_options is None : launch_options = \"\" for option in launch_options . split (): if option in [ \"--debug\" , \"-d\" ]: default_enabled_guilds = self . info [ \"default_guilds\" ] log_level = \"DEBUG\" if option in [ \"--quiet\" , \"-q\" ]: log_level = \"\" super () . __init__ ( token , prefix , ignore_bots , owner_ids , default_enabled_guilds , help_class , help_slash_command , delete_unbound_commands , case_insensitive_prefix_commands , logs = log_level if bool ( log_level ) else None , ** kwargs ) def get_slash_command ( self , name : str ) -> t . Optional [ lightbulb . SlashCommand ]: '''Get the slash command with the given name, or `None` if none was found. Unlike the default behavior in `lightbulb.BotApp`, this also searches for subcommands. Parameters ---------- name : str The command name to search. Returns ------- t.Optional[lightbulb.SlashCommand] The slash command with that name, or `None` if none was found. ''' # Reference: https://hikari-lightbulb.readthedocs.io/en/latest/_modules/lightbulb/app.html#BotApp.get_prefix_command parts = name . split () if len ( parts ) == 1 : return self . _slash_commands . get ( name ) maybe_group = self . _slash_commands . get ( parts . pop ( 0 )) if not isinstance ( maybe_group , lightbulb . SlashCommandGroup ): return None this : t . Optional [ t . Union [ lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup , lightbulb . SlashSubCommand ] ] = maybe_group for part in parts : if this is None or isinstance ( this , lightbulb . SlashSubCommand ): return None this = this . get_subcommand ( part ) return this __init__ ( token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None Parameters: Name Type Description Default info dict The bot info. Store the one in config.json . required secrets dict The bot's secrets such as token, database info, etc. required Source code in utils\\models.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def __init__ ( self , token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None : ''' Parameters ----------------- info : dict The bot info. Store the one in `config.json`. secrets : dict The bot's secrets such as token, database info, etc. ''' self . info : dict = kwargs . pop ( \"info\" ) self . secrets : dict = kwargs . pop ( \"secrets\" ) self . online_at : dt . datetime = None self . pool : t . Optional [ asyncpg . Pool ] = None self . aio_session : t . Optional [ aiohttp . ClientSession ] = None # Store some db info. This allows read-only operation much cheaper. self . guild_cache : dict [ int , GuildCache ] = {} self . user_cache : dict [ int , UserCache ] = {} self . lavalink : t . Optional [ lavaplayer . LavalinkClient ] = None # Currently lavaplayer doesn't support adding attr to lavaplayer.objects.Node # so we'll make a dictionary to manually track additional info. self . node_extra : dict [ int , NodeExtra ] = {} launch_options = self . info . get ( \"launch_options\" ) log_level = \"INFO\" if launch_options is None : launch_options = \"\" for option in launch_options . split (): if option in [ \"--debug\" , \"-d\" ]: default_enabled_guilds = self . info [ \"default_guilds\" ] log_level = \"DEBUG\" if option in [ \"--quiet\" , \"-q\" ]: log_level = \"\" super () . __init__ ( token , prefix , ignore_bots , owner_ids , default_enabled_guilds , help_class , help_slash_command , delete_unbound_commands , case_insensitive_prefix_commands , logs = log_level if bool ( log_level ) else None , ** kwargs ) get_slash_command ( name : str ) -> t . Optional [ lightbulb . SlashCommand ] Get the slash command with the given name, or None if none was found. Unlike the default behavior in lightbulb.BotApp , this also searches for subcommands. Parameters: Name Type Description Default name str The command name to search. required Returns: Type Description t . Optional [ lightbulb . SlashCommand ] The slash command with that name, or None if none was found. Source code in utils\\models.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 def get_slash_command ( self , name : str ) -> t . Optional [ lightbulb . SlashCommand ]: '''Get the slash command with the given name, or `None` if none was found. Unlike the default behavior in `lightbulb.BotApp`, this also searches for subcommands. Parameters ---------- name : str The command name to search. Returns ------- t.Optional[lightbulb.SlashCommand] The slash command with that name, or `None` if none was found. ''' # Reference: https://hikari-lightbulb.readthedocs.io/en/latest/_modules/lightbulb/app.html#BotApp.get_prefix_command parts = name . split () if len ( parts ) == 1 : return self . _slash_commands . get ( name ) maybe_group = self . _slash_commands . get ( parts . pop ( 0 )) if not isinstance ( maybe_group , lightbulb . SlashCommandGroup ): return None this : t . Optional [ t . Union [ lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup , lightbulb . SlashSubCommand ] ] = maybe_group for part in parts : if this is None or isinstance ( this , lightbulb . SlashSubCommand ): return None this = this . get_subcommand ( part ) return this","title":"models.py"},{"location":"dev/models/#utils.models.UserCache","text":"Represent a user data in the database. This contains one module: user_module : Represent the Users table. Source code in utils\\models.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class UserCache : ''' Represent a user data in the database. This contains one module: - `user_module`: Represent the `Users` table. ''' def __init__ ( self , user_module : dict = None ): if user_module is None : user_module = {} else : user_module . pop ( \"id\" , None ) self . user_module = user_module async def add_user_module ( self , conn , user : hikari . User ): ''' Add a user into the cache and the database. ''' await psql . User . insert_one ( conn , psql . User ( user . id , user . username )) user_info = await psql . User . get_one ( conn , user . id , as_dict = True ) self . user_module = user_info async def update_user_module ( self , conn , user_id : int , column : str , new_value ): ''' Edit a user data in the cache and the database. ''' await psql . User . update_column ( conn , user_id , column , new_value ) self . user_module [ column ] = new_value async def force_sync ( self , conn , user_id : int ): ''' Force this object to update with database. If the method returns `None`, the entry for this user isn't on the database, thus you should use `add_user_module()` instead. Otherwise, it returns itself. ''' user = await psql . User . get_one ( conn , user_id , as_dict = True ) if user is None : return None else : user . pop ( \"id\" , None ) self . user_module = user return self","title":"UserCache"},{"location":"dev/models/#utils.models.UserCache.add_user_module","text":"Add a user into the cache and the database. Source code in utils\\models.py 32 33 34 35 36 37 38 async def add_user_module ( self , conn , user : hikari . User ): ''' Add a user into the cache and the database. ''' await psql . User . insert_one ( conn , psql . User ( user . id , user . username )) user_info = await psql . User . get_one ( conn , user . id , as_dict = True ) self . user_module = user_info","title":"add_user_module()"},{"location":"dev/models/#utils.models.UserCache.update_user_module","text":"Edit a user data in the cache and the database. Source code in utils\\models.py 39 40 41 42 43 44 async def update_user_module ( self , conn , user_id : int , column : str , new_value ): ''' Edit a user data in the cache and the database. ''' await psql . User . update_column ( conn , user_id , column , new_value ) self . user_module [ column ] = new_value","title":"update_user_module()"},{"location":"dev/models/#utils.models.UserCache.force_sync","text":"Force this object to update with database. If the method returns None , the entry for this user isn't on the database, thus you should use add_user_module() instead. Otherwise, it returns itself. Source code in utils\\models.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 async def force_sync ( self , conn , user_id : int ): ''' Force this object to update with database. If the method returns `None`, the entry for this user isn't on the database, thus you should use `add_user_module()` instead. Otherwise, it returns itself. ''' user = await psql . User . get_one ( conn , user_id , as_dict = True ) if user is None : return None else : user . pop ( \"id\" , None ) self . user_module = user return self","title":"force_sync()"},{"location":"dev/models/#utils.models.GuildCache","text":"Represent a guild data in the database. This contains two module: guild_module : Represent the Guilds table. logging_module : Represent the GuildsLogs table. Source code in utils\\models.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class GuildCache : ''' Represent a guild data in the database. This contains two module: - `guild_module`: Represent the `Guilds` table. - `logging_module`: Represent the `GuildsLogs` table. ''' def __init__ ( self , guild_module : dict = None , logging_module : dict = None ): if guild_module is None : guild_module = {} else : guild_module . pop ( \"id\" , None ) if logging_module is None : logging_module = {} else : logging_module . pop ( \"guild_id\" , None ) self . guild_module = guild_module self . logging_module = logging_module async def add_guild_module ( self , conn , guild : hikari . Guild ): ''' Add a guild module into the cache and the database. ''' #await psql.Guilds._insert_one(conn, guild) await psql . Guild . insert_one ( conn , psql . Guild ( guild . id , guild . name )) guild_info = await psql . Guild . get_one ( conn , guild . id , as_dict = True ) self . guild_module = guild_info async def update_guild_module ( self , conn , guild_id : int , column : str , new_value ): ''' Edit a guild module data in the cache and the database. ''' await psql . Guild . update_column ( conn , guild_id , column , new_value ) self . guild_module [ column ] = new_value async def add_logging_module ( self , conn , guild : hikari . Guild ): ''' Add a logging module into the cache and the database. ''' await psql . GuildsLogs . insert_one ( conn , guild . id ) logging_info = await psql . GuildsLogs . get_one ( conn , guild . id , as_dict = True ) self . logging_module = logging_info async def update_logging_module ( self , conn , guild_id : int , column : str , new_value ): ''' Update a logging module in the cache and the database. ''' await psql . GuildsLogs . update_column ( conn , guild_id , column , new_value ) self . logging_module [ column ] = new_value async def force_sync ( self , conn , guild_id : int ): ''' Force this object to update with database. If the method returns `None`, the entry for this guild isn't on the database, thus you should use `add_guild_module()` instead. Otherwise, it returns itself. ''' guild = await psql . Guild . get_one ( conn , guild_id , as_dict = True ) if guild is None : return None else : guild . pop ( \"id\" , None ) guild_log = await psql . GuildsLogs . get_one ( conn , guild_id , as_dict = True ) if guild_log is None : guild_log = {} else : guild_log . pop ( \"guild_id\" , None ) self . guild_module = guild self . logging_module = guild_log return self","title":"GuildCache"},{"location":"dev/models/#utils.models.GuildCache.add_guild_module","text":"Add a guild module into the cache and the database. Source code in utils\\models.py 85 86 87 88 89 90 91 92 async def add_guild_module ( self , conn , guild : hikari . Guild ): ''' Add a guild module into the cache and the database. ''' #await psql.Guilds._insert_one(conn, guild) await psql . Guild . insert_one ( conn , psql . Guild ( guild . id , guild . name )) guild_info = await psql . Guild . get_one ( conn , guild . id , as_dict = True ) self . guild_module = guild_info","title":"add_guild_module()"},{"location":"dev/models/#utils.models.GuildCache.update_guild_module","text":"Edit a guild module data in the cache and the database. Source code in utils\\models.py 94 95 96 97 98 99 async def update_guild_module ( self , conn , guild_id : int , column : str , new_value ): ''' Edit a guild module data in the cache and the database. ''' await psql . Guild . update_column ( conn , guild_id , column , new_value ) self . guild_module [ column ] = new_value","title":"update_guild_module()"},{"location":"dev/models/#utils.models.GuildCache.add_logging_module","text":"Add a logging module into the cache and the database. Source code in utils\\models.py 101 102 103 104 105 106 107 async def add_logging_module ( self , conn , guild : hikari . Guild ): ''' Add a logging module into the cache and the database. ''' await psql . GuildsLogs . insert_one ( conn , guild . id ) logging_info = await psql . GuildsLogs . get_one ( conn , guild . id , as_dict = True ) self . logging_module = logging_info","title":"add_logging_module()"},{"location":"dev/models/#utils.models.GuildCache.update_logging_module","text":"Update a logging module in the cache and the database. Source code in utils\\models.py 109 110 111 112 113 114 async def update_logging_module ( self , conn , guild_id : int , column : str , new_value ): ''' Update a logging module in the cache and the database. ''' await psql . GuildsLogs . update_column ( conn , guild_id , column , new_value ) self . logging_module [ column ] = new_value","title":"update_logging_module()"},{"location":"dev/models/#utils.models.GuildCache.force_sync","text":"Force this object to update with database. If the method returns None , the entry for this guild isn't on the database, thus you should use add_guild_module() instead. Otherwise, it returns itself. Source code in utils\\models.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 async def force_sync ( self , conn , guild_id : int ): ''' Force this object to update with database. If the method returns `None`, the entry for this guild isn't on the database, thus you should use `add_guild_module()` instead. Otherwise, it returns itself. ''' guild = await psql . Guild . get_one ( conn , guild_id , as_dict = True ) if guild is None : return None else : guild . pop ( \"id\" , None ) guild_log = await psql . GuildsLogs . get_one ( conn , guild_id , as_dict = True ) if guild_log is None : guild_log = {} else : guild_log . pop ( \"guild_id\" , None ) self . guild_module = guild self . logging_module = guild_log return self","title":"force_sync()"},{"location":"dev/models/#utils.models.DefaultColor","text":"Bases: Enum Store several default colors to use instantly. Source code in utils\\models.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 class DefaultColor ( Enum ): ''' Store several default colors to use instantly. ''' teal = hikari . Color ( 0x1abc9c ) dark_teal = hikari . Color ( 0x11806a ) brand_green = hikari . Color ( 0x57F287 ) green = hikari . Color ( 0x2ecc71 ) dark_green = hikari . Color ( 0x1f8b4c ) blue = hikari . Color ( 0x3498db ) dark_blue = hikari . Color ( 0x206694 ) purple = hikari . Color ( 0x9b59b6 ) dark_purple = hikari . Color ( 0x71368a ) magenta = hikari . Color ( 0xe91e63 ) dark_magenta = hikari . Color ( 0xad1457 ) gold = hikari . Color ( 0xf1c40f ) dark_gold = hikari . Color ( 0xc27c0e ) orange = hikari . Color ( 0xe67e22 ) dark_orange = hikari . Color ( 0xa84300 ) brand_red = hikari . Color ( 0xED4245 ) red = hikari . Color ( 0xe74c3c ) dark_red = hikari . Color ( 0x992d22 ) lighter_gray = hikari . Color ( 0x95a5a6 ) dark_gray = hikari . Color ( 0x607d8b ) light_gray = hikari . Color ( 0x979c9f ) darker_gray = hikari . Color ( 0x546e7a ) og_blurple = hikari . Color ( 0x7289da ) blurple = hikari . Color ( 0x5865F2 ) greyple = hikari . Color ( 0x5865F2 ) dark_theme = hikari . Color ( 0x36393F ) fuchsia = hikari . Color ( 0xEB459E ) yellow = hikari . Color ( 0xFEE75C ) black = hikari . Color ( 0x000000 ) white = hikari . Color ( 0xFFFFFF )","title":"DefaultColor"},{"location":"dev/models/#utils.models.NodeExtra","text":"A class to store extra data for the lavaplayer.Node Source code in utils\\models.py 176 177 178 179 180 @dataclass class NodeExtra : '''A class to store extra data for the `lavaplayer.Node`''' queue_loop : bool = False working_channel : int = 0","title":"NodeExtra"},{"location":"dev/models/#utils.models.MichaelBot","text":"Bases: lightbulb . BotApp A subclass of lightbulb.BotApp . This allows syntax highlight on many custom attributes. Source code in utils\\models.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 class MichaelBot ( lightbulb . BotApp ): '''A subclass of `lightbulb.BotApp`. This allows syntax highlight on many custom attributes.''' __slots__ = ( \"info\" , \"secrets\" , \"online_at\" , \"logging\" , \"pool\" , \"aio_session\" , \"guild_cache\" , \"user_cache\" , \"lavalink\" , \"node_extra\" ) def __init__ ( self , token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None : ''' Parameters ----------------- info : dict The bot info. Store the one in `config.json`. secrets : dict The bot's secrets such as token, database info, etc. ''' self . info : dict = kwargs . pop ( \"info\" ) self . secrets : dict = kwargs . pop ( \"secrets\" ) self . online_at : dt . datetime = None self . pool : t . Optional [ asyncpg . Pool ] = None self . aio_session : t . Optional [ aiohttp . ClientSession ] = None # Store some db info. This allows read-only operation much cheaper. self . guild_cache : dict [ int , GuildCache ] = {} self . user_cache : dict [ int , UserCache ] = {} self . lavalink : t . Optional [ lavaplayer . LavalinkClient ] = None # Currently lavaplayer doesn't support adding attr to lavaplayer.objects.Node # so we'll make a dictionary to manually track additional info. self . node_extra : dict [ int , NodeExtra ] = {} launch_options = self . info . get ( \"launch_options\" ) log_level = \"INFO\" if launch_options is None : launch_options = \"\" for option in launch_options . split (): if option in [ \"--debug\" , \"-d\" ]: default_enabled_guilds = self . info [ \"default_guilds\" ] log_level = \"DEBUG\" if option in [ \"--quiet\" , \"-q\" ]: log_level = \"\" super () . __init__ ( token , prefix , ignore_bots , owner_ids , default_enabled_guilds , help_class , help_slash_command , delete_unbound_commands , case_insensitive_prefix_commands , logs = log_level if bool ( log_level ) else None , ** kwargs ) def get_slash_command ( self , name : str ) -> t . Optional [ lightbulb . SlashCommand ]: '''Get the slash command with the given name, or `None` if none was found. Unlike the default behavior in `lightbulb.BotApp`, this also searches for subcommands. Parameters ---------- name : str The command name to search. Returns ------- t.Optional[lightbulb.SlashCommand] The slash command with that name, or `None` if none was found. ''' # Reference: https://hikari-lightbulb.readthedocs.io/en/latest/_modules/lightbulb/app.html#BotApp.get_prefix_command parts = name . split () if len ( parts ) == 1 : return self . _slash_commands . get ( name ) maybe_group = self . _slash_commands . get ( parts . pop ( 0 )) if not isinstance ( maybe_group , lightbulb . SlashCommandGroup ): return None this : t . Optional [ t . Union [ lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup , lightbulb . SlashSubCommand ] ] = maybe_group for part in parts : if this is None or isinstance ( this , lightbulb . SlashSubCommand ): return None this = this . get_subcommand ( part ) return this","title":"MichaelBot"},{"location":"dev/models/#utils.models.MichaelBot.__init__","text":"Parameters: Name Type Description Default info dict The bot info. Store the one in config.json . required secrets dict The bot's secrets such as token, database info, etc. required Source code in utils\\models.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def __init__ ( self , token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None : ''' Parameters ----------------- info : dict The bot info. Store the one in `config.json`. secrets : dict The bot's secrets such as token, database info, etc. ''' self . info : dict = kwargs . pop ( \"info\" ) self . secrets : dict = kwargs . pop ( \"secrets\" ) self . online_at : dt . datetime = None self . pool : t . Optional [ asyncpg . Pool ] = None self . aio_session : t . Optional [ aiohttp . ClientSession ] = None # Store some db info. This allows read-only operation much cheaper. self . guild_cache : dict [ int , GuildCache ] = {} self . user_cache : dict [ int , UserCache ] = {} self . lavalink : t . Optional [ lavaplayer . LavalinkClient ] = None # Currently lavaplayer doesn't support adding attr to lavaplayer.objects.Node # so we'll make a dictionary to manually track additional info. self . node_extra : dict [ int , NodeExtra ] = {} launch_options = self . info . get ( \"launch_options\" ) log_level = \"INFO\" if launch_options is None : launch_options = \"\" for option in launch_options . split (): if option in [ \"--debug\" , \"-d\" ]: default_enabled_guilds = self . info [ \"default_guilds\" ] log_level = \"DEBUG\" if option in [ \"--quiet\" , \"-q\" ]: log_level = \"\" super () . __init__ ( token , prefix , ignore_bots , owner_ids , default_enabled_guilds , help_class , help_slash_command , delete_unbound_commands , case_insensitive_prefix_commands , logs = log_level if bool ( log_level ) else None , ** kwargs )","title":"__init__()"},{"location":"dev/models/#utils.models.MichaelBot.get_slash_command","text":"Get the slash command with the given name, or None if none was found. Unlike the default behavior in lightbulb.BotApp , this also searches for subcommands. Parameters: Name Type Description Default name str The command name to search. required Returns: Type Description t . Optional [ lightbulb . SlashCommand ] The slash command with that name, or None if none was found. Source code in utils\\models.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 def get_slash_command ( self , name : str ) -> t . Optional [ lightbulb . SlashCommand ]: '''Get the slash command with the given name, or `None` if none was found. Unlike the default behavior in `lightbulb.BotApp`, this also searches for subcommands. Parameters ---------- name : str The command name to search. Returns ------- t.Optional[lightbulb.SlashCommand] The slash command with that name, or `None` if none was found. ''' # Reference: https://hikari-lightbulb.readthedocs.io/en/latest/_modules/lightbulb/app.html#BotApp.get_prefix_command parts = name . split () if len ( parts ) == 1 : return self . _slash_commands . get ( name ) maybe_group = self . _slash_commands . get ( parts . pop ( 0 )) if not isinstance ( maybe_group , lightbulb . SlashCommandGroup ): return None this : t . Optional [ t . Union [ lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup , lightbulb . SlashSubCommand ] ] = maybe_group for part in parts : if this is None or isinstance ( this , lightbulb . SlashSubCommand ): return None this = this . get_subcommand ( part ) return this","title":"get_slash_command()"},{"location":"dev/psql/","text":"Contains many functions that hide all \"naked\" SQL to use. Error Bases: Exception A base error for high-level PostgreSQL operations. Source code in utils\\psql.py 20 21 class Error ( Exception ): '''A base error for high-level PostgreSQL operations.''' GetError Bases: Error A base error for SELECT operations. Notes This should only be raised when get_x() is implicitly called. This will NOT be raised if the user explicitly calls get_x() . Source code in utils\\psql.py 23 24 25 26 27 28 29 30 class GetError ( Error ): '''A base error for SELECT operations. Notes ----- This should only be raised when `get_x()` is implicitly called. This will NOT be raised if the user explicitly calls `get_x()`. ''' InsertError Bases: Error A base error for INSERT operations. Source code in utils\\psql.py 32 33 class InsertError ( Error ): '''A base error for INSERT operations.''' DeleteError Bases: Error A base error for DELETE operations. Source code in utils\\psql.py 35 36 class DeleteError ( Error ): '''A base error for DELETE operations.''' UpdateError Bases: Error A base error for UPDATE operations. Source code in utils\\psql.py 38 39 class UpdateError ( Error ): '''A base error for UPDATE operations.''' DuplicateArrayElement Bases: UpdateError Raised when trying to add an element that's already available in a non-duplicate list. Source code in utils\\psql.py 41 42 class DuplicateArrayElement ( UpdateError ): '''Raised when trying to add an element that's already available in a non-duplicate list.''' Guild dataclass Represent an entry in the Guilds table along with possible operations related to the table. Source code in utils\\psql.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 @dataclasses . dataclass ( slots = True ) class Guild : '''Represent an entry in the `Guilds` table along with possible operations related to the table.''' id : int name : str is_whitelist : bool = True prefix : str = '$' @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entries in the table.''' return await Guild . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Guilds ORDER BY Guilds.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Guild if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ Guild , dict ]: '''Get the first entry in the table that matches the condition.''' query = \"\"\" SELECT * FROM Guilds WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Guild if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , guild : Guild ) -> int : query = insert_into_query ( \"Guilds\" , len ( guild . __slots__ )) return await run_and_return_count ( conn , query , guild . id , guild . name , guild . is_whitelist , guild . prefix ) @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Guilds WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' query = f \"\"\" UPDATE Guilds SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]] staticmethod async Get all entries in the table. Source code in utils\\psql.py 212 213 214 215 216 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entries in the table.''' return await Guild . get_all_where ( conn , as_dict = as_dict ) get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]] staticmethod async Get all entires in the table that matches the condition. Source code in utils\\psql.py 217 218 219 220 221 222 223 224 225 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Guilds ORDER BY Guilds.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Guild if not as_dict else dict ) get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ Guild , dict ] staticmethod async Get the first entry in the table that matches the condition. Source code in utils\\psql.py 226 227 228 229 230 231 232 233 234 @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ Guild , dict ]: '''Get the first entry in the table that matches the condition.''' query = \"\"\" SELECT * FROM Guilds WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Guild if not as_dict else dict ) delete ( conn : asyncpg . Connection , id : int ) -> int staticmethod async Delete an entry in the table based on the provided key. Source code in utils\\psql.py 239 240 241 242 243 244 245 246 247 @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Guilds WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int staticmethod async Update a specific column with a new value. Notes Always prefer using other functions to update rather than this function if possible. Source code in utils\\psql.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' query = f \"\"\" UPDATE Guilds SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) GuildsLogs dataclass Represent an entry in the GuildsLogs table along with possible operations related to the table. Source code in utils\\psql.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 @dataclasses . dataclass ( slots = True ) class GuildsLogs : '''Represent an entry in the `GuildsLogs` table along with possible operations related to the table.''' guild_id : int log_channel : int guild_channel_create : bool = True guild_channel_delete : bool = True guild_channel_update : bool = True guild_ban : bool = True guild_unban : bool = True guild_update : bool = True member_join : bool = True member_leave : bool = True member_update : bool = True guild_bulk_message_delete : bool = True guild_message_delete : bool = True guild_message_update : bool = True role_create : bool = True role_delete : bool = True role_update : bool = True command_complete : bool = True command_error : bool = True @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ GuildsLogs , dict ]]: '''Get all entries in the table.''' return await GuildsLogs . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ GuildsLogs , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM GuildsLogs; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = GuildsLogs if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> list [ t . Union [ GuildsLogs , dict ]]: '''Get the first entry in the table that matches the condition.''' query = \"\"\" SELECT * FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = GuildsLogs if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , guild_id : int ) -> int : '''Insert an entry into the table.''' query = \"\"\" INSERT INTO GuildsLogs VALUES ($1) ON CONFLICT DO NOTHING; \"\"\" return await run_and_return_count ( conn , query , guild_id ) @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' query = f \"\"\" UPDATE GuildsLogs SET { column } = ($1) WHERE guild_id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ GuildsLogs , dict ]] staticmethod async Get all entries in the table. Source code in utils\\psql.py 288 289 290 291 292 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ GuildsLogs , dict ]]: '''Get all entries in the table.''' return await GuildsLogs . get_all_where ( conn , as_dict = as_dict ) get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ GuildsLogs , dict ]] staticmethod async Get all entires in the table that matches the condition. Source code in utils\\psql.py 293 294 295 296 297 298 299 300 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ GuildsLogs , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM GuildsLogs; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = GuildsLogs if not as_dict else dict ) get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> list [ t . Union [ GuildsLogs , dict ]] staticmethod async Get the first entry in the table that matches the condition. Source code in utils\\psql.py 301 302 303 304 305 306 307 308 309 @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> list [ t . Union [ GuildsLogs , dict ]]: '''Get the first entry in the table that matches the condition.''' query = \"\"\" SELECT * FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = GuildsLogs if not as_dict else dict ) insert_one ( conn : asyncpg . Connection , guild_id : int ) -> int staticmethod async Insert an entry into the table. Source code in utils\\psql.py 310 311 312 313 314 315 316 317 318 @staticmethod async def insert_one ( conn : asyncpg . Connection , guild_id : int ) -> int : '''Insert an entry into the table.''' query = \"\"\" INSERT INTO GuildsLogs VALUES ($1) ON CONFLICT DO NOTHING; \"\"\" return await run_and_return_count ( conn , query , guild_id ) delete ( conn : asyncpg . Connection , id : int ) -> int staticmethod async Delete an entry in the table based on the provided key. Source code in utils\\psql.py 319 320 321 322 323 324 325 326 327 @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int staticmethod async Update a specific column with a new value. Notes Always prefer using other functions to update rather than this function if possible. Source code in utils\\psql.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' query = f \"\"\" UPDATE GuildsLogs SET { column } = ($1) WHERE guild_id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) User dataclass Represent an entry in the Users table along with possible operations related to the table. Source code in utils\\psql.py 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 @dataclasses . dataclass ( slots = True ) class User : '''Represent an entry in the `Users` table along with possible operations related to the table.''' id : int name : str is_whitelist : bool = True balance : int = 0 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ User ]: '''Get all entries in the table.''' return await User . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ User , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Users ORDER BY Users.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = User if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , as_dict : bool = False ) -> t . Union [ User , dict ]: '''Get the first entry in the table that matches the condition.''' query = \"\"\" SELECT * FROM Users WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = User if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , user : User ) -> int : query = insert_into_query ( \"Users\" , len ( user . __slots__ )) return await run_and_return_count ( conn , query , user . id , user . name , user . is_whitelist , user . balance ) @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Users WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' query = f \"\"\" UPDATE Users SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ User ] staticmethod async Get all entries in the table. Source code in utils\\psql.py 353 354 355 356 357 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ User ]: '''Get all entries in the table.''' return await User . get_all_where ( conn , as_dict = as_dict ) get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ User , dict ]] staticmethod async Get all entires in the table that matches the condition. Source code in utils\\psql.py 358 359 360 361 362 363 364 365 366 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ User , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Users ORDER BY Users.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = User if not as_dict else dict ) get_one ( conn : asyncpg . Connection , id : int , as_dict : bool = False ) -> t . Union [ User , dict ] staticmethod async Get the first entry in the table that matches the condition. Source code in utils\\psql.py 367 368 369 370 371 372 373 374 375 @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , as_dict : bool = False ) -> t . Union [ User , dict ]: '''Get the first entry in the table that matches the condition.''' query = \"\"\" SELECT * FROM Users WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = User if not as_dict else dict ) delete ( conn : asyncpg . Connection , id : int ) -> int staticmethod async Delete an entry in the table based on the provided key. Source code in utils\\psql.py 380 381 382 383 384 385 386 387 388 @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Users WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int staticmethod async Update a specific column with a new value. Notes Always prefer using other functions to update rather than this function if possible. Source code in utils\\psql.py 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' query = f \"\"\" UPDATE Users SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) Reminders dataclass Represent an entry in the Reminders table along with possible operations related to the table. Source code in utils\\psql.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 @dataclasses . dataclass ( slots = True ) class Reminders : '''Represent an entry in the `Reminders` table along with possible operations related to the table.''' remind_id : int user_id : int awake_time : dt . datetime message : str @staticmethod async def get_user_reminders ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders a user have.''' query = \"\"\" SELECT * FROM Reminders WHERE user_id = ($1); \"\"\" result = await conn . fetch ( query , user_id ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] @staticmethod async def get_reminders ( conn : asyncpg . Connection , lower_time : dt . datetime , upper_time : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders within the time range.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time > ($1) AND awake_time <= ($2); \"\"\" result = await conn . fetch ( query , lower_time , upper_time ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] @staticmethod async def get_past_reminders ( conn : asyncpg . Connection , now : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders that are supposed to be cleared before the time provided.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time < ($1); \"\"\" result = await conn . fetch ( query , now ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] @staticmethod async def insert_reminder ( conn : asyncpg . Connection , user_id : int , when : dt . datetime , message : str ) -> int : '''Insert a reminder entry.''' query = \"\"\" INSERT INTO Reminders (user_id, awake_time, message) VALUES ($1, $2, $3); \"\"\" return await run_and_return_count ( conn , query , user_id , when , message ) @staticmethod async def delete_reminder ( conn : asyncpg . Connection , remind_id : int , user_id : int ) -> int : '''Delete a reminder entry.''' # Although remind_id is sufficient, user_id is to make sure a user can't remove another reminder. query = \"\"\" DELETE FROM Reminders WHERE remind_id = ($1) AND user_id = ($2); \"\"\" return await run_and_return_count ( conn , query , remind_id , user_id ) get_user_reminders ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]] staticmethod async Get a list of reminders a user have. Source code in utils\\psql.py 414 415 416 417 418 419 420 421 422 423 424 @staticmethod async def get_user_reminders ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders a user have.''' query = \"\"\" SELECT * FROM Reminders WHERE user_id = ($1); \"\"\" result = await conn . fetch ( query , user_id ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] get_reminders ( conn : asyncpg . Connection , lower_time : dt . datetime , upper_time : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]] staticmethod async Get a list of reminders within the time range. Source code in utils\\psql.py 425 426 427 428 429 430 431 432 433 434 435 @staticmethod async def get_reminders ( conn : asyncpg . Connection , lower_time : dt . datetime , upper_time : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders within the time range.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time > ($1) AND awake_time <= ($2); \"\"\" result = await conn . fetch ( query , lower_time , upper_time ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] get_past_reminders ( conn : asyncpg . Connection , now : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]] staticmethod async Get a list of reminders that are supposed to be cleared before the time provided. Source code in utils\\psql.py 436 437 438 439 440 441 442 443 444 445 446 @staticmethod async def get_past_reminders ( conn : asyncpg . Connection , now : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders that are supposed to be cleared before the time provided.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time < ($1); \"\"\" result = await conn . fetch ( query , now ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] insert_reminder ( conn : asyncpg . Connection , user_id : int , when : dt . datetime , message : str ) -> int staticmethod async Insert a reminder entry. Source code in utils\\psql.py 447 448 449 450 451 452 453 454 455 @staticmethod async def insert_reminder ( conn : asyncpg . Connection , user_id : int , when : dt . datetime , message : str ) -> int : '''Insert a reminder entry.''' query = \"\"\" INSERT INTO Reminders (user_id, awake_time, message) VALUES ($1, $2, $3); \"\"\" return await run_and_return_count ( conn , query , user_id , when , message ) delete_reminder ( conn : asyncpg . Connection , remind_id : int , user_id : int ) -> int staticmethod async Delete a reminder entry. Source code in utils\\psql.py 456 457 458 459 460 461 462 463 464 465 @staticmethod async def delete_reminder ( conn : asyncpg . Connection , remind_id : int , user_id : int ) -> int : '''Delete a reminder entry.''' # Although remind_id is sufficient, user_id is to make sure a user can't remove another reminder. query = \"\"\" DELETE FROM Reminders WHERE remind_id = ($1) AND user_id = ($2); \"\"\" return await run_and_return_count ( conn , query , remind_id , user_id ) Lockdown dataclass Represent an entry in the Lockdown table along with possible operations related to the table. Source code in utils\\psql.py 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 @dataclasses . dataclass ( slots = True ) class Lockdown : '''Represent an entry in the `Lockdown` table along with possible operations related to the table.''' guild_id : int channels : list [ int ] = dataclasses . field ( default_factory = list ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Lockdown , dict ]]: return await Lockdown . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Lockdown , dict ]]: query = \"\"\" SELECT * FROM Lockdown; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Lockdown if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , guild_id : int , * , as_dict : bool = False ) -> t . Union [ Lockdown , dict ]: query = \"\"\" SELECT * FROM Lockdown WHERE guild_id = ($1); \"\"\" return await __get_one__ ( conn , query , guild_id , result_type = Lockdown if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , lockdown : Lockdown ) -> int : query = insert_into_query ( \"Lockdown\" , len ( lockdown . __slots__ )) return await run_and_return_count ( conn , query , lockdown . guild_id , lockdown . channels ) @staticmethod async def delete ( conn : asyncpg . Connection , guild_id : int ) -> int : '''Delete an entry from the table. Parameters ---------- conn : asyncpg.Connection The connection to use. guild_id : int The pkey to the entry. Returns ------- int The number of entries deleted. ''' query = \"\"\" DELETE FROM Lockdown WHERE guild_id = ($1); \"\"\" return await run_and_return_count ( conn , query , guild_id ) @staticmethod async def update_column ( conn : asyncpg . Connection , guild_id : int , column : str , new_value ) -> int : '''Update a column with a new value. Parameters ---------- conn : asyncpg.Connection The connection to use. guild_id : int The entry pkey to update. column : str The column's name. new_value : _type_ The new value to update. Returns ------- int The number of entries updated. ''' query = f \"\"\" UPDATE Lockdown SET { column } = ($1) WHERE guild_id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , guild_id ) @staticmethod async def add_channel ( conn : asyncpg . Connection , guild_id : int , channel_id : int ) -> int : '''Append a channel to the guild provided. Parameters ---------- conn : asyncpg.Connection The connection to use. guild_id : int The guild id to add. channel_id : int The channel id to add. Returns ------- int The number of entries added. Should be 1 or 0. Raises ------ GetError The entry `guild_id` doesn't exist in the table. ''' # There's probably a postgres way to append the element directly but I'm not gonna risk it. existed = await Lockdown . get_one ( conn , guild_id ) if not existed : raise GetError ( f \"Entry { guild_id } is not found in table 'Lockdown'.\" ) if channel_id in existed . channels : return 0 existed . channels . append ( channel_id ) return await Lockdown . update_column ( conn , guild_id , \"channels\" , existed . channels ) @staticmethod async def remove_channel ( conn : asyncpg . Connection , guild_id : int , channel_id : int ) -> int : '''Remove a channel from the guild provided. Parameters ---------- conn : asyncpg.Connection The connection to use. guild_id : int The guild id to remove. channel_id : int The channel id to remove. Returns ------- int The number of entries removed. Should be 1 or 0. Raises ------ GetError The entry `guild_id` doesn't exist in the table. ''' existed = await Lockdown . get_one ( conn , guild_id ) if not existed : raise GetError ( f \"Entry { guild_id } is not found in table 'Lockdown'.\" ) if channel_id not in existed . channels : return 0 existed . channels . remove ( channel_id ) return await Lockdown . update_column ( conn , guild_id , \"channels\" , existed . channels ) delete ( conn : asyncpg . Connection , guild_id : int ) -> int staticmethod async Delete an entry from the table. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required guild_id int The pkey to the entry. required Returns: Type Description int The number of entries deleted. Source code in utils\\psql.py 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 @staticmethod async def delete ( conn : asyncpg . Connection , guild_id : int ) -> int : '''Delete an entry from the table. Parameters ---------- conn : asyncpg.Connection The connection to use. guild_id : int The pkey to the entry. Returns ------- int The number of entries deleted. ''' query = \"\"\" DELETE FROM Lockdown WHERE guild_id = ($1); \"\"\" return await run_and_return_count ( conn , query , guild_id ) update_column ( conn : asyncpg . Connection , guild_id : int , column : str , new_value ) -> int staticmethod async Update a column with a new value. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required guild_id int The entry pkey to update. required column str The column's name. required new_value _type_ The new value to update. required Returns: Type Description int The number of entries updated. Source code in utils\\psql.py 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 @staticmethod async def update_column ( conn : asyncpg . Connection , guild_id : int , column : str , new_value ) -> int : '''Update a column with a new value. Parameters ---------- conn : asyncpg.Connection The connection to use. guild_id : int The entry pkey to update. column : str The column's name. new_value : _type_ The new value to update. Returns ------- int The number of entries updated. ''' query = f \"\"\" UPDATE Lockdown SET { column } = ($1) WHERE guild_id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , guild_id ) add_channel ( conn : asyncpg . Connection , guild_id : int , channel_id : int ) -> int staticmethod async Append a channel to the guild provided. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required guild_id int The guild id to add. required channel_id int The channel id to add. required Returns: Type Description int The number of entries added. Should be 1 or 0. Raises: Type Description GetError The entry guild_id doesn't exist in the table. Source code in utils\\psql.py 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 @staticmethod async def add_channel ( conn : asyncpg . Connection , guild_id : int , channel_id : int ) -> int : '''Append a channel to the guild provided. Parameters ---------- conn : asyncpg.Connection The connection to use. guild_id : int The guild id to add. channel_id : int The channel id to add. Returns ------- int The number of entries added. Should be 1 or 0. Raises ------ GetError The entry `guild_id` doesn't exist in the table. ''' # There's probably a postgres way to append the element directly but I'm not gonna risk it. existed = await Lockdown . get_one ( conn , guild_id ) if not existed : raise GetError ( f \"Entry { guild_id } is not found in table 'Lockdown'.\" ) if channel_id in existed . channels : return 0 existed . channels . append ( channel_id ) return await Lockdown . update_column ( conn , guild_id , \"channels\" , existed . channels ) remove_channel ( conn : asyncpg . Connection , guild_id : int , channel_id : int ) -> int staticmethod async Remove a channel from the guild provided. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required guild_id int The guild id to remove. required channel_id int The channel id to remove. required Returns: Type Description int The number of entries removed. Should be 1 or 0. Raises: Type Description GetError The entry guild_id doesn't exist in the table. Source code in utils\\psql.py 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 @staticmethod async def remove_channel ( conn : asyncpg . Connection , guild_id : int , channel_id : int ) -> int : '''Remove a channel from the guild provided. Parameters ---------- conn : asyncpg.Connection The connection to use. guild_id : int The guild id to remove. channel_id : int The channel id to remove. Returns ------- int The number of entries removed. Should be 1 or 0. Raises ------ GetError The entry `guild_id` doesn't exist in the table. ''' existed = await Lockdown . get_one ( conn , guild_id ) if not existed : raise GetError ( f \"Entry { guild_id } is not found in table 'Lockdown'.\" ) if channel_id not in existed . channels : return 0 existed . channels . remove ( channel_id ) return await Lockdown . update_column ( conn , guild_id , \"channels\" , existed . channels ) Item dataclass Represent an entry in the Items table along with possible operations related to the table. Source code in utils\\psql.py 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 @dataclasses . dataclass ( slots = True ) class Item : '''Represent an entry in the `Items` table along with possible operations related to the table.''' id : str sort_id : int name : str emoji : str description : str sell_price : int buy_price : int = None aliases : list [ str ] = dataclasses . field ( default_factory = list ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]]: return await Item . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Item ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]]: query = \"\"\" SELECT * FROM Items ORDER by sort_id; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Item if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ]: query = \"\"\" SELECT * FROM Items WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Item if not as_dict else dict ) @staticmethod async def get_by_name ( conn : asyncpg . Connection , name_or_alias : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ]: def filter_name_alias ( record : Item ): return record . name == name_or_alias or name_or_alias in record . aliases res = await Item . get_all_where ( conn , where = filter_name_alias , as_dict = as_dict ) assert len ( res ) == 1 return res [ 0 ] @staticmethod async def insert_one ( conn : asyncpg . Connection , item : Item ): query = insert_into_query ( \"Items\" , len ( item . __slots__ )) return await run_and_return_count ( conn , query , item . id , item . sort_id , item . name , item . aliases , item . emoji , item . description , item . buy_price , item . sell_price , ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : str , column : str , new_value ) -> int : query = f \"\"\" UPDATE Items SET { column } = ($2) WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id , new_value ) @staticmethod async def sync ( conn : asyncpg . Connection , item : Item ): '''Update the item in the database with the new values, or insert it if not exist. Notes ----- This is a rather expensive call since it'll call `Items.get_one()` in addition to updating. Parameters ---------- conn : asyncpg.Connection The connection to use. item : Item The new item. `item.id` will be used to find the item, while the rest of the values will update. ''' existing_item = await Item . get_one ( conn , item . id ) if existing_item is None : await Item . insert_one ( conn , item ) logger . info ( \"Loaded new item ' %s ' into the database.\" , item . id ) else : diff_col = [] for col in existing_item . __slots__ : if getattr ( existing_item , col ) != getattr ( item , col ): diff_col . append ( col ) for change in diff_col : await Item . update_column ( conn , item . id , change , getattr ( item , change )) if diff_col : logger . info ( \"Updated item ' %s ' in the following columns: %s .\" , item . id , diff_col ) sync ( conn : asyncpg . Connection , item : Item ) staticmethod async Update the item in the database with the new values, or insert it if not exist. Notes This is a rather expensive call since it'll call Items.get_one() in addition to updating. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required item Item The new item. item.id will be used to find the item, while the rest of the values will update. required Source code in utils\\psql.py 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 @staticmethod async def sync ( conn : asyncpg . Connection , item : Item ): '''Update the item in the database with the new values, or insert it if not exist. Notes ----- This is a rather expensive call since it'll call `Items.get_one()` in addition to updating. Parameters ---------- conn : asyncpg.Connection The connection to use. item : Item The new item. `item.id` will be used to find the item, while the rest of the values will update. ''' existing_item = await Item . get_one ( conn , item . id ) if existing_item is None : await Item . insert_one ( conn , item ) logger . info ( \"Loaded new item ' %s ' into the database.\" , item . id ) else : diff_col = [] for col in existing_item . __slots__ : if getattr ( existing_item , col ) != getattr ( item , col ): diff_col . append ( col ) for change in diff_col : await Item . update_column ( conn , item . id , change , getattr ( item , change )) if diff_col : logger . info ( \"Updated item ' %s ' in the following columns: %s .\" , item . id , diff_col ) record_to_type ( / , record : asyncpg . Record , result_type : t . Type [ T ] = dict ) -> T Convert a asyncpg.Record into a dict or None if the object is already None . This is for convenience purpose, where dict(Record) will return {} which is not an accurate representation of empty. obj is None or obj is not None is more obvious to anyone than bool(obj) or not bool(obj) . Parameters: Name Type Description Default record asyncpg . Record The record to convert. required result_type t . Type The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a dict . Default to dict . dict Return t.Optional[T] Either None or result_type . Source code in utils\\psql.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def record_to_type ( record : asyncpg . Record , result_type : t . Type [ T ] = dict , / ) -> T : '''Convert a `asyncpg.Record` into a `dict` or `None` if the object is already `None`. This is for convenience purpose, where `dict(Record)` will return `{}` which is not an accurate representation of empty. `obj is None` or `obj is not None` is more obvious to anyone than `bool(obj)` or `not bool(obj)`. Parameters ---------- record : asyncpg.Record The record to convert. result_type : t.Type The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a `dict`. Default to `dict`. Return ------ t.Optional[T] Either `None` or `result_type`. ''' if record is None : return None d = dict ( record ) if result_type is dict : return d return result_type ( ** d ) legacy_insert_into ( conn , table_name : str , * args ) async Insert values into table_name . Warning: This function is an old function from pre-rewrite. It is advised to do the logic by yourself. Source code in utils\\psql.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 async def legacy_insert_into ( conn , table_name : str , * args ): ''' Insert values into `table_name`. Warning: This function is an old function from pre-rewrite. It is advised to do the logic by yourself. ''' arg_str = \"(\" # max(*args, key = len): Get the longest tuple in the list. for j in range ( len ( max ( * args , key = len ))): arg_str += f \"$ { j + 1 } , \" arg_str = arg_str [: - 2 ] + ')' await conn . executemany ( f ''' INSERT INTO { table_name } VALUES { arg_str } ''' , * args ) insert_into_query ( table_name : str , len_col : int ) -> str Return the query to insert into a table that has len_col columns. Parameters: Name Type Description Default table_name str The table to insert. required len_col int How many column does the table have. required Returns: Type Description str An INSERT SQL statement with query formatter ready to use in .execute() Source code in utils\\psql.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def insert_into_query ( table_name : str , len_col : int ) -> str : '''Return the query to insert into a table that has `len_col` columns. Parameters ---------- table_name : str The table to insert. len_col : int How many column does the table have. Returns ------- str An INSERT SQL statement with query formatter ready to use in `.execute()` ''' arg_str = \"(\" for index in range ( len_col ): arg_str += f \"$ { index + 1 } , \" arg_str = arg_str [: - 2 ] + ')' return f \"INSERT INTO { table_name } VALUES { arg_str } ;\" __get_all__ ( conn : asyncpg . Connection , query : str , * , where : t . Callable [[ T ], bool ] = lambda r : True , result_type : t . Type [ T ] = dict ) -> list [ T ] async Run a SELECT statement and return a list of objects. This should NOT be used outside of the module. Instead, use table_name.get_all() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required query str The SELECT statement to run. This should not contain WHERE clause. Conditions should be set in where parameter. required where t . Callable [[ dict ], bool ] Additional conditions to filter. By default, no condition is applied (always return True ). lambda r: True result_type t . Type [ T ] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a dict . Default to dict . dict Returns: Type Description list [ T ] A list of result_type or empty list. Source code in utils\\psql.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 async def __get_all__ ( conn : asyncpg . Connection , query : str , * , where : t . Callable [[ T ], bool ] = lambda r : True , result_type : t . Type [ T ] = dict ) -> list [ T ]: '''Run a `SELECT` statement and return a list of objects. This should NOT be used outside of the module. Instead, use `table_name.get_all()`. Parameters ---------- conn : asyncpg.Connection The connection to use. query : str The `SELECT` statement to run. This should not contain `WHERE` clause. Conditions should be set in `where` parameter. where : t.Callable[[dict], bool] Additional conditions to filter. By default, no condition is applied (always return `True`). result_type : t.Type[T] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a `dict`. Default to `dict`. Returns ------- list[T] A list of `result_type` or empty list. ''' result = await conn . fetch ( query ) l = [] record_obj = None for record in result : # NOTE: This code is for handling dict case; will remove soon. #record_obj = record_to_type(record) #if record_obj is None or (record_obj is not None and where(record_obj)): # l.append(record_obj) record_obj = record_to_type ( record , result_type ) if record_obj is None or ( record_obj is not None and where ( record_obj )): l . append ( record_obj ) return l __get_one__ ( conn : asyncpg . Connection , query : str , * constraints , result_type : t . Type [ T ] = dict ) -> t . Optional [ T ] async Run a SELECT statement and return the first object that matches the constraints. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required query str The SELECT statement to run. This should contain a WHERE clause. required *constraints str Arguments to be formatted into the query. () result_type t . Type [ T ] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a dict . Default to dict . dict Returns: Type Description t . Optional [ T ] A result_type or None if no object is found. Source code in utils\\psql.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 async def __get_one__ ( conn : asyncpg . Connection , query : str , * constraints , result_type : t . Type [ T ] = dict ) -> t . Optional [ T ]: '''Run a `SELECT` statement and return the first object that matches the constraints. Parameters ---------- conn : asyncpg.Connection The connection to use. query : str The `SELECT` statement to run. This should contain a `WHERE` clause. *constraints : str Arguments to be formatted into the query. result_type : t.Type[T] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a `dict`. Default to `dict`. Returns ------- t.Optional[T] A `result_type` or `None` if no object is found. ''' record = await conn . fetchrow ( query , * constraints ) return record_to_type ( record , result_type ) run_and_return_count ( conn : asyncpg . Connection , query : str , * args , ** kwargs ) -> t . Optional [ int ] async Execute an SQL operation and return the number of entries affected. Warnings This is meant to run INSERT, DELETE, and UPDATE statements. Other statement might or might not work. Parameters: Name Type Description Default conn asyncpg . Connection The connection to execute. required *args tuple The arguments to pass into conn.execute() () **kwargs The arguments to pass into conn.execute() {} Returns: Type Description t . Optional [ int ] The number of rows affected. If the operation doesn't return the row count, None is returned. Source code in utils\\psql.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 async def run_and_return_count ( conn : asyncpg . Connection , query : str , * args , ** kwargs ) -> t . Optional [ int ]: '''Execute an SQL operation and return the number of entries affected. Warnings -------- This is meant to run INSERT, DELETE, and UPDATE statements. Other statement might or might not work. Parameters ---------- conn : asyncpg.Connection The connection to execute. *args : tuple The arguments to pass into `conn.execute()` **kwargs: dict The arguments to pass into `conn.execute()` Returns ------- t.Optional[int] The number of rows affected. If the operation doesn't return the row count, `None` is returned. ''' status = await conn . execute ( query , * args , ** kwargs ) # INSERT returns \"INSERT oid count\". try : count = int ( status . split ()[ - 1 ]) return count except ValueError : return None","title":"psql.py"},{"location":"dev/psql/#utils.psql.Error","text":"Bases: Exception A base error for high-level PostgreSQL operations. Source code in utils\\psql.py 20 21 class Error ( Exception ): '''A base error for high-level PostgreSQL operations.'''","title":"Error"},{"location":"dev/psql/#utils.psql.GetError","text":"Bases: Error A base error for SELECT operations.","title":"GetError"},{"location":"dev/psql/#utils.psql.GetError--notes","text":"This should only be raised when get_x() is implicitly called. This will NOT be raised if the user explicitly calls get_x() . Source code in utils\\psql.py 23 24 25 26 27 28 29 30 class GetError ( Error ): '''A base error for SELECT operations. Notes ----- This should only be raised when `get_x()` is implicitly called. This will NOT be raised if the user explicitly calls `get_x()`. '''","title":"Notes"},{"location":"dev/psql/#utils.psql.InsertError","text":"Bases: Error A base error for INSERT operations. Source code in utils\\psql.py 32 33 class InsertError ( Error ): '''A base error for INSERT operations.'''","title":"InsertError"},{"location":"dev/psql/#utils.psql.DeleteError","text":"Bases: Error A base error for DELETE operations. Source code in utils\\psql.py 35 36 class DeleteError ( Error ): '''A base error for DELETE operations.'''","title":"DeleteError"},{"location":"dev/psql/#utils.psql.UpdateError","text":"Bases: Error A base error for UPDATE operations. Source code in utils\\psql.py 38 39 class UpdateError ( Error ): '''A base error for UPDATE operations.'''","title":"UpdateError"},{"location":"dev/psql/#utils.psql.DuplicateArrayElement","text":"Bases: UpdateError Raised when trying to add an element that's already available in a non-duplicate list. Source code in utils\\psql.py 41 42 class DuplicateArrayElement ( UpdateError ): '''Raised when trying to add an element that's already available in a non-duplicate list.'''","title":"DuplicateArrayElement"},{"location":"dev/psql/#utils.psql.Guild","text":"Represent an entry in the Guilds table along with possible operations related to the table. Source code in utils\\psql.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 @dataclasses . dataclass ( slots = True ) class Guild : '''Represent an entry in the `Guilds` table along with possible operations related to the table.''' id : int name : str is_whitelist : bool = True prefix : str = '$' @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entries in the table.''' return await Guild . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Guilds ORDER BY Guilds.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Guild if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ Guild , dict ]: '''Get the first entry in the table that matches the condition.''' query = \"\"\" SELECT * FROM Guilds WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Guild if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , guild : Guild ) -> int : query = insert_into_query ( \"Guilds\" , len ( guild . __slots__ )) return await run_and_return_count ( conn , query , guild . id , guild . name , guild . is_whitelist , guild . prefix ) @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Guilds WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' query = f \"\"\" UPDATE Guilds SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id )","title":"Guild"},{"location":"dev/psql/#utils.psql.Guild.get_all","text":"Get all entries in the table. Source code in utils\\psql.py 212 213 214 215 216 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entries in the table.''' return await Guild . get_all_where ( conn , as_dict = as_dict )","title":"get_all()"},{"location":"dev/psql/#utils.psql.Guild.get_all_where","text":"Get all entires in the table that matches the condition. Source code in utils\\psql.py 217 218 219 220 221 222 223 224 225 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Guilds ORDER BY Guilds.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Guild if not as_dict else dict )","title":"get_all_where()"},{"location":"dev/psql/#utils.psql.Guild.get_one","text":"Get the first entry in the table that matches the condition. Source code in utils\\psql.py 226 227 228 229 230 231 232 233 234 @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ Guild , dict ]: '''Get the first entry in the table that matches the condition.''' query = \"\"\" SELECT * FROM Guilds WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Guild if not as_dict else dict )","title":"get_one()"},{"location":"dev/psql/#utils.psql.Guild.delete","text":"Delete an entry in the table based on the provided key. Source code in utils\\psql.py 239 240 241 242 243 244 245 246 247 @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Guilds WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id )","title":"delete()"},{"location":"dev/psql/#utils.psql.Guild.update_column","text":"Update a specific column with a new value.","title":"update_column()"},{"location":"dev/psql/#utils.psql.Guild.update_column--notes","text":"Always prefer using other functions to update rather than this function if possible. Source code in utils\\psql.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' query = f \"\"\" UPDATE Guilds SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id )","title":"Notes"},{"location":"dev/psql/#utils.psql.GuildsLogs","text":"Represent an entry in the GuildsLogs table along with possible operations related to the table. Source code in utils\\psql.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 @dataclasses . dataclass ( slots = True ) class GuildsLogs : '''Represent an entry in the `GuildsLogs` table along with possible operations related to the table.''' guild_id : int log_channel : int guild_channel_create : bool = True guild_channel_delete : bool = True guild_channel_update : bool = True guild_ban : bool = True guild_unban : bool = True guild_update : bool = True member_join : bool = True member_leave : bool = True member_update : bool = True guild_bulk_message_delete : bool = True guild_message_delete : bool = True guild_message_update : bool = True role_create : bool = True role_delete : bool = True role_update : bool = True command_complete : bool = True command_error : bool = True @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ GuildsLogs , dict ]]: '''Get all entries in the table.''' return await GuildsLogs . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ GuildsLogs , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM GuildsLogs; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = GuildsLogs if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> list [ t . Union [ GuildsLogs , dict ]]: '''Get the first entry in the table that matches the condition.''' query = \"\"\" SELECT * FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = GuildsLogs if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , guild_id : int ) -> int : '''Insert an entry into the table.''' query = \"\"\" INSERT INTO GuildsLogs VALUES ($1) ON CONFLICT DO NOTHING; \"\"\" return await run_and_return_count ( conn , query , guild_id ) @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' query = f \"\"\" UPDATE GuildsLogs SET { column } = ($1) WHERE guild_id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id )","title":"GuildsLogs"},{"location":"dev/psql/#utils.psql.GuildsLogs.get_all","text":"Get all entries in the table. Source code in utils\\psql.py 288 289 290 291 292 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ GuildsLogs , dict ]]: '''Get all entries in the table.''' return await GuildsLogs . get_all_where ( conn , as_dict = as_dict )","title":"get_all()"},{"location":"dev/psql/#utils.psql.GuildsLogs.get_all_where","text":"Get all entires in the table that matches the condition. Source code in utils\\psql.py 293 294 295 296 297 298 299 300 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ GuildsLogs , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM GuildsLogs; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = GuildsLogs if not as_dict else dict )","title":"get_all_where()"},{"location":"dev/psql/#utils.psql.GuildsLogs.get_one","text":"Get the first entry in the table that matches the condition. Source code in utils\\psql.py 301 302 303 304 305 306 307 308 309 @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> list [ t . Union [ GuildsLogs , dict ]]: '''Get the first entry in the table that matches the condition.''' query = \"\"\" SELECT * FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = GuildsLogs if not as_dict else dict )","title":"get_one()"},{"location":"dev/psql/#utils.psql.GuildsLogs.insert_one","text":"Insert an entry into the table. Source code in utils\\psql.py 310 311 312 313 314 315 316 317 318 @staticmethod async def insert_one ( conn : asyncpg . Connection , guild_id : int ) -> int : '''Insert an entry into the table.''' query = \"\"\" INSERT INTO GuildsLogs VALUES ($1) ON CONFLICT DO NOTHING; \"\"\" return await run_and_return_count ( conn , query , guild_id )","title":"insert_one()"},{"location":"dev/psql/#utils.psql.GuildsLogs.delete","text":"Delete an entry in the table based on the provided key. Source code in utils\\psql.py 319 320 321 322 323 324 325 326 327 @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await run_and_return_count ( conn , query , id )","title":"delete()"},{"location":"dev/psql/#utils.psql.GuildsLogs.update_column","text":"Update a specific column with a new value.","title":"update_column()"},{"location":"dev/psql/#utils.psql.GuildsLogs.update_column--notes","text":"Always prefer using other functions to update rather than this function if possible. Source code in utils\\psql.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' query = f \"\"\" UPDATE GuildsLogs SET { column } = ($1) WHERE guild_id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id )","title":"Notes"},{"location":"dev/psql/#utils.psql.User","text":"Represent an entry in the Users table along with possible operations related to the table. Source code in utils\\psql.py 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 @dataclasses . dataclass ( slots = True ) class User : '''Represent an entry in the `Users` table along with possible operations related to the table.''' id : int name : str is_whitelist : bool = True balance : int = 0 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ User ]: '''Get all entries in the table.''' return await User . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ User , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Users ORDER BY Users.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = User if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , as_dict : bool = False ) -> t . Union [ User , dict ]: '''Get the first entry in the table that matches the condition.''' query = \"\"\" SELECT * FROM Users WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = User if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , user : User ) -> int : query = insert_into_query ( \"Users\" , len ( user . __slots__ )) return await run_and_return_count ( conn , query , user . id , user . name , user . is_whitelist , user . balance ) @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Users WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' query = f \"\"\" UPDATE Users SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id )","title":"User"},{"location":"dev/psql/#utils.psql.User.get_all","text":"Get all entries in the table. Source code in utils\\psql.py 353 354 355 356 357 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ User ]: '''Get all entries in the table.''' return await User . get_all_where ( conn , as_dict = as_dict )","title":"get_all()"},{"location":"dev/psql/#utils.psql.User.get_all_where","text":"Get all entires in the table that matches the condition. Source code in utils\\psql.py 358 359 360 361 362 363 364 365 366 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ User , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Users ORDER BY Users.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = User if not as_dict else dict )","title":"get_all_where()"},{"location":"dev/psql/#utils.psql.User.get_one","text":"Get the first entry in the table that matches the condition. Source code in utils\\psql.py 367 368 369 370 371 372 373 374 375 @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , as_dict : bool = False ) -> t . Union [ User , dict ]: '''Get the first entry in the table that matches the condition.''' query = \"\"\" SELECT * FROM Users WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = User if not as_dict else dict )","title":"get_one()"},{"location":"dev/psql/#utils.psql.User.delete","text":"Delete an entry in the table based on the provided key. Source code in utils\\psql.py 380 381 382 383 384 385 386 387 388 @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Users WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id )","title":"delete()"},{"location":"dev/psql/#utils.psql.User.update_column","text":"Update a specific column with a new value.","title":"update_column()"},{"location":"dev/psql/#utils.psql.User.update_column--notes","text":"Always prefer using other functions to update rather than this function if possible. Source code in utils\\psql.py 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' query = f \"\"\" UPDATE Users SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id )","title":"Notes"},{"location":"dev/psql/#utils.psql.Reminders","text":"Represent an entry in the Reminders table along with possible operations related to the table. Source code in utils\\psql.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 @dataclasses . dataclass ( slots = True ) class Reminders : '''Represent an entry in the `Reminders` table along with possible operations related to the table.''' remind_id : int user_id : int awake_time : dt . datetime message : str @staticmethod async def get_user_reminders ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders a user have.''' query = \"\"\" SELECT * FROM Reminders WHERE user_id = ($1); \"\"\" result = await conn . fetch ( query , user_id ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] @staticmethod async def get_reminders ( conn : asyncpg . Connection , lower_time : dt . datetime , upper_time : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders within the time range.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time > ($1) AND awake_time <= ($2); \"\"\" result = await conn . fetch ( query , lower_time , upper_time ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] @staticmethod async def get_past_reminders ( conn : asyncpg . Connection , now : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders that are supposed to be cleared before the time provided.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time < ($1); \"\"\" result = await conn . fetch ( query , now ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] @staticmethod async def insert_reminder ( conn : asyncpg . Connection , user_id : int , when : dt . datetime , message : str ) -> int : '''Insert a reminder entry.''' query = \"\"\" INSERT INTO Reminders (user_id, awake_time, message) VALUES ($1, $2, $3); \"\"\" return await run_and_return_count ( conn , query , user_id , when , message ) @staticmethod async def delete_reminder ( conn : asyncpg . Connection , remind_id : int , user_id : int ) -> int : '''Delete a reminder entry.''' # Although remind_id is sufficient, user_id is to make sure a user can't remove another reminder. query = \"\"\" DELETE FROM Reminders WHERE remind_id = ($1) AND user_id = ($2); \"\"\" return await run_and_return_count ( conn , query , remind_id , user_id )","title":"Reminders"},{"location":"dev/psql/#utils.psql.Reminders.get_user_reminders","text":"Get a list of reminders a user have. Source code in utils\\psql.py 414 415 416 417 418 419 420 421 422 423 424 @staticmethod async def get_user_reminders ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders a user have.''' query = \"\"\" SELECT * FROM Reminders WHERE user_id = ($1); \"\"\" result = await conn . fetch ( query , user_id ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ]","title":"get_user_reminders()"},{"location":"dev/psql/#utils.psql.Reminders.get_reminders","text":"Get a list of reminders within the time range. Source code in utils\\psql.py 425 426 427 428 429 430 431 432 433 434 435 @staticmethod async def get_reminders ( conn : asyncpg . Connection , lower_time : dt . datetime , upper_time : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders within the time range.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time > ($1) AND awake_time <= ($2); \"\"\" result = await conn . fetch ( query , lower_time , upper_time ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ]","title":"get_reminders()"},{"location":"dev/psql/#utils.psql.Reminders.get_past_reminders","text":"Get a list of reminders that are supposed to be cleared before the time provided. Source code in utils\\psql.py 436 437 438 439 440 441 442 443 444 445 446 @staticmethod async def get_past_reminders ( conn : asyncpg . Connection , now : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders that are supposed to be cleared before the time provided.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time < ($1); \"\"\" result = await conn . fetch ( query , now ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ]","title":"get_past_reminders()"},{"location":"dev/psql/#utils.psql.Reminders.insert_reminder","text":"Insert a reminder entry. Source code in utils\\psql.py 447 448 449 450 451 452 453 454 455 @staticmethod async def insert_reminder ( conn : asyncpg . Connection , user_id : int , when : dt . datetime , message : str ) -> int : '''Insert a reminder entry.''' query = \"\"\" INSERT INTO Reminders (user_id, awake_time, message) VALUES ($1, $2, $3); \"\"\" return await run_and_return_count ( conn , query , user_id , when , message )","title":"insert_reminder()"},{"location":"dev/psql/#utils.psql.Reminders.delete_reminder","text":"Delete a reminder entry. Source code in utils\\psql.py 456 457 458 459 460 461 462 463 464 465 @staticmethod async def delete_reminder ( conn : asyncpg . Connection , remind_id : int , user_id : int ) -> int : '''Delete a reminder entry.''' # Although remind_id is sufficient, user_id is to make sure a user can't remove another reminder. query = \"\"\" DELETE FROM Reminders WHERE remind_id = ($1) AND user_id = ($2); \"\"\" return await run_and_return_count ( conn , query , remind_id , user_id )","title":"delete_reminder()"},{"location":"dev/psql/#utils.psql.Lockdown","text":"Represent an entry in the Lockdown table along with possible operations related to the table. Source code in utils\\psql.py 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 @dataclasses . dataclass ( slots = True ) class Lockdown : '''Represent an entry in the `Lockdown` table along with possible operations related to the table.''' guild_id : int channels : list [ int ] = dataclasses . field ( default_factory = list ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Lockdown , dict ]]: return await Lockdown . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Lockdown , dict ]]: query = \"\"\" SELECT * FROM Lockdown; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Lockdown if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , guild_id : int , * , as_dict : bool = False ) -> t . Union [ Lockdown , dict ]: query = \"\"\" SELECT * FROM Lockdown WHERE guild_id = ($1); \"\"\" return await __get_one__ ( conn , query , guild_id , result_type = Lockdown if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , lockdown : Lockdown ) -> int : query = insert_into_query ( \"Lockdown\" , len ( lockdown . __slots__ )) return await run_and_return_count ( conn , query , lockdown . guild_id , lockdown . channels ) @staticmethod async def delete ( conn : asyncpg . Connection , guild_id : int ) -> int : '''Delete an entry from the table. Parameters ---------- conn : asyncpg.Connection The connection to use. guild_id : int The pkey to the entry. Returns ------- int The number of entries deleted. ''' query = \"\"\" DELETE FROM Lockdown WHERE guild_id = ($1); \"\"\" return await run_and_return_count ( conn , query , guild_id ) @staticmethod async def update_column ( conn : asyncpg . Connection , guild_id : int , column : str , new_value ) -> int : '''Update a column with a new value. Parameters ---------- conn : asyncpg.Connection The connection to use. guild_id : int The entry pkey to update. column : str The column's name. new_value : _type_ The new value to update. Returns ------- int The number of entries updated. ''' query = f \"\"\" UPDATE Lockdown SET { column } = ($1) WHERE guild_id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , guild_id ) @staticmethod async def add_channel ( conn : asyncpg . Connection , guild_id : int , channel_id : int ) -> int : '''Append a channel to the guild provided. Parameters ---------- conn : asyncpg.Connection The connection to use. guild_id : int The guild id to add. channel_id : int The channel id to add. Returns ------- int The number of entries added. Should be 1 or 0. Raises ------ GetError The entry `guild_id` doesn't exist in the table. ''' # There's probably a postgres way to append the element directly but I'm not gonna risk it. existed = await Lockdown . get_one ( conn , guild_id ) if not existed : raise GetError ( f \"Entry { guild_id } is not found in table 'Lockdown'.\" ) if channel_id in existed . channels : return 0 existed . channels . append ( channel_id ) return await Lockdown . update_column ( conn , guild_id , \"channels\" , existed . channels ) @staticmethod async def remove_channel ( conn : asyncpg . Connection , guild_id : int , channel_id : int ) -> int : '''Remove a channel from the guild provided. Parameters ---------- conn : asyncpg.Connection The connection to use. guild_id : int The guild id to remove. channel_id : int The channel id to remove. Returns ------- int The number of entries removed. Should be 1 or 0. Raises ------ GetError The entry `guild_id` doesn't exist in the table. ''' existed = await Lockdown . get_one ( conn , guild_id ) if not existed : raise GetError ( f \"Entry { guild_id } is not found in table 'Lockdown'.\" ) if channel_id not in existed . channels : return 0 existed . channels . remove ( channel_id ) return await Lockdown . update_column ( conn , guild_id , \"channels\" , existed . channels )","title":"Lockdown"},{"location":"dev/psql/#utils.psql.Lockdown.delete","text":"Delete an entry from the table. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required guild_id int The pkey to the entry. required Returns: Type Description int The number of entries deleted. Source code in utils\\psql.py 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 @staticmethod async def delete ( conn : asyncpg . Connection , guild_id : int ) -> int : '''Delete an entry from the table. Parameters ---------- conn : asyncpg.Connection The connection to use. guild_id : int The pkey to the entry. Returns ------- int The number of entries deleted. ''' query = \"\"\" DELETE FROM Lockdown WHERE guild_id = ($1); \"\"\" return await run_and_return_count ( conn , query , guild_id )","title":"delete()"},{"location":"dev/psql/#utils.psql.Lockdown.update_column","text":"Update a column with a new value. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required guild_id int The entry pkey to update. required column str The column's name. required new_value _type_ The new value to update. required Returns: Type Description int The number of entries updated. Source code in utils\\psql.py 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 @staticmethod async def update_column ( conn : asyncpg . Connection , guild_id : int , column : str , new_value ) -> int : '''Update a column with a new value. Parameters ---------- conn : asyncpg.Connection The connection to use. guild_id : int The entry pkey to update. column : str The column's name. new_value : _type_ The new value to update. Returns ------- int The number of entries updated. ''' query = f \"\"\" UPDATE Lockdown SET { column } = ($1) WHERE guild_id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , guild_id )","title":"update_column()"},{"location":"dev/psql/#utils.psql.Lockdown.add_channel","text":"Append a channel to the guild provided. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required guild_id int The guild id to add. required channel_id int The channel id to add. required Returns: Type Description int The number of entries added. Should be 1 or 0. Raises: Type Description GetError The entry guild_id doesn't exist in the table. Source code in utils\\psql.py 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 @staticmethod async def add_channel ( conn : asyncpg . Connection , guild_id : int , channel_id : int ) -> int : '''Append a channel to the guild provided. Parameters ---------- conn : asyncpg.Connection The connection to use. guild_id : int The guild id to add. channel_id : int The channel id to add. Returns ------- int The number of entries added. Should be 1 or 0. Raises ------ GetError The entry `guild_id` doesn't exist in the table. ''' # There's probably a postgres way to append the element directly but I'm not gonna risk it. existed = await Lockdown . get_one ( conn , guild_id ) if not existed : raise GetError ( f \"Entry { guild_id } is not found in table 'Lockdown'.\" ) if channel_id in existed . channels : return 0 existed . channels . append ( channel_id ) return await Lockdown . update_column ( conn , guild_id , \"channels\" , existed . channels )","title":"add_channel()"},{"location":"dev/psql/#utils.psql.Lockdown.remove_channel","text":"Remove a channel from the guild provided. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required guild_id int The guild id to remove. required channel_id int The channel id to remove. required Returns: Type Description int The number of entries removed. Should be 1 or 0. Raises: Type Description GetError The entry guild_id doesn't exist in the table. Source code in utils\\psql.py 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 @staticmethod async def remove_channel ( conn : asyncpg . Connection , guild_id : int , channel_id : int ) -> int : '''Remove a channel from the guild provided. Parameters ---------- conn : asyncpg.Connection The connection to use. guild_id : int The guild id to remove. channel_id : int The channel id to remove. Returns ------- int The number of entries removed. Should be 1 or 0. Raises ------ GetError The entry `guild_id` doesn't exist in the table. ''' existed = await Lockdown . get_one ( conn , guild_id ) if not existed : raise GetError ( f \"Entry { guild_id } is not found in table 'Lockdown'.\" ) if channel_id not in existed . channels : return 0 existed . channels . remove ( channel_id ) return await Lockdown . update_column ( conn , guild_id , \"channels\" , existed . channels )","title":"remove_channel()"},{"location":"dev/psql/#utils.psql.Item","text":"Represent an entry in the Items table along with possible operations related to the table. Source code in utils\\psql.py 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 @dataclasses . dataclass ( slots = True ) class Item : '''Represent an entry in the `Items` table along with possible operations related to the table.''' id : str sort_id : int name : str emoji : str description : str sell_price : int buy_price : int = None aliases : list [ str ] = dataclasses . field ( default_factory = list ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]]: return await Item . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Item ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]]: query = \"\"\" SELECT * FROM Items ORDER by sort_id; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Item if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ]: query = \"\"\" SELECT * FROM Items WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Item if not as_dict else dict ) @staticmethod async def get_by_name ( conn : asyncpg . Connection , name_or_alias : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ]: def filter_name_alias ( record : Item ): return record . name == name_or_alias or name_or_alias in record . aliases res = await Item . get_all_where ( conn , where = filter_name_alias , as_dict = as_dict ) assert len ( res ) == 1 return res [ 0 ] @staticmethod async def insert_one ( conn : asyncpg . Connection , item : Item ): query = insert_into_query ( \"Items\" , len ( item . __slots__ )) return await run_and_return_count ( conn , query , item . id , item . sort_id , item . name , item . aliases , item . emoji , item . description , item . buy_price , item . sell_price , ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : str , column : str , new_value ) -> int : query = f \"\"\" UPDATE Items SET { column } = ($2) WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id , new_value ) @staticmethod async def sync ( conn : asyncpg . Connection , item : Item ): '''Update the item in the database with the new values, or insert it if not exist. Notes ----- This is a rather expensive call since it'll call `Items.get_one()` in addition to updating. Parameters ---------- conn : asyncpg.Connection The connection to use. item : Item The new item. `item.id` will be used to find the item, while the rest of the values will update. ''' existing_item = await Item . get_one ( conn , item . id ) if existing_item is None : await Item . insert_one ( conn , item ) logger . info ( \"Loaded new item ' %s ' into the database.\" , item . id ) else : diff_col = [] for col in existing_item . __slots__ : if getattr ( existing_item , col ) != getattr ( item , col ): diff_col . append ( col ) for change in diff_col : await Item . update_column ( conn , item . id , change , getattr ( item , change )) if diff_col : logger . info ( \"Updated item ' %s ' in the following columns: %s .\" , item . id , diff_col )","title":"Item"},{"location":"dev/psql/#utils.psql.Item.sync","text":"Update the item in the database with the new values, or insert it if not exist.","title":"sync()"},{"location":"dev/psql/#utils.psql.Item.sync--notes","text":"This is a rather expensive call since it'll call Items.get_one() in addition to updating. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required item Item The new item. item.id will be used to find the item, while the rest of the values will update. required Source code in utils\\psql.py 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 @staticmethod async def sync ( conn : asyncpg . Connection , item : Item ): '''Update the item in the database with the new values, or insert it if not exist. Notes ----- This is a rather expensive call since it'll call `Items.get_one()` in addition to updating. Parameters ---------- conn : asyncpg.Connection The connection to use. item : Item The new item. `item.id` will be used to find the item, while the rest of the values will update. ''' existing_item = await Item . get_one ( conn , item . id ) if existing_item is None : await Item . insert_one ( conn , item ) logger . info ( \"Loaded new item ' %s ' into the database.\" , item . id ) else : diff_col = [] for col in existing_item . __slots__ : if getattr ( existing_item , col ) != getattr ( item , col ): diff_col . append ( col ) for change in diff_col : await Item . update_column ( conn , item . id , change , getattr ( item , change )) if diff_col : logger . info ( \"Updated item ' %s ' in the following columns: %s .\" , item . id , diff_col )","title":"Notes"},{"location":"dev/psql/#utils.psql.record_to_type","text":"Convert a asyncpg.Record into a dict or None if the object is already None . This is for convenience purpose, where dict(Record) will return {} which is not an accurate representation of empty. obj is None or obj is not None is more obvious to anyone than bool(obj) or not bool(obj) . Parameters: Name Type Description Default record asyncpg . Record The record to convert. required result_type t . Type The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a dict . Default to dict . dict","title":"record_to_type()"},{"location":"dev/psql/#utils.psql.record_to_type--return","text":"t.Optional[T] Either None or result_type . Source code in utils\\psql.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def record_to_type ( record : asyncpg . Record , result_type : t . Type [ T ] = dict , / ) -> T : '''Convert a `asyncpg.Record` into a `dict` or `None` if the object is already `None`. This is for convenience purpose, where `dict(Record)` will return `{}` which is not an accurate representation of empty. `obj is None` or `obj is not None` is more obvious to anyone than `bool(obj)` or `not bool(obj)`. Parameters ---------- record : asyncpg.Record The record to convert. result_type : t.Type The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a `dict`. Default to `dict`. Return ------ t.Optional[T] Either `None` or `result_type`. ''' if record is None : return None d = dict ( record ) if result_type is dict : return d return result_type ( ** d )","title":"Return"},{"location":"dev/psql/#utils.psql.legacy_insert_into","text":"Insert values into table_name . Warning: This function is an old function from pre-rewrite. It is advised to do the logic by yourself. Source code in utils\\psql.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 async def legacy_insert_into ( conn , table_name : str , * args ): ''' Insert values into `table_name`. Warning: This function is an old function from pre-rewrite. It is advised to do the logic by yourself. ''' arg_str = \"(\" # max(*args, key = len): Get the longest tuple in the list. for j in range ( len ( max ( * args , key = len ))): arg_str += f \"$ { j + 1 } , \" arg_str = arg_str [: - 2 ] + ')' await conn . executemany ( f ''' INSERT INTO { table_name } VALUES { arg_str } ''' , * args )","title":"legacy_insert_into()"},{"location":"dev/psql/#utils.psql.insert_into_query","text":"Return the query to insert into a table that has len_col columns. Parameters: Name Type Description Default table_name str The table to insert. required len_col int How many column does the table have. required Returns: Type Description str An INSERT SQL statement with query formatter ready to use in .execute() Source code in utils\\psql.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def insert_into_query ( table_name : str , len_col : int ) -> str : '''Return the query to insert into a table that has `len_col` columns. Parameters ---------- table_name : str The table to insert. len_col : int How many column does the table have. Returns ------- str An INSERT SQL statement with query formatter ready to use in `.execute()` ''' arg_str = \"(\" for index in range ( len_col ): arg_str += f \"$ { index + 1 } , \" arg_str = arg_str [: - 2 ] + ')' return f \"INSERT INTO { table_name } VALUES { arg_str } ;\"","title":"insert_into_query()"},{"location":"dev/psql/#utils.psql.__get_all__","text":"Run a SELECT statement and return a list of objects. This should NOT be used outside of the module. Instead, use table_name.get_all() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required query str The SELECT statement to run. This should not contain WHERE clause. Conditions should be set in where parameter. required where t . Callable [[ dict ], bool ] Additional conditions to filter. By default, no condition is applied (always return True ). lambda r: True result_type t . Type [ T ] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a dict . Default to dict . dict Returns: Type Description list [ T ] A list of result_type or empty list. Source code in utils\\psql.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 async def __get_all__ ( conn : asyncpg . Connection , query : str , * , where : t . Callable [[ T ], bool ] = lambda r : True , result_type : t . Type [ T ] = dict ) -> list [ T ]: '''Run a `SELECT` statement and return a list of objects. This should NOT be used outside of the module. Instead, use `table_name.get_all()`. Parameters ---------- conn : asyncpg.Connection The connection to use. query : str The `SELECT` statement to run. This should not contain `WHERE` clause. Conditions should be set in `where` parameter. where : t.Callable[[dict], bool] Additional conditions to filter. By default, no condition is applied (always return `True`). result_type : t.Type[T] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a `dict`. Default to `dict`. Returns ------- list[T] A list of `result_type` or empty list. ''' result = await conn . fetch ( query ) l = [] record_obj = None for record in result : # NOTE: This code is for handling dict case; will remove soon. #record_obj = record_to_type(record) #if record_obj is None or (record_obj is not None and where(record_obj)): # l.append(record_obj) record_obj = record_to_type ( record , result_type ) if record_obj is None or ( record_obj is not None and where ( record_obj )): l . append ( record_obj ) return l","title":"__get_all__()"},{"location":"dev/psql/#utils.psql.__get_one__","text":"Run a SELECT statement and return the first object that matches the constraints. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required query str The SELECT statement to run. This should contain a WHERE clause. required *constraints str Arguments to be formatted into the query. () result_type t . Type [ T ] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a dict . Default to dict . dict Returns: Type Description t . Optional [ T ] A result_type or None if no object is found. Source code in utils\\psql.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 async def __get_one__ ( conn : asyncpg . Connection , query : str , * constraints , result_type : t . Type [ T ] = dict ) -> t . Optional [ T ]: '''Run a `SELECT` statement and return the first object that matches the constraints. Parameters ---------- conn : asyncpg.Connection The connection to use. query : str The `SELECT` statement to run. This should contain a `WHERE` clause. *constraints : str Arguments to be formatted into the query. result_type : t.Type[T] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a `dict`. Default to `dict`. Returns ------- t.Optional[T] A `result_type` or `None` if no object is found. ''' record = await conn . fetchrow ( query , * constraints ) return record_to_type ( record , result_type )","title":"__get_one__()"},{"location":"dev/psql/#utils.psql.run_and_return_count","text":"Execute an SQL operation and return the number of entries affected.","title":"run_and_return_count()"},{"location":"dev/psql/#utils.psql.run_and_return_count--warnings","text":"This is meant to run INSERT, DELETE, and UPDATE statements. Other statement might or might not work. Parameters: Name Type Description Default conn asyncpg . Connection The connection to execute. required *args tuple The arguments to pass into conn.execute() () **kwargs The arguments to pass into conn.execute() {} Returns: Type Description t . Optional [ int ] The number of rows affected. If the operation doesn't return the row count, None is returned. Source code in utils\\psql.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 async def run_and_return_count ( conn : asyncpg . Connection , query : str , * args , ** kwargs ) -> t . Optional [ int ]: '''Execute an SQL operation and return the number of entries affected. Warnings -------- This is meant to run INSERT, DELETE, and UPDATE statements. Other statement might or might not work. Parameters ---------- conn : asyncpg.Connection The connection to execute. *args : tuple The arguments to pass into `conn.execute()` **kwargs: dict The arguments to pass into `conn.execute()` Returns ------- t.Optional[int] The number of rows affected. If the operation doesn't return the row count, `None` is returned. ''' status = await conn . execute ( query , * args , ** kwargs ) # INSERT returns \"INSERT oid count\". try : count = int ( status . split ()[ - 1 ]) return count except ValueError : return None","title":"Warnings"},{"location":"user/bot/","text":"Bot Category Bot-related Commands changelog [option = stable] Show 10 latest stable changes to the bot. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: option : Additional options. Valid options are dev / development and stable . Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command. help [*name = None] Get help information for the bot. Type: Prefix Command , Slash Command Aliases: h Parameters: name : Category name or command name. Is case-sensitive. info Show information about the bot. Type: Prefix Command , Slash Command Aliases: about ping Check the bot if it's alive. Type: Prefix Command , Slash Command prefix [new_prefix = None] View or edit the bot prefix for the guild. This only affects Prefix Commands. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: new_prefix : The new prefix. Should not be longer than 5 characters or contain spaces. Additional Info: Author needs to have Manage Server permission. report <type> <*reason> Report a bug or suggest a feature for the bot. Please be constructive. Type: Prefix Command , Slash Command (recommended). Cooldown: 5 seconds after 1 use per user. Parameters: type : The type of report you're making. Either bug or suggest . reason : The content you're trying to send. Last updated on Apr 25, 2022","title":"Bot"},{"location":"user/bot/#bot-category","text":"Bot-related Commands","title":"Bot Category"},{"location":"user/bot/#changelog-option-stable","text":"Show 10 latest stable changes to the bot. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: option : Additional options. Valid options are dev / development and stable . Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command.","title":"changelog [option = stable]"},{"location":"user/bot/#help-name-none","text":"Get help information for the bot. Type: Prefix Command , Slash Command Aliases: h Parameters: name : Category name or command name. Is case-sensitive.","title":"help [*name = None]"},{"location":"user/bot/#info","text":"Show information about the bot. Type: Prefix Command , Slash Command Aliases: about","title":"info"},{"location":"user/bot/#ping","text":"Check the bot if it's alive. Type: Prefix Command , Slash Command","title":"ping"},{"location":"user/bot/#prefix-new_prefix-none","text":"View or edit the bot prefix for the guild. This only affects Prefix Commands. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: new_prefix : The new prefix. Should not be longer than 5 characters or contain spaces. Additional Info: Author needs to have Manage Server permission.","title":"prefix [new_prefix = None]"},{"location":"user/bot/#report-type-reason","text":"Report a bug or suggest a feature for the bot. Please be constructive. Type: Prefix Command , Slash Command (recommended). Cooldown: 5 seconds after 1 use per user. Parameters: type : The type of report you're making. Either bug or suggest . reason : The content you're trying to send. Last updated on Apr 25, 2022","title":"report &lt;type&gt; &lt;*reason&gt;"},{"location":"user/fun/","text":"Fun Category Fun Commands copypasta <type> My favorite copypasta. Type: Prefix Command Cooldown: 10 seconds after 1 use per user. Parameters: type : Which copypasta to show. Dig into the bot's code to see available options ;) dadjoke Give you a dad joke. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Aliases: ina-of-the-mountain-what-is-your-wisdom dice Roll a 6-face dice for you. Type: Prefix Command , Slash Command do <action_type> [*user] Perform an anime action. Type: Prefix Command , Slash Command (recommended) Cooldown: 5 seconds after 1 use per user. Parameters: action_type : The action to perform. Valid actions are: angry , cuddle , hug , pat , punch , slap , wink . user : The Discord user to perform the action on. Default to yourself. echo <content> Echo echo echo echo. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per user. Parameters: content : The string to echo. Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command. how <measure_unit> <*target> An ultimate measurement to measure everything. Type: Prefix Command , Slash Command (recommended) Parameters: measure_unit : The unit to measure. target : The target to measure. mock <*text> tuRn A teXT INtO MOCk teXt. Type: Prefix Command , Slash Command (recommended) Parameters: text : Text to mock. Additional Info: The text will be sent through DM if it exceeds 1500 characters. pekofy Pekofy a message peko. Type: Message Command Cooldown: 5 seconds after 1 use per user. speak <*content> Speak the message. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per user. Parameters: content : The string to speak. Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command. uwu <*text> Turn a text into uwu text. Type: Prefix Command , Slash Command , Message Command (recommended) Cooldown: 3 seconds after 1 use per user. Parameters: text : Text to uwuify. Last updated on Apr 10, 2022","title":"Fun"},{"location":"user/fun/#fun-category","text":"Fun Commands","title":"Fun Category"},{"location":"user/fun/#copypasta-type","text":"My favorite copypasta. Type: Prefix Command Cooldown: 10 seconds after 1 use per user. Parameters: type : Which copypasta to show. Dig into the bot's code to see available options ;)","title":"copypasta &lt;type&gt;"},{"location":"user/fun/#dadjoke","text":"Give you a dad joke. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Aliases: ina-of-the-mountain-what-is-your-wisdom","title":"dadjoke"},{"location":"user/fun/#dice","text":"Roll a 6-face dice for you. Type: Prefix Command , Slash Command","title":"dice"},{"location":"user/fun/#do-action_type-user","text":"Perform an anime action. Type: Prefix Command , Slash Command (recommended) Cooldown: 5 seconds after 1 use per user. Parameters: action_type : The action to perform. Valid actions are: angry , cuddle , hug , pat , punch , slap , wink . user : The Discord user to perform the action on. Default to yourself.","title":"do &lt;action_type&gt; [*user]"},{"location":"user/fun/#echo-content","text":"Echo echo echo echo. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per user. Parameters: content : The string to echo. Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command.","title":"echo &lt;content&gt;"},{"location":"user/fun/#how-measure_unit-target","text":"An ultimate measurement to measure everything. Type: Prefix Command , Slash Command (recommended) Parameters: measure_unit : The unit to measure. target : The target to measure.","title":"how &lt;measure_unit&gt; &lt;*target&gt;"},{"location":"user/fun/#mock-text","text":"tuRn A teXT INtO MOCk teXt. Type: Prefix Command , Slash Command (recommended) Parameters: text : Text to mock. Additional Info: The text will be sent through DM if it exceeds 1500 characters.","title":"mock &lt;*text&gt;"},{"location":"user/fun/#pekofy","text":"Pekofy a message peko. Type: Message Command Cooldown: 5 seconds after 1 use per user.","title":"pekofy"},{"location":"user/fun/#speak-content","text":"Speak the message. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per user. Parameters: content : The string to speak. Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command.","title":"speak &lt;*content&gt;"},{"location":"user/fun/#uwu-text","text":"Turn a text into uwu text. Type: Prefix Command , Slash Command , Message Command (recommended) Cooldown: 3 seconds after 1 use per user. Parameters: text : Text to uwuify. Last updated on Apr 10, 2022","title":"uwu &lt;*text&gt;"},{"location":"user/logger/","text":"Logs Category Logging commands. log-set Set a channel as a log channel. Type: Prefix Command Additional Info: This command doesn't do anything. Please use the subcommands. log-set all [channel = None] Set a channel to dump all the logs. This automatically enables logging system. Type: Prefix Command , Slash Command Parameters: channel : The Discord channel to dump all the logs. Default to current channel. Additional Info: Author needs to have Manage Server . log-set option <logging_option> Enable a logging option. Type: Prefix Command , Slash Command (recommended) Parameters: logging_option : Log type to turn on. Check log-view to see all options. Additional Info: Author needs to have Manage Server . It is recommended to use the Slash Command version of the command. log-disable Disable logging or part of the logging system. Type: Prefix Command Additional Info: This command doesn't do anything. Please use the subcommands. log-disable all Disable logging system. Type: Prefix Command , Slash Command log-disable option <logging_option> Disable a logging option. Type: Prefix Command , Slash Command (recommended) Parameters: logging_option : Log type to turn off. Check log-view to see all options. Additional Info: Author needs to have Manage Server . It is recommended to use the Slash Command version of the command. log-view View all log settings. Type: Prefix Command , Slash Command Additional Info: Author needs to have Manage Server . Last updated on Apr 1, 2022","title":"Logs"},{"location":"user/logger/#logs-category","text":"Logging commands.","title":"Logs Category"},{"location":"user/logger/#log-set","text":"Set a channel as a log channel. Type: Prefix Command Additional Info: This command doesn't do anything. Please use the subcommands.","title":"log-set"},{"location":"user/logger/#log-set-all-channel-none","text":"Set a channel to dump all the logs. This automatically enables logging system. Type: Prefix Command , Slash Command Parameters: channel : The Discord channel to dump all the logs. Default to current channel. Additional Info: Author needs to have Manage Server .","title":"log-set all [channel = None]"},{"location":"user/logger/#log-set-option-logging_option","text":"Enable a logging option. Type: Prefix Command , Slash Command (recommended) Parameters: logging_option : Log type to turn on. Check log-view to see all options. Additional Info: Author needs to have Manage Server . It is recommended to use the Slash Command version of the command.","title":"log-set option &lt;logging_option&gt;"},{"location":"user/logger/#log-disable","text":"Disable logging or part of the logging system. Type: Prefix Command Additional Info: This command doesn't do anything. Please use the subcommands.","title":"log-disable"},{"location":"user/logger/#log-disable-all","text":"Disable logging system. Type: Prefix Command , Slash Command","title":"log-disable all"},{"location":"user/logger/#log-disable-option-logging_option","text":"Disable a logging option. Type: Prefix Command , Slash Command (recommended) Parameters: logging_option : Log type to turn off. Check log-view to see all options. Additional Info: Author needs to have Manage Server . It is recommended to use the Slash Command version of the command.","title":"log-disable option &lt;logging_option&gt;"},{"location":"user/logger/#log-view","text":"View all log settings. Type: Prefix Command , Slash Command Additional Info: Author needs to have Manage Server . Last updated on Apr 1, 2022","title":"log-view"},{"location":"user/music/","text":"Music Category Music commands. join [voice_channel = None] Join a voice channel. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: voice_channel : The voice channel to join. Default to the VC you're in. Aliases: connect leave Leave the voice channel. Type: Prefix Command , Slash Command Aliases: dc (recommended), disconnect np Get info about the current track. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild. Aliases: now_playing play <*query> Play the query or add it to the queue. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 5 uses per guild. Parameters: query : The query to play (url, name, etc.) Aliases: p (recommended) pause Toggle pausing the player. Type: Prefix Command , Slash Command c search <*track> Search and return 10 relevant results. You can then copy the desired link into play . Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild. Parameters: track : Keywords to search. Example: blend w . seek <position> Jump to the provided timestamp. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild. Parameters: position : Timestamp to jump to. repeat Toggle repeating the track. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild. volume <vol> Set the volume of the player. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: vol : Volume to set (0-200). Additional Info: It's recommended to use the built-in feature User Volume instead of this command. queue Display the song queue. Type: Prefix Command Cooldown: 2 seconds after 1 use per guild. Aliases: q (recommended) queue view Display the song queue. This exists for Slash Commands. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild. queue clear Clear the entire queue but the current track. Type: Prefix Command , Slash Command queue shuffle Shuffle the queue. Type: Prefix Command , Slash Command queue loop Toggle queue loop. Type: Prefix Command , Slash Command queue move <from_index> <to_index> Move a track in queue to a new order index. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: from_index : The index in the queue to move. to_index : The index in the queue where you want the track to be. queue remove <index> Remove a track in the queue. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: index : The index in the queue to remove. skip Skip the current track. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild. Aliases: s (recommended) stop Stop the player. Type: Prefix Command , Slash Command Last updated on Apr 1, 2022","title":"Music"},{"location":"user/music/#music-category","text":"Music commands.","title":"Music Category"},{"location":"user/music/#join-voice_channel-none","text":"Join a voice channel. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: voice_channel : The voice channel to join. Default to the VC you're in. Aliases: connect","title":"join [voice_channel = None]"},{"location":"user/music/#leave","text":"Leave the voice channel. Type: Prefix Command , Slash Command Aliases: dc (recommended), disconnect","title":"leave"},{"location":"user/music/#np","text":"Get info about the current track. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild. Aliases: now_playing","title":"np"},{"location":"user/music/#play-query","text":"Play the query or add it to the queue. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 5 uses per guild. Parameters: query : The query to play (url, name, etc.) Aliases: p (recommended)","title":"play &lt;*query&gt;"},{"location":"user/music/#pause","text":"Toggle pausing the player. Type: Prefix Command , Slash Command c","title":"pause"},{"location":"user/music/#search-track","text":"Search and return 10 relevant results. You can then copy the desired link into play . Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild. Parameters: track : Keywords to search. Example: blend w .","title":"search &lt;*track&gt;"},{"location":"user/music/#seek-position","text":"Jump to the provided timestamp. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild. Parameters: position : Timestamp to jump to.","title":"seek &lt;position&gt;"},{"location":"user/music/#repeat","text":"Toggle repeating the track. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild.","title":"repeat"},{"location":"user/music/#volume-vol","text":"Set the volume of the player. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: vol : Volume to set (0-200). Additional Info: It's recommended to use the built-in feature User Volume instead of this command.","title":"volume &lt;vol&gt;"},{"location":"user/music/#queue","text":"Display the song queue. Type: Prefix Command Cooldown: 2 seconds after 1 use per guild. Aliases: q (recommended)","title":"queue"},{"location":"user/music/#queue-view","text":"Display the song queue. This exists for Slash Commands. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild.","title":"queue view"},{"location":"user/music/#queue-clear","text":"Clear the entire queue but the current track. Type: Prefix Command , Slash Command","title":"queue clear"},{"location":"user/music/#queue-shuffle","text":"Shuffle the queue. Type: Prefix Command , Slash Command","title":"queue shuffle"},{"location":"user/music/#queue-loop","text":"Toggle queue loop. Type: Prefix Command , Slash Command","title":"queue loop"},{"location":"user/music/#queue-move-from_index-to_index","text":"Move a track in queue to a new order index. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: from_index : The index in the queue to move. to_index : The index in the queue where you want the track to be.","title":"queue move &lt;from_index&gt; &lt;to_index&gt;"},{"location":"user/music/#queue-remove-index","text":"Remove a track in the queue. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: index : The index in the queue to remove.","title":"queue remove &lt;index&gt;"},{"location":"user/music/#skip","text":"Skip the current track. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild. Aliases: s (recommended)","title":"skip"},{"location":"user/music/#stop","text":"Stop the player. Type: Prefix Command , Slash Command Last updated on Apr 1, 2022","title":"stop"},{"location":"user/utilities/","text":"Utilities Category Utility Commands. calc <expression> Calculate a math expression. Type: Prefix Command , Slash Command Parameters: expression : The math expression. Additional Info: Rounding errors, along with other debatable values such as 0^0 is incorrect due to language limitation. embed Send an embed. Additional Info: This command only works with subcommands. embed from-json <raw_embed> Send an embed from a JSON object. Check out https://embedbuilder.nadekobot.me/ for easier time. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: raw_embed : The embed in JSON format. embed to-json <message_id> Take the embed from a message and convert it to a JSON object. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: message_id : The message ID. The bot can't get a message that's too old. Additional Info: This is useful when you want to change slightly from an existing embed. embed simple [title = None] [description = None] [color = green] [channel = None] Create and send a simple embed. Useful for quick embeds. Type: Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: title : The title of the embed. description : The description of the embed. color : Your choice of color. Default to green. channel : The channel to send this embed. Default to the current one. Additional Info: This is an alternative to embed interactive . Either title or description must be non-empty. embed interactive Create a simple embed with prompts. Type: Prefix Command Aliases: embed i Cooldown: 3 seconds after 1 use per user. Additional Info: Bot needs to have Manage Messages . This is an alternative to embed simple . profile [member = None] Information about yourself or another member. Type: Prefix Command , Slash Command Parameters: member : A Discord member. Default to you. remindme Create a reminder. Make sure your DM is open to the bot. Type: None Aliases: rmd , notify , timer Additional Info: This command only works with subcommands. remindme create <interval> <*message> Create a reminder. Make sure your DM is open to the bot. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: interval : How long until the bot reminds you. Must be between 1 minute and 30 days. Example: 3d2m1s message : The message the bot will send after the interval. Additional Info: An interval of less than 120 seconds is considered to be a \"short reminder\". remindme view View all your long reminders. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Additional Info: Due to optimization, this command won't display short reminders. remindme remove <remind_id> Remove a long reminder. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: remind_id : The reminder's id. You can find it in remindme view . Additional Info: Due to optimization, this command won't remove short reminders. role-info <role> Information about a role in this server. Type: Prefix Command , Slash Command Parameters: role : A Discord role. Aliases: roleinfo server-info Information about this server. Type: Prefix Command , Slash Command Aliases: serverinfo urban <*term> Search a term on urbandictionary. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: term : The term to search. Example: rickroll . weather <*city_name> Display weather information for a location. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: city_name : The city to check. Example: Paris . Last updated on Apr 27, 2022","title":"Utilities"},{"location":"user/utilities/#utilities-category","text":"Utility Commands.","title":"Utilities Category"},{"location":"user/utilities/#calc-expression","text":"Calculate a math expression. Type: Prefix Command , Slash Command Parameters: expression : The math expression. Additional Info: Rounding errors, along with other debatable values such as 0^0 is incorrect due to language limitation.","title":"calc &lt;expression&gt;"},{"location":"user/utilities/#embed","text":"Send an embed. Additional Info: This command only works with subcommands.","title":"embed"},{"location":"user/utilities/#embed-from-json-raw_embed","text":"Send an embed from a JSON object. Check out https://embedbuilder.nadekobot.me/ for easier time. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: raw_embed : The embed in JSON format.","title":"embed from-json &lt;raw_embed&gt;"},{"location":"user/utilities/#embed-to-json-message_id","text":"Take the embed from a message and convert it to a JSON object. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: message_id : The message ID. The bot can't get a message that's too old. Additional Info: This is useful when you want to change slightly from an existing embed.","title":"embed to-json &lt;message_id&gt;"},{"location":"user/utilities/#embed-simple-title-none-description-none-color-green-channel-none","text":"Create and send a simple embed. Useful for quick embeds. Type: Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: title : The title of the embed. description : The description of the embed. color : Your choice of color. Default to green. channel : The channel to send this embed. Default to the current one. Additional Info: This is an alternative to embed interactive . Either title or description must be non-empty.","title":"embed simple [title = None] [description = None] [color = green] [channel = None]"},{"location":"user/utilities/#embed-interactive","text":"Create a simple embed with prompts. Type: Prefix Command Aliases: embed i Cooldown: 3 seconds after 1 use per user. Additional Info: Bot needs to have Manage Messages . This is an alternative to embed simple .","title":"embed interactive"},{"location":"user/utilities/#profile-member-none","text":"Information about yourself or another member. Type: Prefix Command , Slash Command Parameters: member : A Discord member. Default to you.","title":"profile [member = None]"},{"location":"user/utilities/#remindme","text":"Create a reminder. Make sure your DM is open to the bot. Type: None Aliases: rmd , notify , timer Additional Info: This command only works with subcommands.","title":"remindme"},{"location":"user/utilities/#remindme-create-interval-message","text":"Create a reminder. Make sure your DM is open to the bot. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: interval : How long until the bot reminds you. Must be between 1 minute and 30 days. Example: 3d2m1s message : The message the bot will send after the interval. Additional Info: An interval of less than 120 seconds is considered to be a \"short reminder\".","title":"remindme create &lt;interval&gt; &lt;*message&gt;"},{"location":"user/utilities/#remindme-view","text":"View all your long reminders. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Additional Info: Due to optimization, this command won't display short reminders.","title":"remindme view"},{"location":"user/utilities/#remindme-remove-remind_id","text":"Remove a long reminder. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: remind_id : The reminder's id. You can find it in remindme view . Additional Info: Due to optimization, this command won't remove short reminders.","title":"remindme remove &lt;remind_id&gt;"},{"location":"user/utilities/#role-info-role","text":"Information about a role in this server. Type: Prefix Command , Slash Command Parameters: role : A Discord role. Aliases: roleinfo","title":"role-info &lt;role&gt;"},{"location":"user/utilities/#server-info","text":"Information about this server. Type: Prefix Command , Slash Command Aliases: serverinfo","title":"server-info"},{"location":"user/utilities/#urban-term","text":"Search a term on urbandictionary. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: term : The term to search. Example: rickroll .","title":"urban &lt;*term&gt;"},{"location":"user/utilities/#weather-city_name","text":"Display weather information for a location. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: city_name : The city to check. Example: Paris . Last updated on Apr 27, 2022","title":"weather &lt;*city_name&gt;"}]}