{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MichaelBot Documentation Welcome to MichaelBot's documentation. This documents all the bot's commands along with its features. For general purposes, please refers to the Commands heading. For those who are interested in some of the more secret stuffs, feel free to look at the bot source code. Below are some of the topics that are might not obvious from a user perspective. Prefix vs Slash MichaelBot has 2 main types of command: prefix command and slash command. Prefix command is the OG \"command system\" that's been widely implemented for pretty much every single bot. Slash command is the official command system in Discord that's been implemented fairly recently. MichaelBot tries to balance these 2, but there are some pros and cons to them: Slash > Prefix: Is officially supported by Discord and is super newbie-friendly. Can use Tab to autocomplete. This makes it somewhat unnecessary for the user to remember the arguments. This is excellent when the user need to input some sort of choice into the command. Arguments are generally easier to deal with since Discord do all the necessary text parsing. Prefix commands don't work without verifying the bot after reaching 100 servers. This is technically not the case for slash commands. Prefix > Slash: Is familiar to a lot of people. Can alias commands. This allows users to smash commands super fast. Slash commands have a hard limit of 100 commands per bot. Prefix commands don't have such thing. Slash commands don't have hidden commands; all commands are public. Slash commands' parent can't be invoked ( queue cannot be invoked if a subcommand queue clear is registered). This is not the case for prefix commands. With these pros and cons, sometimes some commands are exclusive to slash or prefix only. This will be mentioned in each command entry. Besides slash commands, Discord also have user commands and message commands . However, the bot rarely uses them for important features, so you can safely ignore them for the most part. By default, I'll recommend you to use the Prefix version of the command. However, in some cases, Slash command might performs the job easier. I'll sometimes put my preferences if that's the case. Cooldown Some commands have cooldown. This is to ensure the bot has time to do things first before it is invoked again. This is quite common for commands that deal with heavy stuffs such as music or communicating with servers. Some cooldown are simply to avoid spamming potential. Cooldown is applied to a certain target. There are 4 targets a cooldown can apply: A user. This means the user can't execute the command within an interval. A channel. This means the command can't be executed in the same channel within an interval. A guild. This means the command can't be executed in the same guild within an interval. Everywhere. This means the command can't be executed by anyone within an interval. Technical: Most cooldown are soft; they can be reset by resetting the bot or use some commands to reset. Some cooldown are hard-coded; they're saved within the database and you might need to edit the table (and the cache) to remove it. Parameters Many commands require parameters to be passed in. Although the help command already provide a good amount of info, it is still limited because it is auto-generated. Note that these are mostly applied to Prefix Commands; Slash Commands is super user-friendly so you might not even need to care about most of these stuffs. Take the command signature foo <bar> [bar2 = bla] [bar3 = 1] [*baz = None] All parameters are separated by space. Which means if you invoke foo 1 2 3 , it'll store as bar = 1, bar2 = 2, bar3 = 3 and not bar = 1 2 3 . <parameter> means this parameter is required. That means bar is a required parameter. [parameter] or [parameter = None] means this parameter is optional. That means bar2 , bar3 , and baz are optional parameters. parameter = sth means the default value of a parameter is set to whatever sth is. This usually appears in optional parameters. *parameter means it'll consume all the remaining text. This means if you invoke foo 1 2 3 4 5 6 , it'll store as bar = 1, bar2 = 2, bar3 = 3, baz = 4 5 6 . Slash Commands have none of the above problem since parameters are separated by Tab, and they also have indication which parameters are required. Parameter Type There are several types the bot will work with. The most common one is plain text, followed by numbers. These are pretty straightforward. The less obvious types are such as a Discord User or a Discord Guild. There are several ways to pass in such types, which will be shown in this table. Type Pass into Prefix Commands Pass into Slash Commands Plain text Literally any text you type. Literally any text you type. Numbers Literally any numbers you type. Literally any numbers you type. Discord User/Member/Channel/Role ID > Mention > Name > Nickname Choose from the option (you might need to partially type the name for it to show up). Discord Guild ID ID Time 1d10h10m10s or hh:mm:ss 1d10h10m10s or hh:mm:ss","title":"Home"},{"location":"#welcome-to-michaelbot-documentation","text":"Welcome to MichaelBot's documentation. This documents all the bot's commands along with its features. For general purposes, please refers to the Commands heading. For those who are interested in some of the more secret stuffs, feel free to look at the bot source code. Below are some of the topics that are might not obvious from a user perspective.","title":"Welcome to MichaelBot Documentation"},{"location":"#prefix-vs-slash","text":"MichaelBot has 2 main types of command: prefix command and slash command. Prefix command is the OG \"command system\" that's been widely implemented for pretty much every single bot. Slash command is the official command system in Discord that's been implemented fairly recently. MichaelBot tries to balance these 2, but there are some pros and cons to them: Slash > Prefix: Is officially supported by Discord and is super newbie-friendly. Can use Tab to autocomplete. This makes it somewhat unnecessary for the user to remember the arguments. This is excellent when the user need to input some sort of choice into the command. Arguments are generally easier to deal with since Discord do all the necessary text parsing. Prefix commands don't work without verifying the bot after reaching 100 servers. This is technically not the case for slash commands. Prefix > Slash: Is familiar to a lot of people. Can alias commands. This allows users to smash commands super fast. Slash commands have a hard limit of 100 commands per bot. Prefix commands don't have such thing. Slash commands don't have hidden commands; all commands are public. Slash commands' parent can't be invoked ( queue cannot be invoked if a subcommand queue clear is registered). This is not the case for prefix commands. With these pros and cons, sometimes some commands are exclusive to slash or prefix only. This will be mentioned in each command entry. Besides slash commands, Discord also have user commands and message commands . However, the bot rarely uses them for important features, so you can safely ignore them for the most part. By default, I'll recommend you to use the Prefix version of the command. However, in some cases, Slash command might performs the job easier. I'll sometimes put my preferences if that's the case.","title":"Prefix vs Slash"},{"location":"#cooldown","text":"Some commands have cooldown. This is to ensure the bot has time to do things first before it is invoked again. This is quite common for commands that deal with heavy stuffs such as music or communicating with servers. Some cooldown are simply to avoid spamming potential. Cooldown is applied to a certain target. There are 4 targets a cooldown can apply: A user. This means the user can't execute the command within an interval. A channel. This means the command can't be executed in the same channel within an interval. A guild. This means the command can't be executed in the same guild within an interval. Everywhere. This means the command can't be executed by anyone within an interval. Technical: Most cooldown are soft; they can be reset by resetting the bot or use some commands to reset. Some cooldown are hard-coded; they're saved within the database and you might need to edit the table (and the cache) to remove it.","title":"Cooldown"},{"location":"#parameters","text":"Many commands require parameters to be passed in. Although the help command already provide a good amount of info, it is still limited because it is auto-generated. Note that these are mostly applied to Prefix Commands; Slash Commands is super user-friendly so you might not even need to care about most of these stuffs. Take the command signature foo <bar> [bar2 = bla] [bar3 = 1] [*baz = None] All parameters are separated by space. Which means if you invoke foo 1 2 3 , it'll store as bar = 1, bar2 = 2, bar3 = 3 and not bar = 1 2 3 . <parameter> means this parameter is required. That means bar is a required parameter. [parameter] or [parameter = None] means this parameter is optional. That means bar2 , bar3 , and baz are optional parameters. parameter = sth means the default value of a parameter is set to whatever sth is. This usually appears in optional parameters. *parameter means it'll consume all the remaining text. This means if you invoke foo 1 2 3 4 5 6 , it'll store as bar = 1, bar2 = 2, bar3 = 3, baz = 4 5 6 . Slash Commands have none of the above problem since parameters are separated by Tab, and they also have indication which parameters are required.","title":"Parameters"},{"location":"#parameter-type","text":"There are several types the bot will work with. The most common one is plain text, followed by numbers. These are pretty straightforward. The less obvious types are such as a Discord User or a Discord Guild. There are several ways to pass in such types, which will be shown in this table. Type Pass into Prefix Commands Pass into Slash Commands Plain text Literally any text you type. Literally any text you type. Numbers Literally any numbers you type. Literally any numbers you type. Discord User/Member/Channel/Role ID > Mention > Name > Nickname Choose from the option (you might need to partially type the name for it to show up). Discord Guild ID ID Time 1d10h10m10s or hh:mm:ss 1d10h10m10s or hh:mm:ss","title":"Parameter Type"},{"location":"INSTALLATION/","text":"Installation All instructions are geared towards Ubuntu (Kubuntu specifically) because that's what I use. Instructions for Windows is available, but be aware I don't test them often. Prerequisites Requires: Python 3.10+ (ideally latest), Git, pip , virtualenv / python3-venv under Python. Optional: Lavalink (more information below), Docker (for Lavalink), PostgreSQL (more information below). About Lavalink Lavalink is optional for the bot. If you don't plan to use the music functionality, you can simply edit main.py the EXTENSION variable to exclude categories.music . Then you can completely ignore this section and move on. Otherwise, you'll need to finish setting up Lavalink and get it running. There are 2 options to host Lavalink: you can host it directly using the .jar file or use Docker. I personally switched to Docker recently so I won't tell which one you should go. In either cases, you'll need a file application.yml to configure the server. An example is provided in ./lib/Lavalink . You'll also need Java 13+, which can be downloaded here or somewhere else (there are a billion places to download a billion java versions I'm not gonna even bother). Running Lavalink (.jar) Download Lavalink.jar , or use the one currently in ./lib/Lavalink/ . Run java -jar <path to Lavalink.jar> . Lavalink server should start running now. By default, it'll run on localhost:2333 unless you configure it in application.yml . Running Lavalink (Docker) This is not tested on Windows. Download Docker. Here is the guide for Ubuntu. Run docker pull fredboat/lavalink:master . This will pull the stable image. Run docker run --name <name> -p <port>:<port> -d -v <path-to-application.yml>:/opt/Lavalink/application.yml fredboat/lavalink:master , where <name> is the name of the process, <port> is the port the server is on, and <path-to-application.yml> is the absolute path to the config file. To stop the process, run docker stop <name> . About PostgreSQL PostgreSQL is optional for the bot, but is strongly recommended. Without a database, some features will be missing, such as prefix config, blacklisting, logging, etc. In addition to that, although the code can handle no database scenario on its own, it is not well-tested for such cases, so there might be some edge cases here and there. This is a pretty fine guide to install PostgreSQL on Ubuntu: https://linuxhint.com/postgresql_installation_guide_ubuntu_20-04/ After installing Postgres, create a database and check the connection info. You'll need this later. Build Instructions The following instructions has been tested with bash and Powershell . You'll need to replace the python command mentioned below with whatever your system has ( python3 or python3.x for Linux, python for Windows). Clone the repository into the current folder. git clone https://github.com/MikeJollie2707/MichaelBot.git . Activate virtual environment and install libraries. # Linux python -m pip venv venv source ./venv/bin/activate python -m pip install -r requirement.txt # Windows # From my experience, / still works, but if it doesn't, use \\ python -m pip venv venv ./venv/Scripts/Activate.ps1 # This is important; uvloop is not available on Windows. python -m pip install -r win_requirement.txt Configure the bot. Inside ./setup , create a .json file. I'll call it secret.json . // secret.json { \"token\": \"Bot token here\", \"host\": \"localhost\", \"port\": 5432, \"database\": \"database name\", \"user\": \"user name\", \"password\": \"password\", \"weather_api_key\": \"api key\" } If you don't have a database and/or weather_api_key , leave them as dummy values ( \"\" and 0 ). Within ./setup , there's also another file called config.json . The file has the following structure: // config.json { \"BotIndex\": { \"version\": \"Required\", \"description\": \"Required\", \"prefix\": \"Required\", \"launch_options\": \"Optional\", \"default_guilds\": [123456], \"secret\": \"secret.json\" } } BotIndex : the index you'll refer to the bot when you launch it from the terminal. Usually the bot name without space. version : the bot version. Just fake something up like 69.69beta if you don't really care about this. description : the bot's about me. Discord doesn't have a way to retrieve this so this is required for now. prefix : the bot's default prefix. launch_options : an optional string to pass into the bot when it launches. This mostly affects terminal logging. Acceptable options are: -d or --debug : Launch the bot in debug mode. This will set the log level to DEBUG but more importantly, it'll apply slash commands to default_guilds immediately (no need to wait at most 1 hour). If this is passed, default_guilds must also be non-empty. -q or --quiet : Launch the bot in quiet mode. This will disable terminal logging, but any uncaught exceptions will still spawn in stderr . default_guilds : a list of guilds' ids to apply slash commands immediately. This is required if the bot is launched in debug mode. secret : the file name that contains your bot's secret like token. You can view my bot config as an example. (Optional) If you have a database, you'll need to set up the tables beforehand. You only need to do this once. python dbsetup.py BotIndex Run the bot. python -OO main.py BotIndex What's next? For personal convenience, I also have a template script to run the bot in different modes. You can check it out at run.sh (Kubuntu) or run.ps1 (Windows). It'll only run the bot. You'll need to run Lavalink and PostgreSQL on your own.","title":"Installation"},{"location":"INSTALLATION/#installation","text":"All instructions are geared towards Ubuntu (Kubuntu specifically) because that's what I use. Instructions for Windows is available, but be aware I don't test them often.","title":"Installation"},{"location":"INSTALLATION/#prerequisites","text":"Requires: Python 3.10+ (ideally latest), Git, pip , virtualenv / python3-venv under Python. Optional: Lavalink (more information below), Docker (for Lavalink), PostgreSQL (more information below).","title":"Prerequisites"},{"location":"INSTALLATION/#about-lavalink","text":"Lavalink is optional for the bot. If you don't plan to use the music functionality, you can simply edit main.py the EXTENSION variable to exclude categories.music . Then you can completely ignore this section and move on. Otherwise, you'll need to finish setting up Lavalink and get it running. There are 2 options to host Lavalink: you can host it directly using the .jar file or use Docker. I personally switched to Docker recently so I won't tell which one you should go. In either cases, you'll need a file application.yml to configure the server. An example is provided in ./lib/Lavalink . You'll also need Java 13+, which can be downloaded here or somewhere else (there are a billion places to download a billion java versions I'm not gonna even bother).","title":"About Lavalink"},{"location":"INSTALLATION/#running-lavalink-jar","text":"Download Lavalink.jar , or use the one currently in ./lib/Lavalink/ . Run java -jar <path to Lavalink.jar> . Lavalink server should start running now. By default, it'll run on localhost:2333 unless you configure it in application.yml .","title":"Running Lavalink (.jar)"},{"location":"INSTALLATION/#running-lavalink-docker","text":"This is not tested on Windows. Download Docker. Here is the guide for Ubuntu. Run docker pull fredboat/lavalink:master . This will pull the stable image. Run docker run --name <name> -p <port>:<port> -d -v <path-to-application.yml>:/opt/Lavalink/application.yml fredboat/lavalink:master , where <name> is the name of the process, <port> is the port the server is on, and <path-to-application.yml> is the absolute path to the config file. To stop the process, run docker stop <name> .","title":"Running Lavalink (Docker)"},{"location":"INSTALLATION/#about-postgresql","text":"PostgreSQL is optional for the bot, but is strongly recommended. Without a database, some features will be missing, such as prefix config, blacklisting, logging, etc. In addition to that, although the code can handle no database scenario on its own, it is not well-tested for such cases, so there might be some edge cases here and there. This is a pretty fine guide to install PostgreSQL on Ubuntu: https://linuxhint.com/postgresql_installation_guide_ubuntu_20-04/ After installing Postgres, create a database and check the connection info. You'll need this later.","title":"About PostgreSQL"},{"location":"INSTALLATION/#build-instructions","text":"The following instructions has been tested with bash and Powershell . You'll need to replace the python command mentioned below with whatever your system has ( python3 or python3.x for Linux, python for Windows). Clone the repository into the current folder. git clone https://github.com/MikeJollie2707/MichaelBot.git . Activate virtual environment and install libraries. # Linux python -m pip venv venv source ./venv/bin/activate python -m pip install -r requirement.txt # Windows # From my experience, / still works, but if it doesn't, use \\ python -m pip venv venv ./venv/Scripts/Activate.ps1 # This is important; uvloop is not available on Windows. python -m pip install -r win_requirement.txt Configure the bot. Inside ./setup , create a .json file. I'll call it secret.json . // secret.json { \"token\": \"Bot token here\", \"host\": \"localhost\", \"port\": 5432, \"database\": \"database name\", \"user\": \"user name\", \"password\": \"password\", \"weather_api_key\": \"api key\" } If you don't have a database and/or weather_api_key , leave them as dummy values ( \"\" and 0 ). Within ./setup , there's also another file called config.json . The file has the following structure: // config.json { \"BotIndex\": { \"version\": \"Required\", \"description\": \"Required\", \"prefix\": \"Required\", \"launch_options\": \"Optional\", \"default_guilds\": [123456], \"secret\": \"secret.json\" } } BotIndex : the index you'll refer to the bot when you launch it from the terminal. Usually the bot name without space. version : the bot version. Just fake something up like 69.69beta if you don't really care about this. description : the bot's about me. Discord doesn't have a way to retrieve this so this is required for now. prefix : the bot's default prefix. launch_options : an optional string to pass into the bot when it launches. This mostly affects terminal logging. Acceptable options are: -d or --debug : Launch the bot in debug mode. This will set the log level to DEBUG but more importantly, it'll apply slash commands to default_guilds immediately (no need to wait at most 1 hour). If this is passed, default_guilds must also be non-empty. -q or --quiet : Launch the bot in quiet mode. This will disable terminal logging, but any uncaught exceptions will still spawn in stderr . default_guilds : a list of guilds' ids to apply slash commands immediately. This is required if the bot is launched in debug mode. secret : the file name that contains your bot's secret like token. You can view my bot config as an example. (Optional) If you have a database, you'll need to set up the tables beforehand. You only need to do this once. python dbsetup.py BotIndex Run the bot. python -OO main.py BotIndex","title":"Build Instructions"},{"location":"INSTALLATION/#whats-next","text":"For personal convenience, I also have a template script to run the bot in different modes. You can check it out at run.sh (Kubuntu) or run.ps1 (Windows). It'll only run the bot. You'll need to run Lavalink and PostgreSQL on your own.","title":"What's next?"},{"location":"econ/","text":"Economy System MichaelBot has its own economy system that's heavily inspired by Minecraft. This document is written to serve a brief intro to this sytem, as it can be confusing where to start. Guide Currently, the only valid way to get started is to use the command daily . This will gives you a pre-determined amount of money (or emerald) and some woods. Next, you'll need to craft some items to move on. Like Minecraft, you usually first craft some sticks, then a wooden pickaxe to mine stone, then craft stone tools, etc. The process follows somewhat similarly using the command craft . It's recommended to use the slash command version, since it gives a list of items you can craft as you type. /craft Stick /craft Wood Pickaxe Note that for prefix commands, some items' name need to be enclosed inside \"\" like \"Wood Pickaxe\" . This is not a problem for slash commands. A pickaxe (in this case, the Wood Pickaxe ) is considered to be an equipment, a subset of items that can be equipped and used. Other equipment can include a sword, axe, and potion (some of these are mere concept and not yet added). To use certain equipments, you'll need to equip them using equip . /equip Wood Pickaxe Now that you have your wooden pickaxe equipped, time to go mining. /mine These are considered to be action commands . These need certain equipments to be equipped before performing the action. In this case, mine requires a pickaxe equipped before using it, otherwise, it'll send an error. After the mining, you'll have some stone. Use them to craft more tools like in Minecraft. At this point, the progression is similar to Minecraft, so you should be able to progress. If not, feel free to explore what the system can do.","title":"Economy Guide"},{"location":"econ/#economy-system","text":"MichaelBot has its own economy system that's heavily inspired by Minecraft. This document is written to serve a brief intro to this sytem, as it can be confusing where to start.","title":"Economy System"},{"location":"econ/#guide","text":"Currently, the only valid way to get started is to use the command daily . This will gives you a pre-determined amount of money (or emerald) and some woods. Next, you'll need to craft some items to move on. Like Minecraft, you usually first craft some sticks, then a wooden pickaxe to mine stone, then craft stone tools, etc. The process follows somewhat similarly using the command craft . It's recommended to use the slash command version, since it gives a list of items you can craft as you type. /craft Stick /craft Wood Pickaxe Note that for prefix commands, some items' name need to be enclosed inside \"\" like \"Wood Pickaxe\" . This is not a problem for slash commands. A pickaxe (in this case, the Wood Pickaxe ) is considered to be an equipment, a subset of items that can be equipped and used. Other equipment can include a sword, axe, and potion (some of these are mere concept and not yet added). To use certain equipments, you'll need to equip them using equip . /equip Wood Pickaxe Now that you have your wooden pickaxe equipped, time to go mining. /mine These are considered to be action commands . These need certain equipments to be equipped before performing the action. In this case, mine requires a pickaxe equipped before using it, otherwise, it'll send an error. After the mining, you'll have some stone. Use them to craft more tools like in Minecraft. At this point, the progression is similar to Minecraft, so you should be able to progress. If not, feel free to explore what the system can do.","title":"Guide"},{"location":"dev/econ/","text":"econ/loot.py Define the loot tables for the economy system. RewardRNG Define the RNG to randomize. Attributes: Name Type Description rate float Define the drop rate of the associated item. Must be between 0 and 1. min_amount int Define the minimum amount of this item to drop if it happens to roll. This should be positive. max_amount int Define the maximum amount of this item to drop if it happens to roll. This should be positive. amount_layout tuple [ int ], optional Define the rng distribution between min_amount and max_amount . This should satisfy len(amount_layout) == (max_amount - min_amount + 1) and sum(amount_layout) == 100 Source code in categories\\econ\\loot.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class RewardRNG : '''Define the RNG to randomize. Attributes ---------- rate : float Define the drop rate of the associated item. Must be between 0 and 1. min_amount : int Define the minimum amount of this item to drop if it happens to roll. This should be positive. max_amount : int Define the maximum amount of this item to drop if it happens to roll. This should be positive. amount_layout : tuple[int], optional Define the rng distribution between `min_amount` and `max_amount`. This should satisfy `len(amount_layout) == (max_amount - min_amount + 1) and sum(amount_layout) == 100` ''' __slots__ = ( \"rate\" , \"min_amount\" , \"max_amount\" , \"amount_layout\" ) def __init__ ( self , rate : float , min_amount : int , max_amount : int , * , amount_layout : tuple [ int ] = None ): if rate < 0 or rate > 1 : raise ValueError ( \"'rate' must be in [0, 1].\" ) if min_amount > max_amount : raise ValueError ( \"'min_amount' must be smaller than or equal to 'max_amount'.\" ) if amount_layout : if len ( amount_layout ) != ( max_amount - min_amount + 1 ): raise ValueError ( \"'amount_layout' must have the same amount of items as (max_amount - min_amount + 1).\" ) if sum ( amount_layout ) != 100 : print ( sum ( amount_layout )) raise ValueError ( \"'amount_layout' must sum up to 100.\" ) self . rate = rate self . min_amount = min_amount self . max_amount = max_amount self . amount_layout = amount_layout def roll ( self ) -> int : '''Roll the RNG based on the provided information. Returns ------- int The number after randomizing. ''' if self . rate < 1 : r = random . random () if r > self . rate : return 0 if self . min_amount == self . max_amount : return self . min_amount if not self . amount_layout : return random . choice ( range ( self . min_amount , self . max_amount + 1 )) r = random . random () rate = 0 for index , amount_rate in enumerate ( self . amount_layout ): rate += amount_rate / 100.0 if r <= rate : return min ( self . min_amount + index , self . max_amount ) return self . max_amount roll roll () -> int Roll the RNG based on the provided information. Returns: Type Description int The number after randomizing. Source code in categories\\econ\\loot.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def roll ( self ) -> int : '''Roll the RNG based on the provided information. Returns ------- int The number after randomizing. ''' if self . rate < 1 : r = random . random () if r > self . rate : return 0 if self . min_amount == self . max_amount : return self . min_amount if not self . amount_layout : return random . choice ( range ( self . min_amount , self . max_amount + 1 )) r = random . random () rate = 0 for index , amount_rate in enumerate ( self . amount_layout ): rate += amount_rate / 100.0 if r <= rate : return min ( self . min_amount + index , self . max_amount ) return self . max_amount get_daily_loot get_daily_loot ( streak : int ) -> dict [ str , int ] Return the daily loot based on the current streak. Parameters: Name Type Description Default streak int The current streak. required Returns: Type Description dict [ str , int ] A dict denoting the loot table. Source code in categories\\econ\\loot.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 def get_daily_loot ( streak : int ) -> dict [ str , int ]: '''Return the daily loot based on the current streak. Parameters ---------- streak : int The current streak. Returns ------- dict[str, int] A `dict` denoting the loot table. ''' if streak <= 1 : return { \"money\" : 50 , \"wood\" : 5 } if streak <= 6 : return { \"money\" : 10 , \"wood\" : random . randint ( 10 , 15 ) } if streak <= 13 : return { \"money\" : 10 , \"bonus\" : streak , \"wood\" : random . randint ( 10 , 15 ) } if streak <= 27 : return { \"money\" : 20 , \"bonus\" : 5 * ( streak - 12 ), \"wood\" : random . randint ( 11 , 16 ) } if streak <= 60 : return { \"money\" : 100 , \"bonus\" : 2 * ( streak - 20 ), \"wood\" : random . randint ( 95 , 105 ) } return { \"money\" : 200 , \"bonus\" : 5 * ( streak - 60 ), \"wood\" : random . randint ( 190 , 210 ) } get_activity_loot get_activity_loot ( equipment_id : str , world : str ) -> t . Optional [ dict [ str , int ]] Return the loot generated by an equipment in a world. Parameters: Name Type Description Default equipment_id str The equipment's id. The function won't check for valid id. required world str The world's name. The function won't check for valid world. required Returns: Type Description t . Optional [ dict [ str , int ]] A dict denoting the loot table, or None if there's no matching loot table. Source code in categories\\econ\\loot.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 def get_activity_loot ( equipment_id : str , world : str ) -> t . Optional [ dict [ str , int ]]: '''Return the loot generated by an equipment in a world. Parameters ---------- equipment_id : str The equipment's id. The function won't check for valid id. world : str The world's name. The function won't check for valid world. Returns ------- t.Optional[dict[str, int]] A `dict` denoting the loot table, or `None` if there's no matching loot table. ''' reward : dict [ str , int ] = {} world_loot = __ACTIVITY_LOOT . get ( world ) if not world_loot : return None equipment_loot = world_loot . get ( equipment_id ) if not equipment_loot : return None for item_id , rng in equipment_loot . items (): reward [ item_id ] = rng . roll () return reward get_craft_recipe get_craft_recipe ( item_id : str ) -> t . Optional [ dict [ str , int ]] Return the crafting recipe for an item if existed. Notes The returning dict has a special key result , which denote how many items will be crafted out of the recipe. Parameters: Name Type Description Default item_id str The item's id. required Returns: Type Description t . Optional [ dict [ str , int ]] A dict denoting the crafting recipe, or None if no crafting recipe is found. Source code in categories\\econ\\loot.py 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 def get_craft_recipe ( item_id : str ) -> t . Optional [ dict [ str , int ]]: '''Return the crafting recipe for an item if existed. Notes ----- The returning `dict` has a special key `result`, which denote how many items will be crafted out of the recipe. Parameters ---------- item_id : str The item's id. Returns ------- t.Optional[dict[str, int]] A `dict` denoting the crafting recipe, or `None` if no crafting recipe is found. ''' return __CRAFT_RECIPE . get ( item_id ) __driver_code __driver_code () DO NOT CALL THIS FUNCTION. This is a function only because all variables used will be public when exporting (thank you Python for its scoping \"rule\"). Source code in categories\\econ\\loot.py 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def __driver_code (): '''DO NOT CALL THIS FUNCTION. This is a function only because all variables used will be public when exporting (thank you Python for its scoping \"rule\"). ''' SIMULATION_TIME = 10 ** 6 total : int = 0 rate_tracker : dict [ str , int ] = {} for i in range ( 0 , SIMULATION_TIME ): loot_rate = get_activity_loot ( \"diamond_pickaxe\" , \"overworld\" ) for reward in loot_rate : if reward not in rate_tracker : rate_tracker [ reward ] = loot_rate [ reward ] else : rate_tracker [ reward ] += loot_rate [ reward ] total += loot_rate [ reward ] print ( f \"Sim { SIMULATION_TIME : , } times, total amount: { total : , } \" ) for item , amount in rate_tracker . items (): print ( f \"- { item } : { amount : , } / { total : , } ( { float ( amount ) / total * 100 : .5f } %)\" ) econ/trader.py generate_trades generate_trades ( item_cache : models . ItemCache , next_reset : dt . datetime , amount : int = 6 ) -> list [ psql . ActiveTrade ] Generate trades based on pre-determined rules. Parameters: Name Type Description Default item_cache models . ItemCache The bot's item cache. This is to get item's information. required next_reset dt . datetime When these trades will reset. required amount int , optional How many trade to generate, by default 6 6 Returns: Type Description list [ psql . ActiveTrade ] A list of trades to be added. Source code in categories\\econ\\trader.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def generate_trades ( item_cache : models . ItemCache , next_reset : dt . datetime , amount : int = 6 ) -> list [ psql . ActiveTrade ]: '''Generate trades based on pre-determined rules. Parameters ---------- item_cache : models.ItemCache The bot's item cache. This is to get item's information. next_reset : dt.datetime When these trades will reset. amount : int, optional How many trade to generate, by default 6 Returns ------- list[psql.ActiveTrade] A list of trades to be added. ''' trades = [] # Avoid duplicate trades. traded_item = [ \"money\" ] for i in range ( 1 , amount + 1 ): trade = psql . ActiveTrade ( i , \"trade\" , \"\" , 0 , \"\" , 0 , next_reset ) max_value_limit = random . randint ( 1 , 200 ) # item -> money if i == 1 : # Limit this, otherwise it'd be a free money maker strat. max_value_limit = random . randint ( 1 , 50 ) trade . hard_limit = 5 trade . item_dest = \"money\" trade . item_src = \"money\" while trade . item_src in traded_item : trade . item_src = random . choice ( __TRADE_WHITELIST ) traded_item . append ( trade . item_src ) # Get the item's value. item = item_cache [ trade . item_src ] src_price = item . sell_price # Force the current max to be at least the item's price so we can avoid amount = 0. max_value_limit = max ( max_value_limit , src_price ) # Get the max amount of item to not exceed the trade's current max value. src_max_amount = max_value_limit // src_price trade . amount_src = random . randint ( 1 , src_max_amount ) # Overvalue the item. trade . amount_dest = math . ceil ( trade . amount_src * src_price * ( 1 + random . random ())) # item -> item elif i == amount : # Select items so they don't go against each other. trade . item_src = \"money\" while trade . item_src in traded_item : trade . item_src = random . choice ( __TRADE_WHITELIST ) traded_item . append ( trade . item_src ) trade . item_dest = \"money\" while trade . item_dest in traded_item : trade . item_dest = random . choice ( __TRADE_WHITELIST ) traded_item . append ( trade . item_dest ) # Get the items' values. item_src = item_cache [ trade . item_src ] item_dest = item_cache [ trade . item_dest ] src_price = item_src . sell_price dest_price = item_dest . buy_price if not item_dest . buy_price : dest_price = item_dest . sell_price # Lower the limit if these are tools, otherwise you'll end up with super trash trades. if psql . Equipment . is_equipment ( item_src . id ) or psql . Equipment . is_equipment ( item_dest . id ): max_value_limit = 50 # Force the current max to be at least the item's price so we can avoid amount = 0. max_value_limit = max ( src_price , dest_price , max_value_limit ) # At this point we can guarantee the trade will have at least 1 on both side, we can safely get amount. src_max_amount = max_value_limit // src_price dest_max_amount = max_value_limit // dest_price if src_price > dest_price : trade . amount_src = random . randint ( 1 , src_max_amount ) trade . amount_dest = math . ceil (( trade . amount_src * src_price // dest_price ) * random . random ()) else : trade . amount_dest = random . randint ( 1 , dest_max_amount ) trade . amount_src = math . ceil (( trade . amount_dest * dest_price // src_price ) * random . random ()) # money -> item else : trade . item_src = \"money\" trade . item_dest = \"money\" while trade . item_dest in traded_item : trade . item_dest = random . choice ( __TRADE_WHITELIST ) traded_item . append ( trade . item_dest ) # Get the item's value. item = item_cache [ trade . item_dest ] dest_price = item . buy_price if not item . buy_price : dest_price = item . sell_price # Lower the limit if these are tools, otherwise you'll end up with super trash trades. if psql . Equipment . is_equipment ( item . id ): max_value_limit = 50 # Force the current max to be at least the item's price so we can avoid amount = 0. max_value_limit = max ( max_value_limit , dest_price ) # Get the max amount of item to not exceed the trade's current max value. dest_max_amount = max_value_limit // dest_price trade . amount_dest = random . randint ( 1 , dest_max_amount ) # Devalue the item. trade . amount_src = math . ceil ( trade . amount_dest * dest_price * ( 1 + random . random ())) trades . append ( trade ) return trades generate_barters generate_barters ( item_cache : models . ItemCache , next_reset : dt . datetime , amount : int = 9 ) -> list [ psql . ActiveTrade ] Generate barters based on pre-determined rules. Parameters: Name Type Description Default item_cache models . ItemCache The bot's item cache. This is to get item's information. required next_reset dt . datetime When these barters will reset. required amount int , optional How many barter to generate, by default 6 9 Returns: Type Description list [ psql . ActiveTrade ] A list of barters to be added. Source code in categories\\econ\\trader.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def generate_barters ( item_cache : models . ItemCache , next_reset : dt . datetime , amount : int = 9 ) -> list [ psql . ActiveTrade ]: '''Generate barters based on pre-determined rules. Parameters ---------- item_cache : models.ItemCache The bot's item cache. This is to get item's information. next_reset : dt.datetime When these barters will reset. amount : int, optional How many barter to generate, by default 6 Returns ------- list[psql.ActiveTrade] A list of barters to be added. ''' barters = [] # Avoid duplicate barters. bartered_items = [ \"gold\" ] for i in range ( 1 , amount + 1 ): barter = psql . ActiveTrade ( i , \"barter\" , \"\" , 0 , \"\" , 0 , next_reset , 20 ) max_value_limit = random . randint ( 1 , 500 ) if i == 1 : max_value_limit = random . randint ( 1 , 25 ) barter . hard_limit = 5 barter . item_dest = \"gold\" barter . item_src = \"gold\" while barter . item_src in bartered_items : barter . item_src = random . choice ( __BARTER_WHITELIST ) bartered_items . append ( barter . item_src ) else : barter . item_src = \"gold\" barter . item_dest = \"gold\" while barter . item_dest in bartered_items : barter . item_dest = random . choice ( __BARTER_WHITELIST ) bartered_items . append ( barter . item_dest ) # Get the items' values. item_src = item_cache [ barter . item_src ] item_dest = item_cache [ barter . item_dest ] src_price = item_src . sell_price dest_price = item_dest . buy_price if not item_dest . buy_price : dest_price = item_dest . sell_price # Force the current max to be at least the item's price so we can avoid amount = 0. max_value_limit = max ( src_price , dest_price , max_value_limit ) # At this point we can guarantee the trade will have at least 1 on both side, we can safely get amount. src_max_amount = max_value_limit // src_price dest_max_amount = max_value_limit // dest_price if src_price > dest_price : barter . amount_src = random . randint ( 1 , src_max_amount ) barter . amount_dest = math . ceil (( barter . amount_src * src_price // dest_price ) * random . random ()) else : barter . amount_dest = random . randint ( 1 , dest_max_amount ) barter . amount_src = math . ceil (( barter . amount_dest * dest_price // src_price ) * random . random ()) barters . append ( barter ) return barters","title":"econ"},{"location":"dev/econ/#econlootpy","text":"Define the loot tables for the economy system.","title":"econ/loot.py"},{"location":"dev/econ/#categories.econ.loot.RewardRNG","text":"Define the RNG to randomize. Attributes: Name Type Description rate float Define the drop rate of the associated item. Must be between 0 and 1. min_amount int Define the minimum amount of this item to drop if it happens to roll. This should be positive. max_amount int Define the maximum amount of this item to drop if it happens to roll. This should be positive. amount_layout tuple [ int ], optional Define the rng distribution between min_amount and max_amount . This should satisfy len(amount_layout) == (max_amount - min_amount + 1) and sum(amount_layout) == 100 Source code in categories\\econ\\loot.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class RewardRNG : '''Define the RNG to randomize. Attributes ---------- rate : float Define the drop rate of the associated item. Must be between 0 and 1. min_amount : int Define the minimum amount of this item to drop if it happens to roll. This should be positive. max_amount : int Define the maximum amount of this item to drop if it happens to roll. This should be positive. amount_layout : tuple[int], optional Define the rng distribution between `min_amount` and `max_amount`. This should satisfy `len(amount_layout) == (max_amount - min_amount + 1) and sum(amount_layout) == 100` ''' __slots__ = ( \"rate\" , \"min_amount\" , \"max_amount\" , \"amount_layout\" ) def __init__ ( self , rate : float , min_amount : int , max_amount : int , * , amount_layout : tuple [ int ] = None ): if rate < 0 or rate > 1 : raise ValueError ( \"'rate' must be in [0, 1].\" ) if min_amount > max_amount : raise ValueError ( \"'min_amount' must be smaller than or equal to 'max_amount'.\" ) if amount_layout : if len ( amount_layout ) != ( max_amount - min_amount + 1 ): raise ValueError ( \"'amount_layout' must have the same amount of items as (max_amount - min_amount + 1).\" ) if sum ( amount_layout ) != 100 : print ( sum ( amount_layout )) raise ValueError ( \"'amount_layout' must sum up to 100.\" ) self . rate = rate self . min_amount = min_amount self . max_amount = max_amount self . amount_layout = amount_layout def roll ( self ) -> int : '''Roll the RNG based on the provided information. Returns ------- int The number after randomizing. ''' if self . rate < 1 : r = random . random () if r > self . rate : return 0 if self . min_amount == self . max_amount : return self . min_amount if not self . amount_layout : return random . choice ( range ( self . min_amount , self . max_amount + 1 )) r = random . random () rate = 0 for index , amount_rate in enumerate ( self . amount_layout ): rate += amount_rate / 100.0 if r <= rate : return min ( self . min_amount + index , self . max_amount ) return self . max_amount","title":"RewardRNG"},{"location":"dev/econ/#categories.econ.loot.RewardRNG.roll","text":"roll () -> int Roll the RNG based on the provided information. Returns: Type Description int The number after randomizing. Source code in categories\\econ\\loot.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def roll ( self ) -> int : '''Roll the RNG based on the provided information. Returns ------- int The number after randomizing. ''' if self . rate < 1 : r = random . random () if r > self . rate : return 0 if self . min_amount == self . max_amount : return self . min_amount if not self . amount_layout : return random . choice ( range ( self . min_amount , self . max_amount + 1 )) r = random . random () rate = 0 for index , amount_rate in enumerate ( self . amount_layout ): rate += amount_rate / 100.0 if r <= rate : return min ( self . min_amount + index , self . max_amount ) return self . max_amount","title":"roll()"},{"location":"dev/econ/#categories.econ.loot.get_daily_loot","text":"get_daily_loot ( streak : int ) -> dict [ str , int ] Return the daily loot based on the current streak. Parameters: Name Type Description Default streak int The current streak. required Returns: Type Description dict [ str , int ] A dict denoting the loot table. Source code in categories\\econ\\loot.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 def get_daily_loot ( streak : int ) -> dict [ str , int ]: '''Return the daily loot based on the current streak. Parameters ---------- streak : int The current streak. Returns ------- dict[str, int] A `dict` denoting the loot table. ''' if streak <= 1 : return { \"money\" : 50 , \"wood\" : 5 } if streak <= 6 : return { \"money\" : 10 , \"wood\" : random . randint ( 10 , 15 ) } if streak <= 13 : return { \"money\" : 10 , \"bonus\" : streak , \"wood\" : random . randint ( 10 , 15 ) } if streak <= 27 : return { \"money\" : 20 , \"bonus\" : 5 * ( streak - 12 ), \"wood\" : random . randint ( 11 , 16 ) } if streak <= 60 : return { \"money\" : 100 , \"bonus\" : 2 * ( streak - 20 ), \"wood\" : random . randint ( 95 , 105 ) } return { \"money\" : 200 , \"bonus\" : 5 * ( streak - 60 ), \"wood\" : random . randint ( 190 , 210 ) }","title":"get_daily_loot()"},{"location":"dev/econ/#categories.econ.loot.get_activity_loot","text":"get_activity_loot ( equipment_id : str , world : str ) -> t . Optional [ dict [ str , int ]] Return the loot generated by an equipment in a world. Parameters: Name Type Description Default equipment_id str The equipment's id. The function won't check for valid id. required world str The world's name. The function won't check for valid world. required Returns: Type Description t . Optional [ dict [ str , int ]] A dict denoting the loot table, or None if there's no matching loot table. Source code in categories\\econ\\loot.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 def get_activity_loot ( equipment_id : str , world : str ) -> t . Optional [ dict [ str , int ]]: '''Return the loot generated by an equipment in a world. Parameters ---------- equipment_id : str The equipment's id. The function won't check for valid id. world : str The world's name. The function won't check for valid world. Returns ------- t.Optional[dict[str, int]] A `dict` denoting the loot table, or `None` if there's no matching loot table. ''' reward : dict [ str , int ] = {} world_loot = __ACTIVITY_LOOT . get ( world ) if not world_loot : return None equipment_loot = world_loot . get ( equipment_id ) if not equipment_loot : return None for item_id , rng in equipment_loot . items (): reward [ item_id ] = rng . roll () return reward","title":"get_activity_loot()"},{"location":"dev/econ/#categories.econ.loot.get_craft_recipe","text":"get_craft_recipe ( item_id : str ) -> t . Optional [ dict [ str , int ]] Return the crafting recipe for an item if existed.","title":"get_craft_recipe()"},{"location":"dev/econ/#categories.econ.loot.get_craft_recipe--notes","text":"The returning dict has a special key result , which denote how many items will be crafted out of the recipe. Parameters: Name Type Description Default item_id str The item's id. required Returns: Type Description t . Optional [ dict [ str , int ]] A dict denoting the crafting recipe, or None if no crafting recipe is found. Source code in categories\\econ\\loot.py 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 def get_craft_recipe ( item_id : str ) -> t . Optional [ dict [ str , int ]]: '''Return the crafting recipe for an item if existed. Notes ----- The returning `dict` has a special key `result`, which denote how many items will be crafted out of the recipe. Parameters ---------- item_id : str The item's id. Returns ------- t.Optional[dict[str, int]] A `dict` denoting the crafting recipe, or `None` if no crafting recipe is found. ''' return __CRAFT_RECIPE . get ( item_id )","title":"Notes"},{"location":"dev/econ/#categories.econ.loot.__driver_code","text":"__driver_code () DO NOT CALL THIS FUNCTION. This is a function only because all variables used will be public when exporting (thank you Python for its scoping \"rule\"). Source code in categories\\econ\\loot.py 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def __driver_code (): '''DO NOT CALL THIS FUNCTION. This is a function only because all variables used will be public when exporting (thank you Python for its scoping \"rule\"). ''' SIMULATION_TIME = 10 ** 6 total : int = 0 rate_tracker : dict [ str , int ] = {} for i in range ( 0 , SIMULATION_TIME ): loot_rate = get_activity_loot ( \"diamond_pickaxe\" , \"overworld\" ) for reward in loot_rate : if reward not in rate_tracker : rate_tracker [ reward ] = loot_rate [ reward ] else : rate_tracker [ reward ] += loot_rate [ reward ] total += loot_rate [ reward ] print ( f \"Sim { SIMULATION_TIME : , } times, total amount: { total : , } \" ) for item , amount in rate_tracker . items (): print ( f \"- { item } : { amount : , } / { total : , } ( { float ( amount ) / total * 100 : .5f } %)\" )","title":"__driver_code()"},{"location":"dev/econ/#econtraderpy","text":"","title":"econ/trader.py"},{"location":"dev/econ/#categories.econ.trader.generate_trades","text":"generate_trades ( item_cache : models . ItemCache , next_reset : dt . datetime , amount : int = 6 ) -> list [ psql . ActiveTrade ] Generate trades based on pre-determined rules. Parameters: Name Type Description Default item_cache models . ItemCache The bot's item cache. This is to get item's information. required next_reset dt . datetime When these trades will reset. required amount int , optional How many trade to generate, by default 6 6 Returns: Type Description list [ psql . ActiveTrade ] A list of trades to be added. Source code in categories\\econ\\trader.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def generate_trades ( item_cache : models . ItemCache , next_reset : dt . datetime , amount : int = 6 ) -> list [ psql . ActiveTrade ]: '''Generate trades based on pre-determined rules. Parameters ---------- item_cache : models.ItemCache The bot's item cache. This is to get item's information. next_reset : dt.datetime When these trades will reset. amount : int, optional How many trade to generate, by default 6 Returns ------- list[psql.ActiveTrade] A list of trades to be added. ''' trades = [] # Avoid duplicate trades. traded_item = [ \"money\" ] for i in range ( 1 , amount + 1 ): trade = psql . ActiveTrade ( i , \"trade\" , \"\" , 0 , \"\" , 0 , next_reset ) max_value_limit = random . randint ( 1 , 200 ) # item -> money if i == 1 : # Limit this, otherwise it'd be a free money maker strat. max_value_limit = random . randint ( 1 , 50 ) trade . hard_limit = 5 trade . item_dest = \"money\" trade . item_src = \"money\" while trade . item_src in traded_item : trade . item_src = random . choice ( __TRADE_WHITELIST ) traded_item . append ( trade . item_src ) # Get the item's value. item = item_cache [ trade . item_src ] src_price = item . sell_price # Force the current max to be at least the item's price so we can avoid amount = 0. max_value_limit = max ( max_value_limit , src_price ) # Get the max amount of item to not exceed the trade's current max value. src_max_amount = max_value_limit // src_price trade . amount_src = random . randint ( 1 , src_max_amount ) # Overvalue the item. trade . amount_dest = math . ceil ( trade . amount_src * src_price * ( 1 + random . random ())) # item -> item elif i == amount : # Select items so they don't go against each other. trade . item_src = \"money\" while trade . item_src in traded_item : trade . item_src = random . choice ( __TRADE_WHITELIST ) traded_item . append ( trade . item_src ) trade . item_dest = \"money\" while trade . item_dest in traded_item : trade . item_dest = random . choice ( __TRADE_WHITELIST ) traded_item . append ( trade . item_dest ) # Get the items' values. item_src = item_cache [ trade . item_src ] item_dest = item_cache [ trade . item_dest ] src_price = item_src . sell_price dest_price = item_dest . buy_price if not item_dest . buy_price : dest_price = item_dest . sell_price # Lower the limit if these are tools, otherwise you'll end up with super trash trades. if psql . Equipment . is_equipment ( item_src . id ) or psql . Equipment . is_equipment ( item_dest . id ): max_value_limit = 50 # Force the current max to be at least the item's price so we can avoid amount = 0. max_value_limit = max ( src_price , dest_price , max_value_limit ) # At this point we can guarantee the trade will have at least 1 on both side, we can safely get amount. src_max_amount = max_value_limit // src_price dest_max_amount = max_value_limit // dest_price if src_price > dest_price : trade . amount_src = random . randint ( 1 , src_max_amount ) trade . amount_dest = math . ceil (( trade . amount_src * src_price // dest_price ) * random . random ()) else : trade . amount_dest = random . randint ( 1 , dest_max_amount ) trade . amount_src = math . ceil (( trade . amount_dest * dest_price // src_price ) * random . random ()) # money -> item else : trade . item_src = \"money\" trade . item_dest = \"money\" while trade . item_dest in traded_item : trade . item_dest = random . choice ( __TRADE_WHITELIST ) traded_item . append ( trade . item_dest ) # Get the item's value. item = item_cache [ trade . item_dest ] dest_price = item . buy_price if not item . buy_price : dest_price = item . sell_price # Lower the limit if these are tools, otherwise you'll end up with super trash trades. if psql . Equipment . is_equipment ( item . id ): max_value_limit = 50 # Force the current max to be at least the item's price so we can avoid amount = 0. max_value_limit = max ( max_value_limit , dest_price ) # Get the max amount of item to not exceed the trade's current max value. dest_max_amount = max_value_limit // dest_price trade . amount_dest = random . randint ( 1 , dest_max_amount ) # Devalue the item. trade . amount_src = math . ceil ( trade . amount_dest * dest_price * ( 1 + random . random ())) trades . append ( trade ) return trades","title":"generate_trades()"},{"location":"dev/econ/#categories.econ.trader.generate_barters","text":"generate_barters ( item_cache : models . ItemCache , next_reset : dt . datetime , amount : int = 9 ) -> list [ psql . ActiveTrade ] Generate barters based on pre-determined rules. Parameters: Name Type Description Default item_cache models . ItemCache The bot's item cache. This is to get item's information. required next_reset dt . datetime When these barters will reset. required amount int , optional How many barter to generate, by default 6 9 Returns: Type Description list [ psql . ActiveTrade ] A list of barters to be added. Source code in categories\\econ\\trader.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def generate_barters ( item_cache : models . ItemCache , next_reset : dt . datetime , amount : int = 9 ) -> list [ psql . ActiveTrade ]: '''Generate barters based on pre-determined rules. Parameters ---------- item_cache : models.ItemCache The bot's item cache. This is to get item's information. next_reset : dt.datetime When these barters will reset. amount : int, optional How many barter to generate, by default 6 Returns ------- list[psql.ActiveTrade] A list of barters to be added. ''' barters = [] # Avoid duplicate barters. bartered_items = [ \"gold\" ] for i in range ( 1 , amount + 1 ): barter = psql . ActiveTrade ( i , \"barter\" , \"\" , 0 , \"\" , 0 , next_reset , 20 ) max_value_limit = random . randint ( 1 , 500 ) if i == 1 : max_value_limit = random . randint ( 1 , 25 ) barter . hard_limit = 5 barter . item_dest = \"gold\" barter . item_src = \"gold\" while barter . item_src in bartered_items : barter . item_src = random . choice ( __BARTER_WHITELIST ) bartered_items . append ( barter . item_src ) else : barter . item_src = \"gold\" barter . item_dest = \"gold\" while barter . item_dest in bartered_items : barter . item_dest = random . choice ( __BARTER_WHITELIST ) bartered_items . append ( barter . item_dest ) # Get the items' values. item_src = item_cache [ barter . item_src ] item_dest = item_cache [ barter . item_dest ] src_price = item_src . sell_price dest_price = item_dest . buy_price if not item_dest . buy_price : dest_price = item_dest . sell_price # Force the current max to be at least the item's price so we can avoid amount = 0. max_value_limit = max ( src_price , dest_price , max_value_limit ) # At this point we can guarantee the trade will have at least 1 on both side, we can safely get amount. src_max_amount = max_value_limit // src_price dest_max_amount = max_value_limit // dest_price if src_price > dest_price : barter . amount_src = random . randint ( 1 , src_max_amount ) barter . amount_dest = math . ceil (( barter . amount_src * src_price // dest_price ) * random . random ()) else : barter . amount_dest = random . randint ( 1 , dest_max_amount ) barter . amount_src = math . ceil (( barter . amount_dest * dest_price // src_price ) * random . random ()) barters . append ( barter ) return barters","title":"generate_barters()"},{"location":"dev/errors/","text":"Custom exceptions (errors) to handle in global error handler. CustomAPIFailed Bases: hikari . HTTPError Exception raised when a third-party API call failed (not status 200). CustomCheckFailed Bases: lightbulb . CheckFailure Exception raised when a custom check (not lightbulb check) failed. NoDatabase Bases: CustomCheckFailed Exception raised when the bot doesn't have a database connection pool. NoHTTPClient Bases: CustomCheckFailed Exception raised when the bot doesn't have a http client. GuildDisabled Bases: CustomCheckFailed Exception raised when the guild disable the command. GuildBlacklisted Bases: CustomCheckFailed Exception raised when the guild is blacklisted by the bot's owner. UserBlacklisted Bases: CustomCheckFailed Exception raised when the user is blacklisted by the bot's owner.","title":"errors.py"},{"location":"dev/errors/#utils.errors.CustomAPIFailed","text":"Bases: hikari . HTTPError Exception raised when a third-party API call failed (not status 200).","title":"CustomAPIFailed"},{"location":"dev/errors/#utils.errors.CustomCheckFailed","text":"Bases: lightbulb . CheckFailure Exception raised when a custom check (not lightbulb check) failed.","title":"CustomCheckFailed"},{"location":"dev/errors/#utils.errors.NoDatabase","text":"Bases: CustomCheckFailed Exception raised when the bot doesn't have a database connection pool.","title":"NoDatabase"},{"location":"dev/errors/#utils.errors.NoHTTPClient","text":"Bases: CustomCheckFailed Exception raised when the bot doesn't have a http client.","title":"NoHTTPClient"},{"location":"dev/errors/#utils.errors.GuildDisabled","text":"Bases: CustomCheckFailed Exception raised when the guild disable the command.","title":"GuildDisabled"},{"location":"dev/errors/#utils.errors.GuildBlacklisted","text":"Bases: CustomCheckFailed Exception raised when the guild is blacklisted by the bot's owner.","title":"GuildBlacklisted"},{"location":"dev/errors/#utils.errors.UserBlacklisted","text":"Bases: CustomCheckFailed Exception raised when the user is blacklisted by the bot's owner.","title":"UserBlacklisted"},{"location":"dev/funtext/","text":"Contains funny text manipulations. pekofy pekofy ( / , text : str ) -> str A simple implementation of pekofy which simply adds peko at the end of a sentence. Parameters: Name Type Description Default text str The text to transform. required Returns: Type Description str The pekofy text. Source code in utils\\funtext.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def pekofy ( text : str , / ) -> str : '''A simple implementation of `pekofy` which simply adds `peko` at the end of a sentence. Parameters ---------- text : str The text to transform. Returns ------- str The pekofy text. ''' words = text . split () for index , word in enumerate ( words ): for punc in [ '.' , '!' , '?' ]: if word . endswith ( punc ): words [ index ] = words [ index ][: - 1 ] + f \" peko { punc } \" if word == words [ - 1 ]: words [ index ] += \" peko\" return ' ' . join ( words ) uwuify uwuify ( / , text : str , * , allow_nyvowels = True , stutter_chance : float = 0.2 , emote_chance : float = 0.8 , action_chance : float = 0.05 ) -> str Transform a text into uwu text. Parameters: Name Type Description Default text str The text to transform. required allow_nyvowels bool , optional Whether or not to transform na , no , etc. into nya , nyo , etc. Default to True . True stutter_chance float , optional The chance to stutter a word. Must be [0, 1] . Default to 0.20 . 0.2 emote_chance float , optional The chance to put an emote after a punctuation like , or . Must be [0, 1] . Default to 0.8 . 0.8 action_chance float , optional The chance to put an action string after a word. Must be [0, 1] . Default to 0.05 . 0.05 Returns: Type Description str The uwu text. Source code in utils\\funtext.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def uwuify ( text : str , / , * , allow_nyvowels = True , stutter_chance : float = 0.20 , emote_chance : float = 0.8 , action_chance : float = 0.05 ) -> str : '''Transform a text into uwu text. Parameters ---------- text : str The text to transform. allow_nyvowels : bool, optional Whether or not to transform `na`, `no`, etc. into `nya`, `nyo`, etc. Default to `True`. stutter_chance : float, optional The chance to stutter a word. Must be `[0, 1]`. Default to `0.20`. emote_chance : float, optional The chance to put an emote after a punctuation like `,` or `.` Must be `[0, 1]`. Default to `0.8`. action_chance : float, optional The chance to put an action string after a word. Must be `[0, 1]`. Default to `0.05`. Returns ------- str The uwu text. ''' words = text . split () for index , word in enumerate ( words ): words [ index ] = words [ index ] . replace ( 'l' , 'w' ) words [ index ] = words [ index ] . replace ( 'L' , 'W' ) words [ index ] = words [ index ] . replace ( 'r' , 'w' ) words [ index ] = words [ index ] . replace ( 'R' , 'W' ) if allow_nyvowels : words [ index ] = words [ index ] . replace ( \"na\" , \"nya\" ) words [ index ] = words [ index ] . replace ( \"Na\" , \"Nya\" ) words [ index ] = words [ index ] . replace ( \"NA\" , \"NyA\" ) words [ index ] = words [ index ] . replace ( \"ne\" , \"nye\" ) words [ index ] = words [ index ] . replace ( \"Ne\" , \"Nye\" ) words [ index ] = words [ index ] . replace ( \"NE\" , \"NyE\" ) words [ index ] = words [ index ] . replace ( \"no\" , \"nyo\" ) words [ index ] = words [ index ] . replace ( \"No\" , \"Nyo\" ) words [ index ] = words [ index ] . replace ( \"NO\" , \"NyO\" ) words [ index ] = words [ index ] . replace ( \"nu\" , \"yu\" ) words [ index ] = words [ index ] . replace ( \"Nu\" , \"Nyu\" ) words [ index ] = words [ index ] . replace ( \"NU\" , \"NyU\" ) if word in __REPLACE_WORDS : words [ index ] = __REPLACE_WORDS [ word ] is_stutter = random . random () if is_stutter <= stutter_chance : words [ index ] = f \" { words [ index ][ 0 ] } - { words [ index ] } \" is_emote = random . random () if is_emote <= emote_chance and words [ index ] . endswith (( '.' , '?' , '!' , ',' )): words [ index ] += random . choice ( __RANDOM_EMOTES ) is_action = random . random () if is_action <= action_chance : words [ index ] += random . choice ( __RANDOM_ACTIONS ) return ' ' . join ( words )","title":"funtext.py"},{"location":"dev/funtext/#utils.funtext.pekofy","text":"pekofy ( / , text : str ) -> str A simple implementation of pekofy which simply adds peko at the end of a sentence. Parameters: Name Type Description Default text str The text to transform. required Returns: Type Description str The pekofy text. Source code in utils\\funtext.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def pekofy ( text : str , / ) -> str : '''A simple implementation of `pekofy` which simply adds `peko` at the end of a sentence. Parameters ---------- text : str The text to transform. Returns ------- str The pekofy text. ''' words = text . split () for index , word in enumerate ( words ): for punc in [ '.' , '!' , '?' ]: if word . endswith ( punc ): words [ index ] = words [ index ][: - 1 ] + f \" peko { punc } \" if word == words [ - 1 ]: words [ index ] += \" peko\" return ' ' . join ( words )","title":"pekofy()"},{"location":"dev/funtext/#utils.funtext.uwuify","text":"uwuify ( / , text : str , * , allow_nyvowels = True , stutter_chance : float = 0.2 , emote_chance : float = 0.8 , action_chance : float = 0.05 ) -> str Transform a text into uwu text. Parameters: Name Type Description Default text str The text to transform. required allow_nyvowels bool , optional Whether or not to transform na , no , etc. into nya , nyo , etc. Default to True . True stutter_chance float , optional The chance to stutter a word. Must be [0, 1] . Default to 0.20 . 0.2 emote_chance float , optional The chance to put an emote after a punctuation like , or . Must be [0, 1] . Default to 0.8 . 0.8 action_chance float , optional The chance to put an action string after a word. Must be [0, 1] . Default to 0.05 . 0.05 Returns: Type Description str The uwu text. Source code in utils\\funtext.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def uwuify ( text : str , / , * , allow_nyvowels = True , stutter_chance : float = 0.20 , emote_chance : float = 0.8 , action_chance : float = 0.05 ) -> str : '''Transform a text into uwu text. Parameters ---------- text : str The text to transform. allow_nyvowels : bool, optional Whether or not to transform `na`, `no`, etc. into `nya`, `nyo`, etc. Default to `True`. stutter_chance : float, optional The chance to stutter a word. Must be `[0, 1]`. Default to `0.20`. emote_chance : float, optional The chance to put an emote after a punctuation like `,` or `.` Must be `[0, 1]`. Default to `0.8`. action_chance : float, optional The chance to put an action string after a word. Must be `[0, 1]`. Default to `0.05`. Returns ------- str The uwu text. ''' words = text . split () for index , word in enumerate ( words ): words [ index ] = words [ index ] . replace ( 'l' , 'w' ) words [ index ] = words [ index ] . replace ( 'L' , 'W' ) words [ index ] = words [ index ] . replace ( 'r' , 'w' ) words [ index ] = words [ index ] . replace ( 'R' , 'W' ) if allow_nyvowels : words [ index ] = words [ index ] . replace ( \"na\" , \"nya\" ) words [ index ] = words [ index ] . replace ( \"Na\" , \"Nya\" ) words [ index ] = words [ index ] . replace ( \"NA\" , \"NyA\" ) words [ index ] = words [ index ] . replace ( \"ne\" , \"nye\" ) words [ index ] = words [ index ] . replace ( \"Ne\" , \"Nye\" ) words [ index ] = words [ index ] . replace ( \"NE\" , \"NyE\" ) words [ index ] = words [ index ] . replace ( \"no\" , \"nyo\" ) words [ index ] = words [ index ] . replace ( \"No\" , \"Nyo\" ) words [ index ] = words [ index ] . replace ( \"NO\" , \"NyO\" ) words [ index ] = words [ index ] . replace ( \"nu\" , \"yu\" ) words [ index ] = words [ index ] . replace ( \"Nu\" , \"Nyu\" ) words [ index ] = words [ index ] . replace ( \"NU\" , \"NyU\" ) if word in __REPLACE_WORDS : words [ index ] = __REPLACE_WORDS [ word ] is_stutter = random . random () if is_stutter <= stutter_chance : words [ index ] = f \" { words [ index ][ 0 ] } - { words [ index ] } \" is_emote = random . random () if is_emote <= emote_chance and words [ index ] . endswith (( '.' , '?' , '!' , ',' )): words [ index ] += random . choice ( __RANDOM_EMOTES ) is_action = random . random () if is_action <= action_chance : words [ index ] += random . choice ( __RANDOM_ACTIONS ) return ' ' . join ( words )","title":"uwuify()"},{"location":"dev/help/","text":"Define the behavior of the 'help' command for the bot. Includes help-specific utilities. MenuLikeHelp Bases: lightbulb . DefaultHelpCommand A custom help command that's tailored for MichaelBot . Source code in categories\\help.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 class MenuLikeHelp ( lightbulb . DefaultHelpCommand ): ''' A custom help command that's tailored for `MichaelBot`. ''' async def send_help ( self , ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None : ''' The main logic for the help command. ''' bot : models . MichaelBot = self . bot # Reference: https://github.com/tandemdude/hikari-lightbulb/blob/development/lightbulb/help_command.py#L100 if obj is None : await self . send_bot_help ( ctx ) return # Prioritize searching command based on context. if isinstance ( ctx , lightbulb . PrefixContext ): cmd = bot . get_prefix_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . PrefixCommandGroup , lightbulb . PrefixSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) if isinstance ( ctx , lightbulb . SlashContext ): cmd = bot . get_slash_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) # We don't have user/message commands yet. await super () . send_help ( ctx , obj ) async def send_bot_help ( self , ctx : lightbulb . Context ) -> None : ''' Send a generic help message. ''' if isinstance ( ctx , lightbulb . PrefixContext ): await ctx . event . message . delete () main_page = helpers . get_default_embed ( title = \"Help\" , description = \"\" , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) plugins = ctx . bot . plugins # {plugin_name: command_count} plugin_info : dict [ str , int ] = {} for plugin in plugins . values (): public_commands = [] if isinstance ( ctx , lightbulb . PrefixContext ): public_commands = filter_command_type ( plugin . all_commands , __PREFIX_COMMAND_TYPES__ , True ) else : public_commands = filter_command_type ( plugin . all_commands , __SLASH_COMMAND_TYPES__ , True ) public_commands_len = len ( public_commands ) if public_commands_len > 0 : embed_name = f \" { plugin . d . emote } { plugin . name } ( { public_commands_len } commands)\" embed_description = \"*No description provided*\" if bool ( plugin . description ): embed_description = plugin . description main_page . add_field ( name = embed_name , value = embed_description , inline = False ) plugin_info [ plugin . name ] = public_commands_len menu_root = nav . MenuComponent ( main_page ) for name in plugin_info : menu_root . add_list_options ( nav . MenuButton ( label = name , emoji = plugins [ name ] . d . emote , ), plugin_help_format ( ctx , plugins [ name ]) ) await nav . ComplexView ( menu_root ) . run ( ctx ) async def send_plugin_help ( self , ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None : ''' Send a plugin help that contains all commands. ''' embeds = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ public_commands = filter_command_type ( plugin . all_commands , types , True ) for command in sorted ( public_commands , key = lambda cmd : cmd . name ): page = command_help_format ( ctx , command ) if page is not None : embeds . append ( page ) page_nav = nav . ButtonNavigator ( pages = embeds ) await nav . run_view ( page_nav , ctx ) async def send_command_help ( self , ctx : lightbulb . Context , command : lightbulb . Command ) -> None : ''' Send a command help. ''' await ctx . respond ( embed = command_help_format ( ctx , command )) async def send_group_help ( self , ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None : ''' Send a group help. Internally, this does the same as `send_command_help()`. ''' await ctx . respond ( embed = command_help_format ( ctx , group )) send_help async send_help ( ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None The main logic for the help command. Source code in categories\\help.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 async def send_help ( self , ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None : ''' The main logic for the help command. ''' bot : models . MichaelBot = self . bot # Reference: https://github.com/tandemdude/hikari-lightbulb/blob/development/lightbulb/help_command.py#L100 if obj is None : await self . send_bot_help ( ctx ) return # Prioritize searching command based on context. if isinstance ( ctx , lightbulb . PrefixContext ): cmd = bot . get_prefix_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . PrefixCommandGroup , lightbulb . PrefixSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) if isinstance ( ctx , lightbulb . SlashContext ): cmd = bot . get_slash_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) # We don't have user/message commands yet. await super () . send_help ( ctx , obj ) send_bot_help async send_bot_help ( ctx : lightbulb . Context ) -> None Send a generic help message. Source code in categories\\help.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 async def send_bot_help ( self , ctx : lightbulb . Context ) -> None : ''' Send a generic help message. ''' if isinstance ( ctx , lightbulb . PrefixContext ): await ctx . event . message . delete () main_page = helpers . get_default_embed ( title = \"Help\" , description = \"\" , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) plugins = ctx . bot . plugins # {plugin_name: command_count} plugin_info : dict [ str , int ] = {} for plugin in plugins . values (): public_commands = [] if isinstance ( ctx , lightbulb . PrefixContext ): public_commands = filter_command_type ( plugin . all_commands , __PREFIX_COMMAND_TYPES__ , True ) else : public_commands = filter_command_type ( plugin . all_commands , __SLASH_COMMAND_TYPES__ , True ) public_commands_len = len ( public_commands ) if public_commands_len > 0 : embed_name = f \" { plugin . d . emote } { plugin . name } ( { public_commands_len } commands)\" embed_description = \"*No description provided*\" if bool ( plugin . description ): embed_description = plugin . description main_page . add_field ( name = embed_name , value = embed_description , inline = False ) plugin_info [ plugin . name ] = public_commands_len menu_root = nav . MenuComponent ( main_page ) for name in plugin_info : menu_root . add_list_options ( nav . MenuButton ( label = name , emoji = plugins [ name ] . d . emote , ), plugin_help_format ( ctx , plugins [ name ]) ) await nav . ComplexView ( menu_root ) . run ( ctx ) send_plugin_help async send_plugin_help ( ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None Send a plugin help that contains all commands. Source code in categories\\help.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 async def send_plugin_help ( self , ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None : ''' Send a plugin help that contains all commands. ''' embeds = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ public_commands = filter_command_type ( plugin . all_commands , types , True ) for command in sorted ( public_commands , key = lambda cmd : cmd . name ): page = command_help_format ( ctx , command ) if page is not None : embeds . append ( page ) page_nav = nav . ButtonNavigator ( pages = embeds ) await nav . run_view ( page_nav , ctx ) send_command_help async send_command_help ( ctx : lightbulb . Context , command : lightbulb . Command ) -> None Send a command help. Source code in categories\\help.py 317 318 319 320 321 async def send_command_help ( self , ctx : lightbulb . Context , command : lightbulb . Command ) -> None : ''' Send a command help. ''' await ctx . respond ( embed = command_help_format ( ctx , command )) send_group_help async send_group_help ( ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None Send a group help. Internally, this does the same as send_command_help() . Source code in categories\\help.py 322 323 324 325 326 327 328 async def send_group_help ( self , ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None : ''' Send a group help. Internally, this does the same as `send_command_help()`. ''' await ctx . respond ( embed = command_help_format ( ctx , group )) filter_command_type filter_command_type ( commands : t . Sequence [ lightbulb . Command ], types : t . Sequence [ t . Type ], remove_hidden : bool = False ) -> t . List [ lightbulb . Command ] Filter commands with one of the type mentioned in types . Parameters: Name Type Description Default commands t . Sequence [ lightbulb . Command ] A sequence of commands. required types t . Sequence [ t . Type ] A sequence of command's types to filter. Example: (lightbulb.PrefixCommand, lightbulb.SlashCommand) . required remove_hidden bool , optional Whether or not to remove hidden commands. Default to False . False Returns: Type Description t . List [ lightbulb . Command ] A list of commands filtered out by types. Source code in categories\\help.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def filter_command_type ( commands : t . Sequence [ lightbulb . Command ], types : t . Sequence [ t . Type ], remove_hidden : bool = False ) -> t . List [ lightbulb . Command ]: '''Filter commands with one of the type mentioned in `types`. Parameters ---------- commands : t.Sequence[lightbulb.Command] A sequence of commands. types : t.Sequence[t.Type] A sequence of command's types to filter. Example: `(lightbulb.PrefixCommand, lightbulb.SlashCommand)`. remove_hidden : bool, optional Whether or not to remove hidden commands. Default to `False`. Returns ------- t.List[lightbulb.Command] A list of commands filtered out by types. ''' l = [] for command in commands : if isinstance ( command , types ): if ( not remove_hidden ) or ( remove_hidden and not command . hidden ): l . append ( command ) return l plugin_help_format plugin_help_format ( ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> t . List [ hikari . Embed ] Return a list of formatted embed for a plugin help. This list can be passed into a paginator to display. Parameters: Name Type Description Default ctx lightbulb . Context The context. required plugin lightbulb . Plugin The plugin to display the help. required Returns: Type Description t . List [ hikari . Embed ] A list of formatted embed for a plugin help. Source code in categories\\help.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def plugin_help_format ( ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> t . List [ hikari . Embed ]: '''Return a list of formatted embed for a plugin help. This list can be passed into a paginator to display. Parameters ---------- ctx : lightbulb.Context The context. plugin : lightbulb.Plugin The plugin to display the help. Returns ------- t.List[hikari.Embed] A list of formatted embed for a plugin help. ''' MAX_COMMANDS = 10 display = \"\" plugins = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ commands : t . List [ lightbulb . Command ] = filter_command_type ( plugin . all_commands , types , True ) commands . sort ( key = lambda command : command . name ) for index , command in enumerate ( commands ): # Signature includes command name. command_title = command . signature . replace ( '=' , ' = ' ) display += f \"** { command_title } :** \\n \" description = command . description if not description : description = \"*No help provided*\" display += f \"- { description } \\n\\n \" if index == MAX_COMMANDS - 1 or index == len ( commands ) - 1 : title = f \" { plugin . name } ( { len ( commands ) } commands):\" embed = helpers . get_default_embed ( title = title , description = display , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) . set_thumbnail ( ctx . bot . get_me () . avatar_url ) plugins . append ( embed ) display = \"\" return plugins command_help_format command_help_format ( ctx : lightbulb . Context , command : lightbulb . Command ) -> hikari . Embed Return a formatted embed for a command help. Notes For command group, the embed will also include all subcommands. Parameters: Name Type Description Default ctx lightbulb . Context The context. required command lightbulb . Command The command to display the help. Can also be a command group/subcommand/... required Returns: Type Description hikari . Embed The formatted embed for a command help. Source code in categories\\help.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def command_help_format ( ctx : lightbulb . Context , command : lightbulb . Command ) -> hikari . Embed : '''Return a formatted embed for a command help. Notes ----- For command group, the embed will also include all subcommands. Parameters ---------- ctx : lightbulb.Context The context. command : lightbulb.Command The command to display the help. Can also be a command group/subcommand/... Returns ------- hikari.Embed The formatted embed for a command help. ''' bot : models . MichaelBot = ctx . bot # Signature includes full command name. embed_title = command . signature . replace ( '=' , ' = ' ) embed_description = \"*No help provided*\" if command . description != \"\" : embed_description = command . description + ' \\n ' embed = helpers . get_default_embed ( title = embed_title , description = embed_description , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) command_type = [] p_cmd = bot . get_prefix_command ( command . qualname ) s_cmd = bot . get_slash_command ( command . qualname ) m_cmd = bot . get_message_command ( command . qualname ) u_cmd = bot . get_user_command ( command . qualname ) if p_cmd is not None : command_type . append ( \"`Prefix Command`\" ) if s_cmd is not None and not isinstance ( s_cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): command_type . append ( \"`Slash Command`\" ) if m_cmd is not None : command_type . append ( \"`Message Command`\" ) if u_cmd is not None : command_type . append ( \"`User Command`\" ) embed . add_field ( name = \"Type\" , value = ' ' . join ( command_type ) ) if len ( command . options ) > 0 : option_field = \"\" for option in command . options . values (): option_field += f \"- ` { option . name } `: { option . description } \\n \" embed . add_field ( name = \"Parameters\" , value = option_field ) if len ( command . aliases ) > 0 and isinstance ( command , __PREFIX_COMMAND_TYPES__ ): embed . add_field ( name = \"Aliases (Prefix Command only)\" , value = \"- \" + ', ' . join ( f \"` { alias } `\" for alias in command . aliases ) ) if bool ( command . get_help ( ctx )): embed . add_field ( name = \"Note\" , value = dedent ( command . get_help ( ctx )) ) if isinstance ( command , __COMMAND_GROUPS_TYPES__ ): field_value = \"\" subcommands = command . subcommands . values () types = __PREFIX_COMMAND_TYPES__ # Can't check with ctx, since SlashContext can call a PrefixCommandGroup. if isinstance ( command , __SLASH_COMMAND_TYPES__ ): types = __SLASH_COMMAND_TYPES__ for subcommand in sorted ( filter_command_type ( subcommands , types , True ), key = lambda cmd : cmd . name ): field_value += f \"- ` { subcommand . name } `: { subcommand . description } \\n \" if len ( command . subcommands ) > 0 : embed . add_field ( name = \"**Subcommands:**\" , value = field_value , inline = False ) return embed","title":"help.py"},{"location":"dev/help/#categories.help.MenuLikeHelp","text":"Bases: lightbulb . DefaultHelpCommand A custom help command that's tailored for MichaelBot . Source code in categories\\help.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 class MenuLikeHelp ( lightbulb . DefaultHelpCommand ): ''' A custom help command that's tailored for `MichaelBot`. ''' async def send_help ( self , ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None : ''' The main logic for the help command. ''' bot : models . MichaelBot = self . bot # Reference: https://github.com/tandemdude/hikari-lightbulb/blob/development/lightbulb/help_command.py#L100 if obj is None : await self . send_bot_help ( ctx ) return # Prioritize searching command based on context. if isinstance ( ctx , lightbulb . PrefixContext ): cmd = bot . get_prefix_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . PrefixCommandGroup , lightbulb . PrefixSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) if isinstance ( ctx , lightbulb . SlashContext ): cmd = bot . get_slash_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) # We don't have user/message commands yet. await super () . send_help ( ctx , obj ) async def send_bot_help ( self , ctx : lightbulb . Context ) -> None : ''' Send a generic help message. ''' if isinstance ( ctx , lightbulb . PrefixContext ): await ctx . event . message . delete () main_page = helpers . get_default_embed ( title = \"Help\" , description = \"\" , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) plugins = ctx . bot . plugins # {plugin_name: command_count} plugin_info : dict [ str , int ] = {} for plugin in plugins . values (): public_commands = [] if isinstance ( ctx , lightbulb . PrefixContext ): public_commands = filter_command_type ( plugin . all_commands , __PREFIX_COMMAND_TYPES__ , True ) else : public_commands = filter_command_type ( plugin . all_commands , __SLASH_COMMAND_TYPES__ , True ) public_commands_len = len ( public_commands ) if public_commands_len > 0 : embed_name = f \" { plugin . d . emote } { plugin . name } ( { public_commands_len } commands)\" embed_description = \"*No description provided*\" if bool ( plugin . description ): embed_description = plugin . description main_page . add_field ( name = embed_name , value = embed_description , inline = False ) plugin_info [ plugin . name ] = public_commands_len menu_root = nav . MenuComponent ( main_page ) for name in plugin_info : menu_root . add_list_options ( nav . MenuButton ( label = name , emoji = plugins [ name ] . d . emote , ), plugin_help_format ( ctx , plugins [ name ]) ) await nav . ComplexView ( menu_root ) . run ( ctx ) async def send_plugin_help ( self , ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None : ''' Send a plugin help that contains all commands. ''' embeds = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ public_commands = filter_command_type ( plugin . all_commands , types , True ) for command in sorted ( public_commands , key = lambda cmd : cmd . name ): page = command_help_format ( ctx , command ) if page is not None : embeds . append ( page ) page_nav = nav . ButtonNavigator ( pages = embeds ) await nav . run_view ( page_nav , ctx ) async def send_command_help ( self , ctx : lightbulb . Context , command : lightbulb . Command ) -> None : ''' Send a command help. ''' await ctx . respond ( embed = command_help_format ( ctx , command )) async def send_group_help ( self , ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None : ''' Send a group help. Internally, this does the same as `send_command_help()`. ''' await ctx . respond ( embed = command_help_format ( ctx , group ))","title":"MenuLikeHelp"},{"location":"dev/help/#categories.help.MenuLikeHelp.send_help","text":"send_help ( ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None The main logic for the help command. Source code in categories\\help.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 async def send_help ( self , ctx : lightbulb . Context , obj : t . Optional [ str ]) -> None : ''' The main logic for the help command. ''' bot : models . MichaelBot = self . bot # Reference: https://github.com/tandemdude/hikari-lightbulb/blob/development/lightbulb/help_command.py#L100 if obj is None : await self . send_bot_help ( ctx ) return # Prioritize searching command based on context. if isinstance ( ctx , lightbulb . PrefixContext ): cmd = bot . get_prefix_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . PrefixCommandGroup , lightbulb . PrefixSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) if isinstance ( ctx , lightbulb . SlashContext ): cmd = bot . get_slash_command ( obj ) if cmd is not None : if isinstance ( cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): return await self . send_group_help ( ctx , cmd ) else : return await self . send_command_help ( ctx , cmd ) # We don't have user/message commands yet. await super () . send_help ( ctx , obj )","title":"send_help()"},{"location":"dev/help/#categories.help.MenuLikeHelp.send_bot_help","text":"send_bot_help ( ctx : lightbulb . Context ) -> None Send a generic help message. Source code in categories\\help.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 async def send_bot_help ( self , ctx : lightbulb . Context ) -> None : ''' Send a generic help message. ''' if isinstance ( ctx , lightbulb . PrefixContext ): await ctx . event . message . delete () main_page = helpers . get_default_embed ( title = \"Help\" , description = \"\" , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) plugins = ctx . bot . plugins # {plugin_name: command_count} plugin_info : dict [ str , int ] = {} for plugin in plugins . values (): public_commands = [] if isinstance ( ctx , lightbulb . PrefixContext ): public_commands = filter_command_type ( plugin . all_commands , __PREFIX_COMMAND_TYPES__ , True ) else : public_commands = filter_command_type ( plugin . all_commands , __SLASH_COMMAND_TYPES__ , True ) public_commands_len = len ( public_commands ) if public_commands_len > 0 : embed_name = f \" { plugin . d . emote } { plugin . name } ( { public_commands_len } commands)\" embed_description = \"*No description provided*\" if bool ( plugin . description ): embed_description = plugin . description main_page . add_field ( name = embed_name , value = embed_description , inline = False ) plugin_info [ plugin . name ] = public_commands_len menu_root = nav . MenuComponent ( main_page ) for name in plugin_info : menu_root . add_list_options ( nav . MenuButton ( label = name , emoji = plugins [ name ] . d . emote , ), plugin_help_format ( ctx , plugins [ name ]) ) await nav . ComplexView ( menu_root ) . run ( ctx )","title":"send_bot_help()"},{"location":"dev/help/#categories.help.MenuLikeHelp.send_plugin_help","text":"send_plugin_help ( ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None Send a plugin help that contains all commands. Source code in categories\\help.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 async def send_plugin_help ( self , ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> None : ''' Send a plugin help that contains all commands. ''' embeds = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ public_commands = filter_command_type ( plugin . all_commands , types , True ) for command in sorted ( public_commands , key = lambda cmd : cmd . name ): page = command_help_format ( ctx , command ) if page is not None : embeds . append ( page ) page_nav = nav . ButtonNavigator ( pages = embeds ) await nav . run_view ( page_nav , ctx )","title":"send_plugin_help()"},{"location":"dev/help/#categories.help.MenuLikeHelp.send_command_help","text":"send_command_help ( ctx : lightbulb . Context , command : lightbulb . Command ) -> None Send a command help. Source code in categories\\help.py 317 318 319 320 321 async def send_command_help ( self , ctx : lightbulb . Context , command : lightbulb . Command ) -> None : ''' Send a command help. ''' await ctx . respond ( embed = command_help_format ( ctx , command ))","title":"send_command_help()"},{"location":"dev/help/#categories.help.MenuLikeHelp.send_group_help","text":"send_group_help ( ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None Send a group help. Internally, this does the same as send_command_help() . Source code in categories\\help.py 322 323 324 325 326 327 328 async def send_group_help ( self , ctx : lightbulb . Context , group : t . Union [ lightbulb . commands . PrefixCommandGroup , lightbulb . commands . PrefixSubGroup ]) -> None : ''' Send a group help. Internally, this does the same as `send_command_help()`. ''' await ctx . respond ( embed = command_help_format ( ctx , group ))","title":"send_group_help()"},{"location":"dev/help/#categories.help.filter_command_type","text":"filter_command_type ( commands : t . Sequence [ lightbulb . Command ], types : t . Sequence [ t . Type ], remove_hidden : bool = False ) -> t . List [ lightbulb . Command ] Filter commands with one of the type mentioned in types . Parameters: Name Type Description Default commands t . Sequence [ lightbulb . Command ] A sequence of commands. required types t . Sequence [ t . Type ] A sequence of command's types to filter. Example: (lightbulb.PrefixCommand, lightbulb.SlashCommand) . required remove_hidden bool , optional Whether or not to remove hidden commands. Default to False . False Returns: Type Description t . List [ lightbulb . Command ] A list of commands filtered out by types. Source code in categories\\help.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def filter_command_type ( commands : t . Sequence [ lightbulb . Command ], types : t . Sequence [ t . Type ], remove_hidden : bool = False ) -> t . List [ lightbulb . Command ]: '''Filter commands with one of the type mentioned in `types`. Parameters ---------- commands : t.Sequence[lightbulb.Command] A sequence of commands. types : t.Sequence[t.Type] A sequence of command's types to filter. Example: `(lightbulb.PrefixCommand, lightbulb.SlashCommand)`. remove_hidden : bool, optional Whether or not to remove hidden commands. Default to `False`. Returns ------- t.List[lightbulb.Command] A list of commands filtered out by types. ''' l = [] for command in commands : if isinstance ( command , types ): if ( not remove_hidden ) or ( remove_hidden and not command . hidden ): l . append ( command ) return l","title":"filter_command_type()"},{"location":"dev/help/#categories.help.plugin_help_format","text":"plugin_help_format ( ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> t . List [ hikari . Embed ] Return a list of formatted embed for a plugin help. This list can be passed into a paginator to display. Parameters: Name Type Description Default ctx lightbulb . Context The context. required plugin lightbulb . Plugin The plugin to display the help. required Returns: Type Description t . List [ hikari . Embed ] A list of formatted embed for a plugin help. Source code in categories\\help.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def plugin_help_format ( ctx : lightbulb . Context , plugin : lightbulb . Plugin ) -> t . List [ hikari . Embed ]: '''Return a list of formatted embed for a plugin help. This list can be passed into a paginator to display. Parameters ---------- ctx : lightbulb.Context The context. plugin : lightbulb.Plugin The plugin to display the help. Returns ------- t.List[hikari.Embed] A list of formatted embed for a plugin help. ''' MAX_COMMANDS = 10 display = \"\" plugins = [] types = __PREFIX_COMMAND_TYPES__ if isinstance ( ctx , lightbulb . SlashContext ): types = __SLASH_COMMAND_TYPES__ commands : t . List [ lightbulb . Command ] = filter_command_type ( plugin . all_commands , types , True ) commands . sort ( key = lambda command : command . name ) for index , command in enumerate ( commands ): # Signature includes command name. command_title = command . signature . replace ( '=' , ' = ' ) display += f \"** { command_title } :** \\n \" description = command . description if not description : description = \"*No help provided*\" display += f \"- { description } \\n\\n \" if index == MAX_COMMANDS - 1 or index == len ( commands ) - 1 : title = f \" { plugin . name } ( { len ( commands ) } commands):\" embed = helpers . get_default_embed ( title = title , description = display , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) . set_thumbnail ( ctx . bot . get_me () . avatar_url ) plugins . append ( embed ) display = \"\" return plugins","title":"plugin_help_format()"},{"location":"dev/help/#categories.help.command_help_format","text":"command_help_format ( ctx : lightbulb . Context , command : lightbulb . Command ) -> hikari . Embed Return a formatted embed for a command help.","title":"command_help_format()"},{"location":"dev/help/#categories.help.command_help_format--notes","text":"For command group, the embed will also include all subcommands. Parameters: Name Type Description Default ctx lightbulb . Context The context. required command lightbulb . Command The command to display the help. Can also be a command group/subcommand/... required Returns: Type Description hikari . Embed The formatted embed for a command help. Source code in categories\\help.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def command_help_format ( ctx : lightbulb . Context , command : lightbulb . Command ) -> hikari . Embed : '''Return a formatted embed for a command help. Notes ----- For command group, the embed will also include all subcommands. Parameters ---------- ctx : lightbulb.Context The context. command : lightbulb.Command The command to display the help. Can also be a command group/subcommand/... Returns ------- hikari.Embed The formatted embed for a command help. ''' bot : models . MichaelBot = ctx . bot # Signature includes full command name. embed_title = command . signature . replace ( '=' , ' = ' ) embed_description = \"*No help provided*\" if command . description != \"\" : embed_description = command . description + ' \\n ' embed = helpers . get_default_embed ( title = embed_title , description = embed_description , timestamp = dt . datetime . now () . astimezone (), author = ctx . author ) command_type = [] p_cmd = bot . get_prefix_command ( command . qualname ) s_cmd = bot . get_slash_command ( command . qualname ) m_cmd = bot . get_message_command ( command . qualname ) u_cmd = bot . get_user_command ( command . qualname ) if p_cmd is not None : command_type . append ( \"`Prefix Command`\" ) if s_cmd is not None and not isinstance ( s_cmd , ( lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup )): command_type . append ( \"`Slash Command`\" ) if m_cmd is not None : command_type . append ( \"`Message Command`\" ) if u_cmd is not None : command_type . append ( \"`User Command`\" ) embed . add_field ( name = \"Type\" , value = ' ' . join ( command_type ) ) if len ( command . options ) > 0 : option_field = \"\" for option in command . options . values (): option_field += f \"- ` { option . name } `: { option . description } \\n \" embed . add_field ( name = \"Parameters\" , value = option_field ) if len ( command . aliases ) > 0 and isinstance ( command , __PREFIX_COMMAND_TYPES__ ): embed . add_field ( name = \"Aliases (Prefix Command only)\" , value = \"- \" + ', ' . join ( f \"` { alias } `\" for alias in command . aliases ) ) if bool ( command . get_help ( ctx )): embed . add_field ( name = \"Note\" , value = dedent ( command . get_help ( ctx )) ) if isinstance ( command , __COMMAND_GROUPS_TYPES__ ): field_value = \"\" subcommands = command . subcommands . values () types = __PREFIX_COMMAND_TYPES__ # Can't check with ctx, since SlashContext can call a PrefixCommandGroup. if isinstance ( command , __SLASH_COMMAND_TYPES__ ): types = __SLASH_COMMAND_TYPES__ for subcommand in sorted ( filter_command_type ( subcommands , types , True ), key = lambda cmd : cmd . name ): field_value += f \"- ` { subcommand . name } `: { subcommand . description } \\n \" if len ( command . subcommands ) > 0 : embed . add_field ( name = \"**Subcommands:**\" , value = field_value , inline = False ) return embed","title":"Notes"},{"location":"dev/helpers/","text":"Contains many useful functions. embed_from_dict embed_from_dict ( / , data : dict [ str , t . Any ]) -> hikari . Embed Generate an embed from a dictionary. Parameters: Name Type Description Default data dict [ str , t . Any ] A valid dict representation of an embed. required Returns: Type Description hikari . Embed The embed from the dict. Source code in utils\\helpers.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def embed_from_dict ( data : dict [ str , t . Any ], / ) -> hikari . Embed : '''Generate an embed from a dictionary. Parameters ---------- data : dict[str, t.Any] A valid dict representation of an embed. Returns ------- hikari.Embed The embed from the dict. ''' embed = hikari . Embed () embed . title = data . get ( \"title\" , None ) embed . description = data . get ( \"description\" , None ) embed . url = data . get ( \"url\" , None ) if embed . title is not None : embed . title = str ( embed . title ) if embed . description is not None : embed . description = str ( embed . description ) if embed . url is not None : embed . url = str ( embed . url ) try : embed . color = hikari . Color ( data [ \"color\" ]) except KeyError : pass try : embed . timestamp = dt . datetime . fromtimestamp ( data [ 'timestamp' ], tz = dt . timezone . utc ) except KeyError : pass try : value = data [ \"thumbnail\" ] except KeyError : pass else : embed . set_thumbnail ( value ) try : value = data [ \"author\" ] except KeyError : pass else : embed . set_author ( ** value ) try : value = data [ \"fields\" ] except KeyError : pass else : for field in value : embed . add_field ( ** field ) try : value = data [ \"image\" ] except KeyError : pass else : embed . set_image ( value ) try : value = data [ \"footer\" ] except KeyError : pass else : embed . set_footer ( ** value ) return embed embed_to_dict embed_to_dict ( / , embed : hikari . Embed ) -> dict [ str , t . Any ] Convert an embed into a dict object. Parameters: Name Type Description Default embed hikari . Embed An embed object to convert. required Returns: Type Description dict [ str , t . Any ] A dictionary that conforms Discord's structure. Source code in utils\\helpers.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def embed_to_dict ( embed : hikari . Embed , / ) -> dict [ str , t . Any ]: '''Convert an embed into a dict object. Parameters ---------- embed : hikari.Embed An embed object to convert. Returns ------- dict[str, t.Any] A dictionary that conforms Discord's structure. ''' d = {} if bool ( embed . title ): d [ \"title\" ] = embed . title if bool ( embed . description ): d [ \"description\" ] = embed . description if bool ( embed . url ): d [ \"url\" ] = embed . url if bool ( embed . color ): d [ \"color\" ] = int ( embed . color ) if bool ( embed . timestamp ): d [ \"timestamp\" ] = embed . timestamp . timestamp () if bool ( embed . thumbnail ): d [ \"thumbnail\" ] = embed . thumbnail . url if bool ( embed . author ): d [ \"author\" ] = { \"name\" : embed . author . name , \"url\" : embed . author . url } if bool ( embed . author . icon ): d [ \"author\" ][ \"icon\" ] = embed . author . icon . url if bool ( embed . fields ): d [ \"fields\" ] = [] for field in embed . fields : d [ \"fields\" ] . append ({ \"name\" : field . name , \"value\" : field . value , \"inline\" : field . is_inline }) if bool ( embed . image ): d [ \"image\" ] = embed . image . url if bool ( embed . footer ): d [ \"footer\" ] = { \"text\" : embed . footer . text } if bool ( embed . footer . icon ): d [ \"footer\" ][ \"icon\" ] = embed . footer . icon . url return d get_emote get_emote ( / , discord_text : str ) -> str Return the Unicode emoji based on the name provided. Parameters: Name Type Description Default discord_text str Discord/Twitter name of the emoji including : . Example: :grin: . required Returns: Type Description str The Unicode emoji matching the text. Raises: Type Description KeyError Cannot find the emoji based on the text. Source code in utils\\helpers.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def get_emote ( discord_text : str , / ) -> str : '''Return the Unicode emoji based on the name provided. Parameters ---------- discord_text : str Discord/Twitter name of the emoji including `:`. Example: `:grin:`. Returns ------- str The Unicode emoji matching the text. Raises ------ KeyError Cannot find the emoji based on the text. ''' ret = emoji . emojize ( discord_text , language = \"alias\" ) if ret == discord_text : raise KeyError ( f \"Emoji { discord_text } cannot be found.\" ) return ret get_friendly_permissions get_friendly_permissions ( / , permissions : hikari . Permissions ) -> t . List [ str ] Return a list of highlighted permissions string presented in the permission provided. This returns the exact Discord's string of the permission. Parameters: Name Type Description Default permissions hikari . Permissions A permission object. required Returns: Type Description t . List [ str ] A list of highlighted permissions string represented in the permission provided. Notes Manage Events cannot be found in Hikari's documentation. Therefore, it is not included. Source code in utils\\helpers.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 def get_friendly_permissions ( permissions : hikari . Permissions , / ) -> t . List [ str ]: '''Return a list of highlighted permissions string presented in the permission provided. This returns the exact Discord's string of the permission. Parameters ---------- permissions : hikari.Permissions A permission object. Returns ------- t.List[str] A list of highlighted permissions string represented in the permission provided. Notes ----- `Manage Events` cannot be found in Hikari's documentation. Therefore, it is not included. ''' l = [] for permission , text in __PERMISSIONS_MAPPING__ . items (): if permissions & permission : l . append ( f \"` { text } `\" ) return l get_default_embed get_default_embed ( * , author : hikari . Member = None , ** kwargs ) -> hikari . Embed Return a default embed to work with for consistency. Args: author: The author to set in the footer. **kwargs: hikari.Embed constructor. Parameters: Name Type Description Default author hikari . Member , optional The author to set in the footer. If not provided, the footer will not be edited. None **kwargs dict The options passed into hikari.Embed() . {} Returns: Type Description hikari . Embed The default embed. Source code in utils\\helpers.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def get_default_embed ( * , author : hikari . Member = None , ** kwargs ) -> hikari . Embed : '''Return a default embed to work with for consistency. Args: author: The author to set in the footer. **kwargs: `hikari.Embed` constructor. Parameters ---------- author : hikari.Member, optional The author to set in the footer. If not provided, the footer will not be edited. **kwargs : dict The options passed into `hikari.Embed()`. Returns ------- hikari.Embed The default embed. ''' title = kwargs . get ( \"title\" ) url = kwargs . get ( \"url\" ) description = kwargs . get ( \"description\" ) color = kwargs . get ( \"color\" ) if kwargs . get ( \"color\" ) is not None else models . DefaultColor . green timestamp = kwargs . get ( \"timestamp\" ) embed = hikari . Embed ( title = title , url = url , description = description , color = color , timestamp = timestamp ) if author is not None : embed . set_footer ( text = f \"Requested by { author . username } \" , icon = author . avatar_url ) return embed mention mention ( / , mentionable_object : t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ]) -> str Return the appropriate mention string for a mentionable object. Parameters: Name Type Description Default mentionable_object t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ] The object to mention. required Returns: Type Description str The object's default mention string. Notes If the object is a hikari.PartialRole and it has the name @everyone , it'll return the name directly. Source code in utils\\helpers.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 def mention ( mentionable_object : t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ], / ) -> str : '''Return the appropriate mention string for a mentionable object. Parameters ---------- mentionable_object : t.Union[hikari.PartialUser, hikari.PartialRole, hikari.TextableGuildChannel] The object to mention. Returns ------- str The object's default mention string. Notes ----- If the object is a `hikari.PartialRole` and it has the name `@everyone`, it'll return the name directly. ''' if isinstance ( mentionable_object , hikari . PartialRole ): if mentionable_object . name == \"@everyone\" : return mentionable_object . name return mentionable_object . mention sleep_until async sleep_until ( / , when : dt . datetime ) Wait until the specified time. Parameters: Name Type Description Default when dt . datetime The time to resume. Must be tz aware and in utc. required Source code in utils\\helpers.py 334 335 336 337 338 339 340 341 342 343 344 async def sleep_until ( when : dt . datetime , / ): '''Wait until the specified time. Parameters ---------- when : dt.datetime The time to resume. Must be tz aware and in utc. ''' time = when - dt . datetime . now () . astimezone () if time . total_seconds () > 0 : await asyncio . sleep ( time . total_seconds ()) striplist striplist ( / , arr : t . Sequence [ str ]) -> str Return a string from a list, separated by comma. Parameters: Name Type Description Default arr t . Sequence [ str ] A sequence of objects that are convertible to str . required Returns: Type Description str The final string. Empty if sequence is empty. Source code in utils\\helpers.py 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def striplist ( arr : t . Sequence [ str ], / ) -> str : '''Return a string from a list, separated by comma. Parameters ---------- arr : t.Sequence[str] A sequence of objects that are convertible to `str`. Returns ------- str The final string. Empty if sequence is empty. ''' return \", \" . join ( arr )","title":"helpers.py"},{"location":"dev/helpers/#utils.helpers.embed_from_dict","text":"embed_from_dict ( / , data : dict [ str , t . Any ]) -> hikari . Embed Generate an embed from a dictionary. Parameters: Name Type Description Default data dict [ str , t . Any ] A valid dict representation of an embed. required Returns: Type Description hikari . Embed The embed from the dict. Source code in utils\\helpers.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def embed_from_dict ( data : dict [ str , t . Any ], / ) -> hikari . Embed : '''Generate an embed from a dictionary. Parameters ---------- data : dict[str, t.Any] A valid dict representation of an embed. Returns ------- hikari.Embed The embed from the dict. ''' embed = hikari . Embed () embed . title = data . get ( \"title\" , None ) embed . description = data . get ( \"description\" , None ) embed . url = data . get ( \"url\" , None ) if embed . title is not None : embed . title = str ( embed . title ) if embed . description is not None : embed . description = str ( embed . description ) if embed . url is not None : embed . url = str ( embed . url ) try : embed . color = hikari . Color ( data [ \"color\" ]) except KeyError : pass try : embed . timestamp = dt . datetime . fromtimestamp ( data [ 'timestamp' ], tz = dt . timezone . utc ) except KeyError : pass try : value = data [ \"thumbnail\" ] except KeyError : pass else : embed . set_thumbnail ( value ) try : value = data [ \"author\" ] except KeyError : pass else : embed . set_author ( ** value ) try : value = data [ \"fields\" ] except KeyError : pass else : for field in value : embed . add_field ( ** field ) try : value = data [ \"image\" ] except KeyError : pass else : embed . set_image ( value ) try : value = data [ \"footer\" ] except KeyError : pass else : embed . set_footer ( ** value ) return embed","title":"embed_from_dict()"},{"location":"dev/helpers/#utils.helpers.embed_to_dict","text":"embed_to_dict ( / , embed : hikari . Embed ) -> dict [ str , t . Any ] Convert an embed into a dict object. Parameters: Name Type Description Default embed hikari . Embed An embed object to convert. required Returns: Type Description dict [ str , t . Any ] A dictionary that conforms Discord's structure. Source code in utils\\helpers.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def embed_to_dict ( embed : hikari . Embed , / ) -> dict [ str , t . Any ]: '''Convert an embed into a dict object. Parameters ---------- embed : hikari.Embed An embed object to convert. Returns ------- dict[str, t.Any] A dictionary that conforms Discord's structure. ''' d = {} if bool ( embed . title ): d [ \"title\" ] = embed . title if bool ( embed . description ): d [ \"description\" ] = embed . description if bool ( embed . url ): d [ \"url\" ] = embed . url if bool ( embed . color ): d [ \"color\" ] = int ( embed . color ) if bool ( embed . timestamp ): d [ \"timestamp\" ] = embed . timestamp . timestamp () if bool ( embed . thumbnail ): d [ \"thumbnail\" ] = embed . thumbnail . url if bool ( embed . author ): d [ \"author\" ] = { \"name\" : embed . author . name , \"url\" : embed . author . url } if bool ( embed . author . icon ): d [ \"author\" ][ \"icon\" ] = embed . author . icon . url if bool ( embed . fields ): d [ \"fields\" ] = [] for field in embed . fields : d [ \"fields\" ] . append ({ \"name\" : field . name , \"value\" : field . value , \"inline\" : field . is_inline }) if bool ( embed . image ): d [ \"image\" ] = embed . image . url if bool ( embed . footer ): d [ \"footer\" ] = { \"text\" : embed . footer . text } if bool ( embed . footer . icon ): d [ \"footer\" ][ \"icon\" ] = embed . footer . icon . url return d","title":"embed_to_dict()"},{"location":"dev/helpers/#utils.helpers.get_emote","text":"get_emote ( / , discord_text : str ) -> str Return the Unicode emoji based on the name provided. Parameters: Name Type Description Default discord_text str Discord/Twitter name of the emoji including : . Example: :grin: . required Returns: Type Description str The Unicode emoji matching the text. Raises: Type Description KeyError Cannot find the emoji based on the text. Source code in utils\\helpers.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def get_emote ( discord_text : str , / ) -> str : '''Return the Unicode emoji based on the name provided. Parameters ---------- discord_text : str Discord/Twitter name of the emoji including `:`. Example: `:grin:`. Returns ------- str The Unicode emoji matching the text. Raises ------ KeyError Cannot find the emoji based on the text. ''' ret = emoji . emojize ( discord_text , language = \"alias\" ) if ret == discord_text : raise KeyError ( f \"Emoji { discord_text } cannot be found.\" ) return ret","title":"get_emote()"},{"location":"dev/helpers/#utils.helpers.get_friendly_permissions","text":"get_friendly_permissions ( / , permissions : hikari . Permissions ) -> t . List [ str ] Return a list of highlighted permissions string presented in the permission provided. This returns the exact Discord's string of the permission. Parameters: Name Type Description Default permissions hikari . Permissions A permission object. required Returns: Type Description t . List [ str ] A list of highlighted permissions string represented in the permission provided.","title":"get_friendly_permissions()"},{"location":"dev/helpers/#utils.helpers.get_friendly_permissions--notes","text":"Manage Events cannot be found in Hikari's documentation. Therefore, it is not included. Source code in utils\\helpers.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 def get_friendly_permissions ( permissions : hikari . Permissions , / ) -> t . List [ str ]: '''Return a list of highlighted permissions string presented in the permission provided. This returns the exact Discord's string of the permission. Parameters ---------- permissions : hikari.Permissions A permission object. Returns ------- t.List[str] A list of highlighted permissions string represented in the permission provided. Notes ----- `Manage Events` cannot be found in Hikari's documentation. Therefore, it is not included. ''' l = [] for permission , text in __PERMISSIONS_MAPPING__ . items (): if permissions & permission : l . append ( f \"` { text } `\" ) return l","title":"Notes"},{"location":"dev/helpers/#utils.helpers.get_default_embed","text":"get_default_embed ( * , author : hikari . Member = None , ** kwargs ) -> hikari . Embed Return a default embed to work with for consistency. Args: author: The author to set in the footer. **kwargs: hikari.Embed constructor. Parameters: Name Type Description Default author hikari . Member , optional The author to set in the footer. If not provided, the footer will not be edited. None **kwargs dict The options passed into hikari.Embed() . {} Returns: Type Description hikari . Embed The default embed. Source code in utils\\helpers.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def get_default_embed ( * , author : hikari . Member = None , ** kwargs ) -> hikari . Embed : '''Return a default embed to work with for consistency. Args: author: The author to set in the footer. **kwargs: `hikari.Embed` constructor. Parameters ---------- author : hikari.Member, optional The author to set in the footer. If not provided, the footer will not be edited. **kwargs : dict The options passed into `hikari.Embed()`. Returns ------- hikari.Embed The default embed. ''' title = kwargs . get ( \"title\" ) url = kwargs . get ( \"url\" ) description = kwargs . get ( \"description\" ) color = kwargs . get ( \"color\" ) if kwargs . get ( \"color\" ) is not None else models . DefaultColor . green timestamp = kwargs . get ( \"timestamp\" ) embed = hikari . Embed ( title = title , url = url , description = description , color = color , timestamp = timestamp ) if author is not None : embed . set_footer ( text = f \"Requested by { author . username } \" , icon = author . avatar_url ) return embed","title":"get_default_embed()"},{"location":"dev/helpers/#utils.helpers.mention","text":"mention ( / , mentionable_object : t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ]) -> str Return the appropriate mention string for a mentionable object. Parameters: Name Type Description Default mentionable_object t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ] The object to mention. required Returns: Type Description str The object's default mention string.","title":"mention()"},{"location":"dev/helpers/#utils.helpers.mention--notes","text":"If the object is a hikari.PartialRole and it has the name @everyone , it'll return the name directly. Source code in utils\\helpers.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 def mention ( mentionable_object : t . Union [ hikari . PartialUser , hikari . PartialRole , hikari . TextableGuildChannel ], / ) -> str : '''Return the appropriate mention string for a mentionable object. Parameters ---------- mentionable_object : t.Union[hikari.PartialUser, hikari.PartialRole, hikari.TextableGuildChannel] The object to mention. Returns ------- str The object's default mention string. Notes ----- If the object is a `hikari.PartialRole` and it has the name `@everyone`, it'll return the name directly. ''' if isinstance ( mentionable_object , hikari . PartialRole ): if mentionable_object . name == \"@everyone\" : return mentionable_object . name return mentionable_object . mention","title":"Notes"},{"location":"dev/helpers/#utils.helpers.sleep_until","text":"sleep_until ( / , when : dt . datetime ) Wait until the specified time. Parameters: Name Type Description Default when dt . datetime The time to resume. Must be tz aware and in utc. required Source code in utils\\helpers.py 334 335 336 337 338 339 340 341 342 343 344 async def sleep_until ( when : dt . datetime , / ): '''Wait until the specified time. Parameters ---------- when : dt.datetime The time to resume. Must be tz aware and in utc. ''' time = when - dt . datetime . now () . astimezone () if time . total_seconds () > 0 : await asyncio . sleep ( time . total_seconds ())","title":"sleep_until()"},{"location":"dev/helpers/#utils.helpers.striplist","text":"striplist ( / , arr : t . Sequence [ str ]) -> str Return a string from a list, separated by comma. Parameters: Name Type Description Default arr t . Sequence [ str ] A sequence of objects that are convertible to str . required Returns: Type Description str The final string. Empty if sequence is empty. Source code in utils\\helpers.py 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def striplist ( arr : t . Sequence [ str ], / ) -> str : '''Return a string from a list, separated by comma. Parameters ---------- arr : t.Sequence[str] A sequence of objects that are convertible to `str`. Returns ------- str The final string. Empty if sequence is empty. ''' return \", \" . join ( arr )","title":"striplist()"},{"location":"dev/menu/","text":"nav/navigator.py Contains common forms of menu navigator. StopButtonDelete Bases: nav . StopButton A custom button to stop the navigator AND delete the message. This button should only be used in nav.NavigatorView . Source code in utils\\nav\\navigator.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class StopButtonDelete ( nav . StopButton ): ''' A custom button to stop the navigator AND delete the message. This button should only be used in `nav.NavigatorView`. ''' async def callback ( self , context : miru . Context ) -> None : # Reference: https://github.com/HyperGH/hikari-miru/blob/main/miru/ext/nav/buttons.py#L239 #pylint: disable=protected-access view : nav . NavigatorView = self . view if not view . message and not view . _inter : return if view . _inter and view . ephemeral : await view . _inter . delete_initial_response () elif view . message : await view . message . delete () #pylint: enable=protected-access view . stop () ButtonNavigator Bases: nav . NavigatorView The default navigator. Source code in utils\\nav\\navigator.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 class ButtonNavigator ( nav . NavigatorView ): ''' The default navigator. ''' def __init__ ( self , * args , ** kwargs ) -> None : super () . __init__ ( * args , ** kwargs ) for index , item in enumerate ( self . pages ): if isinstance ( item , hikari . Embed ): item . set_footer ( f \"Page { index + 1 } / { len ( self . pages ) } \" ) def get_default_buttons ( self ) -> t . List [ nav . NavButton [ nav . NavigatorView ]]: ''' Returns a list of default buttons. These are `FirstButton()`, `PrevButton()`, `NextButton()`, `LastButton()`, and `StopButtonDelete()`. Returns ------- t.List[nav.NavButton[nav.NavigatorView]] A list of default buttons. ''' return [ nav . FirstButton (), nav . PrevButton (), nav . NextButton (), nav . LastButton (), StopButtonDelete ()] async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout () get_default_buttons get_default_buttons () -> t . List [ nav . NavButton [ nav . NavigatorView ]] Returns a list of default buttons. These are FirstButton() , PrevButton() , NextButton() , LastButton() , and StopButtonDelete() . Returns: Type Description t . List [ nav . NavButton [ nav . NavigatorView ]] A list of default buttons. Source code in utils\\nav\\navigator.py 100 101 102 103 104 105 106 107 108 109 110 111 def get_default_buttons ( self ) -> t . List [ nav . NavButton [ nav . NavigatorView ]]: ''' Returns a list of default buttons. These are `FirstButton()`, `PrevButton()`, `NextButton()`, `LastButton()`, and `StopButtonDelete()`. Returns ------- t.List[nav.NavButton[nav.NavigatorView]] A list of default buttons. ''' return [ nav . FirstButton (), nav . PrevButton (), nav . NextButton (), nav . LastButton (), StopButtonDelete ()] on_timeout async on_timeout () -> None Called when the view times out. Notes This adds the timeout button into the menu. Source code in utils\\nav\\navigator.py 113 114 115 116 117 118 119 120 121 122 async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout () ItemListBuilder A builder to fit a list of item into a navigator appropriately. (This is experimental and can be removed at any time). Source code in utils\\nav\\navigator.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 class ItemListBuilder : '''A builder to fit a list of item into a navigator appropriately. (This is experimental and can be removed at any time).''' def __init__ ( self , items : list [ T ], max_item_per_page : int ): '''Construct the builder. Parameters ---------- items : list[T] A list of items. max_item_per_page : int The max amount of item to display before moving to a new page. ''' self . items = items self . max_item = max_item_per_page self . page_start_formatter : t . Callable [[ int , T ], hikari . Embed ] = None self . entry_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = None self . page_end_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = lambda embed , index , item : None def set_page_start_formatter ( self , callback : t . Callable [[ int , T ], hikari . Embed ], / ): '''Set this callback as the formatter to run whenever a new page is requested to be created. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[int, T], hikari.Embed] The callback to use. It must accept an `int` (index of the item), the item itself, and return a `hikari.Embed`. ''' self . page_start_formatter = callback def set_entry_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run while iterating through the item list. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . entry_formatter = callback def set_page_end_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run once adding items to a page is finished. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . page_end_formatter = callback def build ( self , * , page_type = ButtonNavigator ): '''Start the formatting process and return an object of `page_type`. Warnings -------- The builder must provide at least `page_start_formatter` and either `entry_formatter` or `page_end_formatter` before this method is called. Parameters ---------- page_type : t.Type, optional The type of navigator to use, by default ButtonNavigator. This must have a `pages` argument accepting a list of `hikari.Embed`. Returns ------- t.Any The type passed into the constructor, by default ButtonNavigator. Raises ------ NotImplementedError `page_start_formatter` is empty or both `entry_formatter` and `page_end_formatter` are empty. ''' if self . page_start_formatter is None or ( self . entry_formatter is None and self . page_end_formatter is None ): raise NotImplementedError ( \"Not enough formatters are defined.\" ) embeds : list [ hikari . Embed ] = [] embed : hikari . Embed = None for index , item in enumerate ( self . items ): if embed is None : embed = self . page_start_formatter ( index , item ) self . entry_formatter ( embed , index , item ) if index % self . max_item == self . max_item - 1 : self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) embed = None if embed is not None : # TODO: Fix undefined-loop-variable self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) return page_type ( pages = embeds ) __init__ __init__ ( items : list [ T ], max_item_per_page : int ) Construct the builder. Parameters: Name Type Description Default items list [ T ] A list of items. required max_item_per_page int The max amount of item to display before moving to a new page. required Source code in utils\\nav\\navigator.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def __init__ ( self , items : list [ T ], max_item_per_page : int ): '''Construct the builder. Parameters ---------- items : list[T] A list of items. max_item_per_page : int The max amount of item to display before moving to a new page. ''' self . items = items self . max_item = max_item_per_page self . page_start_formatter : t . Callable [[ int , T ], hikari . Embed ] = None self . entry_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = None self . page_end_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = lambda embed , index , item : None set_page_start_formatter set_page_start_formatter ( / , callback : t . Callable [[ int , T ], hikari . Embed ]) Set this callback as the formatter to run whenever a new page is requested to be created. Notes This is recommended to use as a decorator. Parameters: Name Type Description Default callback t . Callable [[ int , T ], hikari . Embed ] The callback to use. It must accept an int (index of the item), the item itself, and return a hikari.Embed . required Source code in utils\\nav\\navigator.py 144 145 146 147 148 149 150 151 152 153 154 155 156 def set_page_start_formatter ( self , callback : t . Callable [[ int , T ], hikari . Embed ], / ): '''Set this callback as the formatter to run whenever a new page is requested to be created. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[int, T], hikari.Embed] The callback to use. It must accept an `int` (index of the item), the item itself, and return a `hikari.Embed`. ''' self . page_start_formatter = callback set_entry_formatter set_entry_formatter ( / , callback : t . Callable [[ hikari . Embed , int , T ], None ]) Set this callback as the formatter to run while iterating through the item list. Notes This is recommended to use as a decorator. Parameters: Name Type Description Default callback t . Callable [[ hikari . Embed , int , T ], None] The callback to use. It must accept a hikari.Embed (the page it's editing), an int (index of the item), and the item itself. required Source code in utils\\nav\\navigator.py 157 158 159 160 161 162 163 164 165 166 167 168 169 def set_entry_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run while iterating through the item list. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . entry_formatter = callback set_page_end_formatter set_page_end_formatter ( / , callback : t . Callable [[ hikari . Embed , int , T ], None ]) Set this callback as the formatter to run once adding items to a page is finished. Notes This is recommended to use as a decorator. Parameters: Name Type Description Default callback t . Callable [[ hikari . Embed , int , T ], None] The callback to use. It must accept a hikari.Embed (the page it's editing), an int (index of the item), and the item itself. required Source code in utils\\nav\\navigator.py 170 171 172 173 174 175 176 177 178 179 180 181 182 def set_page_end_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run once adding items to a page is finished. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . page_end_formatter = callback build build ( * , page_type = ButtonNavigator ) Start the formatting process and return an object of page_type . Warnings The builder must provide at least page_start_formatter and either entry_formatter or page_end_formatter before this method is called. Parameters: Name Type Description Default page_type t . Type , optional The type of navigator to use, by default ButtonNavigator. This must have a pages argument accepting a list of hikari.Embed . ButtonNavigator Returns: Type Description t . Any The type passed into the constructor, by default ButtonNavigator. Raises: Type Description NotImplementedError page_start_formatter is empty or both entry_formatter and page_end_formatter are empty. Source code in utils\\nav\\navigator.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def build ( self , * , page_type = ButtonNavigator ): '''Start the formatting process and return an object of `page_type`. Warnings -------- The builder must provide at least `page_start_formatter` and either `entry_formatter` or `page_end_formatter` before this method is called. Parameters ---------- page_type : t.Type, optional The type of navigator to use, by default ButtonNavigator. This must have a `pages` argument accepting a list of `hikari.Embed`. Returns ------- t.Any The type passed into the constructor, by default ButtonNavigator. Raises ------ NotImplementedError `page_start_formatter` is empty or both `entry_formatter` and `page_end_formatter` are empty. ''' if self . page_start_formatter is None or ( self . entry_formatter is None and self . page_end_formatter is None ): raise NotImplementedError ( \"Not enough formatters are defined.\" ) embeds : list [ hikari . Embed ] = [] embed : hikari . Embed = None for index , item in enumerate ( self . items ): if embed is None : embed = self . page_start_formatter ( index , item ) self . entry_formatter ( embed , index , item ) if index % self . max_item == self . max_item - 1 : self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) embed = None if embed is not None : # TODO: Fix undefined-loop-variable self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) return page_type ( pages = embeds ) run_view async run_view ( view : miru . View , ctx : lightbulb . Context , initial_content : t . Union [ str , hikari . Embed ] = None ) -> None A simplified way to run a miru.View . Parameters: Name Type Description Default view miru . View A miru.View or its subclasses. required ctx lightbulb . Context A context to send the view. required initial_content t . Union [ str , hikari . Embed ], optional The content to first display. This is optional for nav.NavigatorView and its subclasses. None Raises: Type Description TypeError initial_content is not provided, but view is not type nav.NavigatorView . hikari . BadRequestError Maybe ctx is deferred. Source code in utils\\nav\\navigator.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 async def run_view ( view : miru . View , ctx : lightbulb . Context , initial_content : t . Union [ str , hikari . Embed ] = None ) -> None : '''A simplified way to run a `miru.View`. Parameters ---------- view : miru.View A `miru.View` or its subclasses. ctx : lightbulb.Context A context to send the view. initial_content : t.Union[str, hikari.Embed], optional The content to first display. This is optional for `nav.NavigatorView` and its subclasses. Raises ------ TypeError `initial_content` is not provided, but `view` is not type `nav.NavigatorView`. hikari.BadRequestError Maybe `ctx` is deferred. ''' if initial_content is None : if isinstance ( view , nav . NavigatorView ): # nav.NavigatorView cannot be run on an interaction with a response already (typically deferring) # so we have to do things manually here. # Reference: https://github.com/HyperGH/hikari-miru/blob/main/miru/ext/nav/navigator.py#L227 for button in view . children : if isinstance ( button , nav . NavButton ): await button . before_page_change () initial_content = view . pages [ view . current_page ] #await view.send(ctx.interaction) #return else : raise TypeError ( \"'initial_content' must be provided if 'view' is not type 'NavigatorView'.\" ) resp_proxy = await ctx . respond ( initial_content , components = view . build ()) view . start ( await resp_proxy . message ()) await view . wait () timeout_button timeout_button () -> nav . NavButton Return a nav.NavButton to be use in nav.NavigatorView . This button is safe to use in miru.View . Returns: Type Description nav . NavButton The default timeout button. Source code in utils\\nav\\navigator.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def timeout_button () -> nav . NavButton : '''Return a `nav.NavButton` to be use in `nav.NavigatorView`. This button is safe to use in `miru.View`. Returns ------- nav.NavButton The default timeout button. ''' return nav . NavButton ( style = hikari . ButtonStyle . SECONDARY , emoji = helpers . get_emote ( \":clock12:\" ), custom_id = \"timeout_button\" , disabled = True ) nav/confirm.py Contains a confirmation menu. ConfirmView Bases: miru . View A confirmation menu. Source code in utils\\nav\\confirm.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class ConfirmView ( miru . View ): ''' A confirmation menu. ''' def __init__ ( self , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None : super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . result : t . Optional [ bool ] = None @miru . button ( label = \"Yes\" , emoji = helpers . get_emote ( \":white_check_mark:\" ), style = hikari . ButtonStyle . SUCCESS , custom_id = \"yes_button\" ) async def yes_button ( self , _ : miru . Button , __ : miru . Context ): self . result = True self . stop () @miru . button ( label = \"No\" , emoji = helpers . get_emote ( \":negative_squared_cross_mark:\" ), style = hikari . ButtonStyle . DANGER , custom_id = \"no_button\" ) async def no_button ( self , _ : miru . Button , __ : miru . Context ): self . result = False self . stop () async def wait ( self ) -> t . Optional [ bool ]: ''' Wait until the view times out or stops manually. Return the result of the confirmation, or `None` if it times out. ''' await super () . wait () await self . message . delete () return self . result wait async wait () -> t . Optional [ bool ] Wait until the view times out or stops manually. Return the result of the confirmation, or None if it times out. Source code in utils\\nav\\confirm.py 28 29 30 31 32 33 34 35 36 37 async def wait ( self ) -> t . Optional [ bool ]: ''' Wait until the view times out or stops manually. Return the result of the confirmation, or `None` if it times out. ''' await super () . wait () await self . message . delete () return self . result nav/menu.py Contains everything needed to build a complex menu. MenuComponent A tree-like node that represents the menu's option structure. The node has two \"states\": a regular node state and a fake node. A regular node state is when the options is a dictionary, which will determine the child nodes. A fake node state is when the options is a list of contents to display. In this case, the node's content is set to None , and no further child nodes can be created from this node. The child nodes can be accessed using dictionary notation IF there are child nodes. Source code in utils\\nav\\menu.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class MenuComponent : ''' A tree-like node that represents the menu's option structure. The node has two \"states\": a regular node state and a fake node. A regular node state is when the `options` is a dictionary, which will determine the child nodes. A fake node state is when the `options` is a list of contents to display. In this case, the node's content is set to `None`, and no further child nodes can be created from this node. The child nodes can be accessed using dictionary notation IF there are child nodes. ''' def __init__ ( self , content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ): ''' Create a node that stores the content and optionally, its options. The `options` can be a list, which will set the content to `None` regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a `dict` through `options`, but instead, use `.add_options()`. ''' self . content = content self . options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = options self . __parent__ : t . Optional [ MenuComponent ] = None if isinstance ( self . options , list ): self . content = None def add_option ( self , key : MenuButton , content : PageLike ) -> MenuComponent : '''Add an option into the current node. Return the newly added node to further add more layers. Warnings -------- The returned object is the newly added object, not the current object. Parameters ---------- key : MenuButton The button for the new option. content : PageLike The content of the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. ''' if isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) if self . options is None : self . options = { key : MenuComponent ( content )} self . options [ key ] . __parent__ = self return self . options [ key ] elif self . options . get ( key ) is None : component = MenuComponent ( content ) component . __parent__ = self self . options [ key ] = component return self . options [ key ] else : raise LookupError ( \"Duplicated keys.\" ) def add_options ( self , options : t . Dict [ MenuButton , PageLike ]): '''Add multiple options into the current node. Warnings -------- This will overwrite any possible duplicate keys. Parameters ---------- options : t.Dict[MenuButton, PageLike] A mapping of {button: content}. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) for key in options : self . options [ key ] = MenuComponent ( options [ key ]) self . options [ key ] . __parent__ = self def add_list_options ( self , key : str , contents : t . List [ PageLike ]) -> MenuComponent : '''Append a fake node to this node. Return the newly added node to do whatever you want. Parameters ---------- key : str The button for the new option. contents : t.List[PageLike] A list of content for the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) component = None if len ( contents ) == 1 : component = MenuComponent ( content = contents [ 0 ]) else : component = MenuComponent ( content = None , options = contents ) component . __parent__ = self self . options [ key ] = component return component def force_add_list_options ( self , contents : t . List [ PageLike ]): '''Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters ---------- contents : t.List[PageLike] A list of content for the option. ''' if self . options is None : self . options = [] for content in contents : self . options . append ( content ) self . content = None def __getitem__ ( self , key : MenuButton ) -> t . Optional [ MenuComponent ]: '''Return the MenuComponent with the matching key, or `None` if none was found. Parameters ---------- key : MenuButton The option you're retrieving. Returns ------- t.Optional[MenuComponent] The option with matching key, or `None` if none was found. Raises ------ IndexError The current MenuComponent is already a fake node. ''' if isinstance ( self . options , dict ): return self . options . get ( key ) raise IndexError ( \"Index doesn't exist.\" ) __init__ __init__ ( content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ) Create a node that stores the content and optionally, its options. The options can be a list, which will set the content to None regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a dict through options , but instead, use .add_options() . Source code in utils\\nav\\menu.py 26 27 28 29 30 31 32 33 34 35 36 37 38 def __init__ ( self , content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ): ''' Create a node that stores the content and optionally, its options. The `options` can be a list, which will set the content to `None` regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a `dict` through `options`, but instead, use `.add_options()`. ''' self . content = content self . options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = options self . __parent__ : t . Optional [ MenuComponent ] = None if isinstance ( self . options , list ): self . content = None add_option add_option ( key : MenuButton , content : PageLike ) -> MenuComponent Add an option into the current node. Return the newly added node to further add more layers. Warnings The returned object is the newly added object, not the current object. Parameters: Name Type Description Default key MenuButton The button for the new option. required content PageLike The content of the new option. required Returns: Type Description MenuComponent The newly added option. Raises: Type Description KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. Source code in utils\\nav\\menu.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def add_option ( self , key : MenuButton , content : PageLike ) -> MenuComponent : '''Add an option into the current node. Return the newly added node to further add more layers. Warnings -------- The returned object is the newly added object, not the current object. Parameters ---------- key : MenuButton The button for the new option. content : PageLike The content of the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. ''' if isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) if self . options is None : self . options = { key : MenuComponent ( content )} self . options [ key ] . __parent__ = self return self . options [ key ] elif self . options . get ( key ) is None : component = MenuComponent ( content ) component . __parent__ = self self . options [ key ] = component return self . options [ key ] else : raise LookupError ( \"Duplicated keys.\" ) add_options add_options ( options : t . Dict [ MenuButton , PageLike ]) Add multiple options into the current node. Warnings This will overwrite any possible duplicate keys. Parameters: Name Type Description Default options t . Dict [ MenuButton , PageLike ] A mapping of {button: content}. required Raises: Type Description KeyError The current MenuComponent is already a fake node. Source code in utils\\nav\\menu.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def add_options ( self , options : t . Dict [ MenuButton , PageLike ]): '''Add multiple options into the current node. Warnings -------- This will overwrite any possible duplicate keys. Parameters ---------- options : t.Dict[MenuButton, PageLike] A mapping of {button: content}. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) for key in options : self . options [ key ] = MenuComponent ( options [ key ]) self . options [ key ] . __parent__ = self add_list_options add_list_options ( key : str , contents : t . List [ PageLike ]) -> MenuComponent Append a fake node to this node. Return the newly added node to do whatever you want. Parameters: Name Type Description Default key str The button for the new option. required contents t . List [ PageLike ] A list of content for the new option. required Returns: Type Description MenuComponent The newly added option. Raises: Type Description KeyError The current MenuComponent is already a fake node. Source code in utils\\nav\\menu.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def add_list_options ( self , key : str , contents : t . List [ PageLike ]) -> MenuComponent : '''Append a fake node to this node. Return the newly added node to do whatever you want. Parameters ---------- key : str The button for the new option. contents : t.List[PageLike] A list of content for the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) component = None if len ( contents ) == 1 : component = MenuComponent ( content = contents [ 0 ]) else : component = MenuComponent ( content = None , options = contents ) component . __parent__ = self self . options [ key ] = component return component force_add_list_options force_add_list_options ( contents : t . List [ PageLike ]) Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters: Name Type Description Default contents t . List [ PageLike ] A list of content for the option. required Source code in utils\\nav\\menu.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def force_add_list_options ( self , contents : t . List [ PageLike ]): '''Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters ---------- contents : t.List[PageLike] A list of content for the option. ''' if self . options is None : self . options = [] for content in contents : self . options . append ( content ) self . content = None __getitem__ __getitem__ ( key : MenuButton ) -> t . Optional [ MenuComponent ] Return the MenuComponent with the matching key, or None if none was found. Parameters: Name Type Description Default key MenuButton The option you're retrieving. required Returns: Type Description t . Optional [ MenuComponent ] The option with matching key, or None if none was found. Raises: Type Description IndexError The current MenuComponent is already a fake node. Source code in utils\\nav\\menu.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def __getitem__ ( self , key : MenuButton ) -> t . Optional [ MenuComponent ]: '''Return the MenuComponent with the matching key, or `None` if none was found. Parameters ---------- key : MenuButton The option you're retrieving. Returns ------- t.Optional[MenuComponent] The option with matching key, or `None` if none was found. Raises ------ IndexError The current MenuComponent is already a fake node. ''' if isinstance ( self . options , dict ): return self . options . get ( key ) raise IndexError ( \"Index doesn't exist.\" ) MenuButton Bases: miru . Button Represents a generic button inside ComplexView . This should only be used in ComplexView . Source code in utils\\nav\\menu.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 class MenuButton ( miru . Button ): '''Represents a generic button inside `ComplexView`. This should only be used in `ComplexView`.''' async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the option if the current `MenuComponent` is not a fake node. ''' view : ComplexView = self . view if isinstance ( view . menu . options , dict ): view . menu = view . menu . options [ self ] await view . update () callback async callback ( _ : miru . Context ) -> None Calls when the button is pressed. It'll move to the option if the current MenuComponent is not a fake node. Source code in utils\\nav\\menu.py 186 187 188 189 190 191 192 193 194 195 196 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the option if the current `MenuComponent` is not a fake node. ''' view : ComplexView = self . view if isinstance ( view . menu . options , dict ): view . menu = view . menu . options [ self ] await view . update () ReturnMenuButton Bases: MenuButton Represents a return button. Source code in utils\\nav\\menu.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 class ReturnMenuButton ( MenuButton ): '''Represents a return button.''' def __init__ ( self ) -> None : super () . __init__ ( style = hikari . ButtonStyle . SECONDARY , emoji = helpers . get_emote ( \":arrow_up_small:\" ), custom_id = \"return_button\" ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the parent node if it is not `None`. Raises ------ RuntimeError The return button is in the root menu. ''' view : ComplexView = self . view if view . menu . __parent__ is not None : view . menu = view . menu . __parent__ view . current_page = 0 else : raise RuntimeError ( \"A return button is available in the root menu.\" ) await view . update () callback async callback ( _ : miru . Context ) -> None Calls when the button is pressed. It'll move to the parent node if it is not None . Raises: Type Description RuntimeError The return button is in the root menu. Source code in utils\\nav\\menu.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the parent node if it is not `None`. Raises ------ RuntimeError The return button is in the root menu. ''' view : ComplexView = self . view if view . menu . __parent__ is not None : view . menu = view . menu . __parent__ view . current_page = 0 else : raise RuntimeError ( \"A return button is available in the root menu.\" ) await view . update () StopMenuButton Bases: MenuButton Represents a terminate button. Source code in utils\\nav\\menu.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 class StopMenuButton ( MenuButton ): '''Represents a terminate button.''' def __init__ ( self ) -> None : super () . __init__ ( style = hikari . ButtonStyle . DANGER , emoji = helpers . get_emote ( \":stop_button:\" ), custom_id = \"stop_button\" ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll stop the `ComplexView` and delete the menu. ''' view : ComplexView = self . view view . stop () if view . message : await view . message . delete () callback async callback ( _ : miru . Context ) -> None Calls when the button is pressed. It'll stop the ComplexView and delete the menu. Source code in utils\\nav\\menu.py 236 237 238 239 240 241 242 243 244 245 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll stop the `ComplexView` and delete the menu. ''' view : ComplexView = self . view view . stop () if view . message : await view . message . delete () NextMenuButton Bases: MenuButton A button to move to the next page list. This behaves similarly to nav.NextButton() . Source code in utils\\nav\\menu.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 class NextMenuButton ( MenuButton ): '''A button to move to the next page list. This behaves similarly to `nav.NextButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"next_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":arrow_forward:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. ''' view : ComplexView = self . view view . current_page += 1 if view . current_page > len ( view . menu . options ) - 1 : view . current_page = 0 await view . update () callback async callback ( _ : miru . Context ) -> None Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. Source code in utils\\nav\\menu.py 262 263 264 265 266 267 268 269 270 271 272 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. ''' view : ComplexView = self . view view . current_page += 1 if view . current_page > len ( view . menu . options ) - 1 : view . current_page = 0 await view . update () PrevMenuButton Bases: MenuButton A button to move to the previous page list. This behaves similarly to nav.PrevButton() . Source code in utils\\nav\\menu.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 class PrevMenuButton ( MenuButton ): '''A button to move to the previous page list. This behaves similarly to `nav.PrevButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"prev_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":arrow_backward:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. ''' view : ComplexView = self . view view . current_page -= 1 if view . current_page < 0 : view . current_page = len ( view . menu . options ) - 1 await view . update () callback async callback ( _ : miru . Context ) -> None Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. Source code in utils\\nav\\menu.py 289 290 291 292 293 294 295 296 297 298 299 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. ''' view : ComplexView = self . view view . current_page -= 1 if view . current_page < 0 : view . current_page = len ( view . menu . options ) - 1 await view . update () FirstMenuButton Bases: MenuButton A button to move to the first page list. This behaves similarly to nav.FirstButton() . Source code in utils\\nav\\menu.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 class FirstMenuButton ( MenuButton ): '''A button to move to the first page list. This behaves similarly to `nav.FirstButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"first_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":last_track_button:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the first page. ''' view : ComplexView = self . view view . current_page = 0 await view . update () callback async callback ( _ : miru . Context ) -> None Calls when the button is pressed. Move to the first page. Source code in utils\\nav\\menu.py 316 317 318 319 320 321 322 323 324 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the first page. ''' view : ComplexView = self . view view . current_page = 0 await view . update () LastMenuButton Bases: MenuButton A button to move to the last page list. This behaves similarly to nav.LastButton() . Source code in utils\\nav\\menu.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 class LastMenuButton ( MenuButton ): '''A button to move to the last page list. This behaves similarly to `nav.LastButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"last_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":next_track_button:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the last page. ''' view : ComplexView = self . view view . current_page = len ( view . menu . options ) - 1 await view . update () callback async callback ( _ : miru . Context ) -> None Calls when the button is pressed. Move to the last page. Source code in utils\\nav\\menu.py 341 342 343 344 345 346 347 348 349 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the last page. ''' view : ComplexView = self . view view . current_page = len ( view . menu . options ) - 1 await view . update () ComplexView Bases: miru . View A complex menu. Source code in utils\\nav\\menu.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 class ComplexView ( miru . View ): '''A complex menu.''' def __init__ ( self , menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None : '''Construct a complex menu. Parameters ---------- menu : MenuComponent A `MenuComponent` tree. This must be a root node. timeout : t.Optional[float], optional How long (in seconds) the menu should accept interactions. Default to `120`. autodefer : bool, optional Whether or not the menu should defer when possible. Default to `True`. ''' super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . menu = menu # For list menu self . current_page : int = 0 def _update_button ( self ) -> None : ''' Update the button based on the current menu state. ''' self . clear_items () if isinstance ( self . menu . options , dict ): for button in self . menu . options : self . add_item ( button ) elif isinstance ( self . menu . options , list ): # TODO: Might optimize this so it wouldn't reset the buttons. self . add_item ( FirstMenuButton ()) self . add_item ( PrevMenuButton ()) self . add_item ( NextMenuButton ()) self . add_item ( LastMenuButton ()) for index , item in enumerate ( self . menu . options ): if isinstance ( item , hikari . Embed ): item . set_footer ( f \"Page { index + 1 } / { len ( self . menu . options ) } \" ) if self . menu . __parent__ is None : self . add_item ( StopMenuButton ()) else : self . add_item ( ReturnMenuButton ()) async def update ( self ) -> None : '''Update the menu. This shouldn't be called by the user. Raises ------ RuntimeError The message is not found (for unknown reasons). Notes ----- All `MenuButton` should call this method inside their callbacks once it's done with everything. ''' self . _update_button () content = self . menu . content # If view is in a list menu. Can also check if menu.content is None instead. if isinstance ( self . menu . options , list ): content = self . menu . options [ self . current_page ] if self . message : await self . message . edit ( content , components = self . build ()) else : raise RuntimeError ( \"Oops ComplexView.update() failed.\" ) async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout () async def run ( self , ctx : lightbulb . Context ) -> None : '''Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters ---------- ctx : lightbulb.Context A `lightbulb` context. ''' self . _update_button () await run_view ( self , ctx , self . menu . content ) __init__ __init__ ( menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None Construct a complex menu. Parameters: Name Type Description Default menu MenuComponent A MenuComponent tree. This must be a root node. required timeout t . Optional [ float ], optional How long (in seconds) the menu should accept interactions. Default to 120 . 120 autodefer bool , optional Whether or not the menu should defer when possible. Default to True . True Source code in utils\\nav\\menu.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 def __init__ ( self , menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None : '''Construct a complex menu. Parameters ---------- menu : MenuComponent A `MenuComponent` tree. This must be a root node. timeout : t.Optional[float], optional How long (in seconds) the menu should accept interactions. Default to `120`. autodefer : bool, optional Whether or not the menu should defer when possible. Default to `True`. ''' super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . menu = menu # For list menu self . current_page : int = 0 update async update () -> None Update the menu. This shouldn't be called by the user. Raises: Type Description RuntimeError The message is not found (for unknown reasons). Notes All MenuButton should call this method inside their callbacks once it's done with everything. Source code in utils\\nav\\menu.py 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 async def update ( self ) -> None : '''Update the menu. This shouldn't be called by the user. Raises ------ RuntimeError The message is not found (for unknown reasons). Notes ----- All `MenuButton` should call this method inside their callbacks once it's done with everything. ''' self . _update_button () content = self . menu . content # If view is in a list menu. Can also check if menu.content is None instead. if isinstance ( self . menu . options , list ): content = self . menu . options [ self . current_page ] if self . message : await self . message . edit ( content , components = self . build ()) else : raise RuntimeError ( \"Oops ComplexView.update() failed.\" ) on_timeout async on_timeout () -> None Called when the view times out. Notes This adds the timeout button into the menu. Source code in utils\\nav\\menu.py 421 422 423 424 425 426 427 428 429 430 async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout () run async run ( ctx : lightbulb . Context ) -> None Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters: Name Type Description Default ctx lightbulb . Context A lightbulb context. required Source code in utils\\nav\\menu.py 432 433 434 435 436 437 438 439 440 441 442 443 444 async def run ( self , ctx : lightbulb . Context ) -> None : '''Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters ---------- ctx : lightbulb.Context A `lightbulb` context. ''' self . _update_button () await run_view ( self , ctx , self . menu . content )","title":"nav"},{"location":"dev/menu/#navnavigatorpy","text":"Contains common forms of menu navigator.","title":"nav/navigator.py"},{"location":"dev/menu/#utils.nav.navigator.StopButtonDelete","text":"Bases: nav . StopButton A custom button to stop the navigator AND delete the message. This button should only be used in nav.NavigatorView . Source code in utils\\nav\\navigator.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class StopButtonDelete ( nav . StopButton ): ''' A custom button to stop the navigator AND delete the message. This button should only be used in `nav.NavigatorView`. ''' async def callback ( self , context : miru . Context ) -> None : # Reference: https://github.com/HyperGH/hikari-miru/blob/main/miru/ext/nav/buttons.py#L239 #pylint: disable=protected-access view : nav . NavigatorView = self . view if not view . message and not view . _inter : return if view . _inter and view . ephemeral : await view . _inter . delete_initial_response () elif view . message : await view . message . delete () #pylint: enable=protected-access view . stop ()","title":"StopButtonDelete"},{"location":"dev/menu/#utils.nav.navigator.ButtonNavigator","text":"Bases: nav . NavigatorView The default navigator. Source code in utils\\nav\\navigator.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 class ButtonNavigator ( nav . NavigatorView ): ''' The default navigator. ''' def __init__ ( self , * args , ** kwargs ) -> None : super () . __init__ ( * args , ** kwargs ) for index , item in enumerate ( self . pages ): if isinstance ( item , hikari . Embed ): item . set_footer ( f \"Page { index + 1 } / { len ( self . pages ) } \" ) def get_default_buttons ( self ) -> t . List [ nav . NavButton [ nav . NavigatorView ]]: ''' Returns a list of default buttons. These are `FirstButton()`, `PrevButton()`, `NextButton()`, `LastButton()`, and `StopButtonDelete()`. Returns ------- t.List[nav.NavButton[nav.NavigatorView]] A list of default buttons. ''' return [ nav . FirstButton (), nav . PrevButton (), nav . NextButton (), nav . LastButton (), StopButtonDelete ()] async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout ()","title":"ButtonNavigator"},{"location":"dev/menu/#utils.nav.navigator.ButtonNavigator.get_default_buttons","text":"get_default_buttons () -> t . List [ nav . NavButton [ nav . NavigatorView ]] Returns a list of default buttons. These are FirstButton() , PrevButton() , NextButton() , LastButton() , and StopButtonDelete() . Returns: Type Description t . List [ nav . NavButton [ nav . NavigatorView ]] A list of default buttons. Source code in utils\\nav\\navigator.py 100 101 102 103 104 105 106 107 108 109 110 111 def get_default_buttons ( self ) -> t . List [ nav . NavButton [ nav . NavigatorView ]]: ''' Returns a list of default buttons. These are `FirstButton()`, `PrevButton()`, `NextButton()`, `LastButton()`, and `StopButtonDelete()`. Returns ------- t.List[nav.NavButton[nav.NavigatorView]] A list of default buttons. ''' return [ nav . FirstButton (), nav . PrevButton (), nav . NextButton (), nav . LastButton (), StopButtonDelete ()]","title":"get_default_buttons()"},{"location":"dev/menu/#utils.nav.navigator.ButtonNavigator.on_timeout","text":"on_timeout () -> None Called when the view times out.","title":"on_timeout()"},{"location":"dev/menu/#utils.nav.navigator.ButtonNavigator.on_timeout--notes","text":"This adds the timeout button into the menu. Source code in utils\\nav\\navigator.py 113 114 115 116 117 118 119 120 121 122 async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout ()","title":"Notes"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder","text":"A builder to fit a list of item into a navigator appropriately. (This is experimental and can be removed at any time). Source code in utils\\nav\\navigator.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 class ItemListBuilder : '''A builder to fit a list of item into a navigator appropriately. (This is experimental and can be removed at any time).''' def __init__ ( self , items : list [ T ], max_item_per_page : int ): '''Construct the builder. Parameters ---------- items : list[T] A list of items. max_item_per_page : int The max amount of item to display before moving to a new page. ''' self . items = items self . max_item = max_item_per_page self . page_start_formatter : t . Callable [[ int , T ], hikari . Embed ] = None self . entry_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = None self . page_end_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = lambda embed , index , item : None def set_page_start_formatter ( self , callback : t . Callable [[ int , T ], hikari . Embed ], / ): '''Set this callback as the formatter to run whenever a new page is requested to be created. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[int, T], hikari.Embed] The callback to use. It must accept an `int` (index of the item), the item itself, and return a `hikari.Embed`. ''' self . page_start_formatter = callback def set_entry_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run while iterating through the item list. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . entry_formatter = callback def set_page_end_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run once adding items to a page is finished. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . page_end_formatter = callback def build ( self , * , page_type = ButtonNavigator ): '''Start the formatting process and return an object of `page_type`. Warnings -------- The builder must provide at least `page_start_formatter` and either `entry_formatter` or `page_end_formatter` before this method is called. Parameters ---------- page_type : t.Type, optional The type of navigator to use, by default ButtonNavigator. This must have a `pages` argument accepting a list of `hikari.Embed`. Returns ------- t.Any The type passed into the constructor, by default ButtonNavigator. Raises ------ NotImplementedError `page_start_formatter` is empty or both `entry_formatter` and `page_end_formatter` are empty. ''' if self . page_start_formatter is None or ( self . entry_formatter is None and self . page_end_formatter is None ): raise NotImplementedError ( \"Not enough formatters are defined.\" ) embeds : list [ hikari . Embed ] = [] embed : hikari . Embed = None for index , item in enumerate ( self . items ): if embed is None : embed = self . page_start_formatter ( index , item ) self . entry_formatter ( embed , index , item ) if index % self . max_item == self . max_item - 1 : self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) embed = None if embed is not None : # TODO: Fix undefined-loop-variable self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) return page_type ( pages = embeds )","title":"ItemListBuilder"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.__init__","text":"__init__ ( items : list [ T ], max_item_per_page : int ) Construct the builder. Parameters: Name Type Description Default items list [ T ] A list of items. required max_item_per_page int The max amount of item to display before moving to a new page. required Source code in utils\\nav\\navigator.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def __init__ ( self , items : list [ T ], max_item_per_page : int ): '''Construct the builder. Parameters ---------- items : list[T] A list of items. max_item_per_page : int The max amount of item to display before moving to a new page. ''' self . items = items self . max_item = max_item_per_page self . page_start_formatter : t . Callable [[ int , T ], hikari . Embed ] = None self . entry_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = None self . page_end_formatter : t . Callable [[ hikari . Embed , int , T ], None ] = lambda embed , index , item : None","title":"__init__()"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.set_page_start_formatter","text":"set_page_start_formatter ( / , callback : t . Callable [[ int , T ], hikari . Embed ]) Set this callback as the formatter to run whenever a new page is requested to be created.","title":"set_page_start_formatter()"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.set_page_start_formatter--notes","text":"This is recommended to use as a decorator. Parameters: Name Type Description Default callback t . Callable [[ int , T ], hikari . Embed ] The callback to use. It must accept an int (index of the item), the item itself, and return a hikari.Embed . required Source code in utils\\nav\\navigator.py 144 145 146 147 148 149 150 151 152 153 154 155 156 def set_page_start_formatter ( self , callback : t . Callable [[ int , T ], hikari . Embed ], / ): '''Set this callback as the formatter to run whenever a new page is requested to be created. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[int, T], hikari.Embed] The callback to use. It must accept an `int` (index of the item), the item itself, and return a `hikari.Embed`. ''' self . page_start_formatter = callback","title":"Notes"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.set_entry_formatter","text":"set_entry_formatter ( / , callback : t . Callable [[ hikari . Embed , int , T ], None ]) Set this callback as the formatter to run while iterating through the item list.","title":"set_entry_formatter()"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.set_entry_formatter--notes","text":"This is recommended to use as a decorator. Parameters: Name Type Description Default callback t . Callable [[ hikari . Embed , int , T ], None] The callback to use. It must accept a hikari.Embed (the page it's editing), an int (index of the item), and the item itself. required Source code in utils\\nav\\navigator.py 157 158 159 160 161 162 163 164 165 166 167 168 169 def set_entry_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run while iterating through the item list. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . entry_formatter = callback","title":"Notes"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.set_page_end_formatter","text":"set_page_end_formatter ( / , callback : t . Callable [[ hikari . Embed , int , T ], None ]) Set this callback as the formatter to run once adding items to a page is finished.","title":"set_page_end_formatter()"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.set_page_end_formatter--notes","text":"This is recommended to use as a decorator. Parameters: Name Type Description Default callback t . Callable [[ hikari . Embed , int , T ], None] The callback to use. It must accept a hikari.Embed (the page it's editing), an int (index of the item), and the item itself. required Source code in utils\\nav\\navigator.py 170 171 172 173 174 175 176 177 178 179 180 181 182 def set_page_end_formatter ( self , callback : t . Callable [[ hikari . Embed , int , T ], None ], / ): '''Set this callback as the formatter to run once adding items to a page is finished. Notes ----- This is recommended to use as a decorator. Parameters ---------- callback : t.Callable[[hikari.Embed, int, T], None] The callback to use. It must accept a `hikari.Embed` (the page it's editing), an `int` (index of the item), and the item itself. ''' self . page_end_formatter = callback","title":"Notes"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.build","text":"build ( * , page_type = ButtonNavigator ) Start the formatting process and return an object of page_type .","title":"build()"},{"location":"dev/menu/#utils.nav.navigator.ItemListBuilder.build--warnings","text":"The builder must provide at least page_start_formatter and either entry_formatter or page_end_formatter before this method is called. Parameters: Name Type Description Default page_type t . Type , optional The type of navigator to use, by default ButtonNavigator. This must have a pages argument accepting a list of hikari.Embed . ButtonNavigator Returns: Type Description t . Any The type passed into the constructor, by default ButtonNavigator. Raises: Type Description NotImplementedError page_start_formatter is empty or both entry_formatter and page_end_formatter are empty. Source code in utils\\nav\\navigator.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def build ( self , * , page_type = ButtonNavigator ): '''Start the formatting process and return an object of `page_type`. Warnings -------- The builder must provide at least `page_start_formatter` and either `entry_formatter` or `page_end_formatter` before this method is called. Parameters ---------- page_type : t.Type, optional The type of navigator to use, by default ButtonNavigator. This must have a `pages` argument accepting a list of `hikari.Embed`. Returns ------- t.Any The type passed into the constructor, by default ButtonNavigator. Raises ------ NotImplementedError `page_start_formatter` is empty or both `entry_formatter` and `page_end_formatter` are empty. ''' if self . page_start_formatter is None or ( self . entry_formatter is None and self . page_end_formatter is None ): raise NotImplementedError ( \"Not enough formatters are defined.\" ) embeds : list [ hikari . Embed ] = [] embed : hikari . Embed = None for index , item in enumerate ( self . items ): if embed is None : embed = self . page_start_formatter ( index , item ) self . entry_formatter ( embed , index , item ) if index % self . max_item == self . max_item - 1 : self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) embed = None if embed is not None : # TODO: Fix undefined-loop-variable self . page_end_formatter ( embed , index , item ) embeds . append ( embed ) return page_type ( pages = embeds )","title":"Warnings"},{"location":"dev/menu/#utils.nav.navigator.run_view","text":"run_view ( view : miru . View , ctx : lightbulb . Context , initial_content : t . Union [ str , hikari . Embed ] = None ) -> None A simplified way to run a miru.View . Parameters: Name Type Description Default view miru . View A miru.View or its subclasses. required ctx lightbulb . Context A context to send the view. required initial_content t . Union [ str , hikari . Embed ], optional The content to first display. This is optional for nav.NavigatorView and its subclasses. None Raises: Type Description TypeError initial_content is not provided, but view is not type nav.NavigatorView . hikari . BadRequestError Maybe ctx is deferred. Source code in utils\\nav\\navigator.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 async def run_view ( view : miru . View , ctx : lightbulb . Context , initial_content : t . Union [ str , hikari . Embed ] = None ) -> None : '''A simplified way to run a `miru.View`. Parameters ---------- view : miru.View A `miru.View` or its subclasses. ctx : lightbulb.Context A context to send the view. initial_content : t.Union[str, hikari.Embed], optional The content to first display. This is optional for `nav.NavigatorView` and its subclasses. Raises ------ TypeError `initial_content` is not provided, but `view` is not type `nav.NavigatorView`. hikari.BadRequestError Maybe `ctx` is deferred. ''' if initial_content is None : if isinstance ( view , nav . NavigatorView ): # nav.NavigatorView cannot be run on an interaction with a response already (typically deferring) # so we have to do things manually here. # Reference: https://github.com/HyperGH/hikari-miru/blob/main/miru/ext/nav/navigator.py#L227 for button in view . children : if isinstance ( button , nav . NavButton ): await button . before_page_change () initial_content = view . pages [ view . current_page ] #await view.send(ctx.interaction) #return else : raise TypeError ( \"'initial_content' must be provided if 'view' is not type 'NavigatorView'.\" ) resp_proxy = await ctx . respond ( initial_content , components = view . build ()) view . start ( await resp_proxy . message ()) await view . wait ()","title":"run_view()"},{"location":"dev/menu/#utils.nav.navigator.timeout_button","text":"timeout_button () -> nav . NavButton Return a nav.NavButton to be use in nav.NavigatorView . This button is safe to use in miru.View . Returns: Type Description nav . NavButton The default timeout button. Source code in utils\\nav\\navigator.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def timeout_button () -> nav . NavButton : '''Return a `nav.NavButton` to be use in `nav.NavigatorView`. This button is safe to use in `miru.View`. Returns ------- nav.NavButton The default timeout button. ''' return nav . NavButton ( style = hikari . ButtonStyle . SECONDARY , emoji = helpers . get_emote ( \":clock12:\" ), custom_id = \"timeout_button\" , disabled = True )","title":"timeout_button()"},{"location":"dev/menu/#navconfirmpy","text":"Contains a confirmation menu.","title":"nav/confirm.py"},{"location":"dev/menu/#utils.nav.confirm.ConfirmView","text":"Bases: miru . View A confirmation menu. Source code in utils\\nav\\confirm.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class ConfirmView ( miru . View ): ''' A confirmation menu. ''' def __init__ ( self , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None : super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . result : t . Optional [ bool ] = None @miru . button ( label = \"Yes\" , emoji = helpers . get_emote ( \":white_check_mark:\" ), style = hikari . ButtonStyle . SUCCESS , custom_id = \"yes_button\" ) async def yes_button ( self , _ : miru . Button , __ : miru . Context ): self . result = True self . stop () @miru . button ( label = \"No\" , emoji = helpers . get_emote ( \":negative_squared_cross_mark:\" ), style = hikari . ButtonStyle . DANGER , custom_id = \"no_button\" ) async def no_button ( self , _ : miru . Button , __ : miru . Context ): self . result = False self . stop () async def wait ( self ) -> t . Optional [ bool ]: ''' Wait until the view times out or stops manually. Return the result of the confirmation, or `None` if it times out. ''' await super () . wait () await self . message . delete () return self . result","title":"ConfirmView"},{"location":"dev/menu/#utils.nav.confirm.ConfirmView.wait","text":"wait () -> t . Optional [ bool ] Wait until the view times out or stops manually. Return the result of the confirmation, or None if it times out. Source code in utils\\nav\\confirm.py 28 29 30 31 32 33 34 35 36 37 async def wait ( self ) -> t . Optional [ bool ]: ''' Wait until the view times out or stops manually. Return the result of the confirmation, or `None` if it times out. ''' await super () . wait () await self . message . delete () return self . result","title":"wait()"},{"location":"dev/menu/#navmenupy","text":"Contains everything needed to build a complex menu.","title":"nav/menu.py"},{"location":"dev/menu/#utils.nav.menu.MenuComponent","text":"A tree-like node that represents the menu's option structure. The node has two \"states\": a regular node state and a fake node. A regular node state is when the options is a dictionary, which will determine the child nodes. A fake node state is when the options is a list of contents to display. In this case, the node's content is set to None , and no further child nodes can be created from this node. The child nodes can be accessed using dictionary notation IF there are child nodes. Source code in utils\\nav\\menu.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class MenuComponent : ''' A tree-like node that represents the menu's option structure. The node has two \"states\": a regular node state and a fake node. A regular node state is when the `options` is a dictionary, which will determine the child nodes. A fake node state is when the `options` is a list of contents to display. In this case, the node's content is set to `None`, and no further child nodes can be created from this node. The child nodes can be accessed using dictionary notation IF there are child nodes. ''' def __init__ ( self , content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ): ''' Create a node that stores the content and optionally, its options. The `options` can be a list, which will set the content to `None` regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a `dict` through `options`, but instead, use `.add_options()`. ''' self . content = content self . options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = options self . __parent__ : t . Optional [ MenuComponent ] = None if isinstance ( self . options , list ): self . content = None def add_option ( self , key : MenuButton , content : PageLike ) -> MenuComponent : '''Add an option into the current node. Return the newly added node to further add more layers. Warnings -------- The returned object is the newly added object, not the current object. Parameters ---------- key : MenuButton The button for the new option. content : PageLike The content of the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. ''' if isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) if self . options is None : self . options = { key : MenuComponent ( content )} self . options [ key ] . __parent__ = self return self . options [ key ] elif self . options . get ( key ) is None : component = MenuComponent ( content ) component . __parent__ = self self . options [ key ] = component return self . options [ key ] else : raise LookupError ( \"Duplicated keys.\" ) def add_options ( self , options : t . Dict [ MenuButton , PageLike ]): '''Add multiple options into the current node. Warnings -------- This will overwrite any possible duplicate keys. Parameters ---------- options : t.Dict[MenuButton, PageLike] A mapping of {button: content}. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) for key in options : self . options [ key ] = MenuComponent ( options [ key ]) self . options [ key ] . __parent__ = self def add_list_options ( self , key : str , contents : t . List [ PageLike ]) -> MenuComponent : '''Append a fake node to this node. Return the newly added node to do whatever you want. Parameters ---------- key : str The button for the new option. contents : t.List[PageLike] A list of content for the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) component = None if len ( contents ) == 1 : component = MenuComponent ( content = contents [ 0 ]) else : component = MenuComponent ( content = None , options = contents ) component . __parent__ = self self . options [ key ] = component return component def force_add_list_options ( self , contents : t . List [ PageLike ]): '''Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters ---------- contents : t.List[PageLike] A list of content for the option. ''' if self . options is None : self . options = [] for content in contents : self . options . append ( content ) self . content = None def __getitem__ ( self , key : MenuButton ) -> t . Optional [ MenuComponent ]: '''Return the MenuComponent with the matching key, or `None` if none was found. Parameters ---------- key : MenuButton The option you're retrieving. Returns ------- t.Optional[MenuComponent] The option with matching key, or `None` if none was found. Raises ------ IndexError The current MenuComponent is already a fake node. ''' if isinstance ( self . options , dict ): return self . options . get ( key ) raise IndexError ( \"Index doesn't exist.\" )","title":"MenuComponent"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.__init__","text":"__init__ ( content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ) Create a node that stores the content and optionally, its options. The options can be a list, which will set the content to None regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a dict through options , but instead, use .add_options() . Source code in utils\\nav\\menu.py 26 27 28 29 30 31 32 33 34 35 36 37 38 def __init__ ( self , content : PageLike , options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = None ): ''' Create a node that stores the content and optionally, its options. The `options` can be a list, which will set the content to `None` regardless of what is passed. Passing a list also seal you from performing any operations on this node. It is recommended to not pass a `dict` through `options`, but instead, use `.add_options()`. ''' self . content = content self . options : t . Union [ t . Dict [ MenuButton , MenuComponent ], list ] = options self . __parent__ : t . Optional [ MenuComponent ] = None if isinstance ( self . options , list ): self . content = None","title":"__init__()"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.add_option","text":"add_option ( key : MenuButton , content : PageLike ) -> MenuComponent Add an option into the current node. Return the newly added node to further add more layers.","title":"add_option()"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.add_option--warnings","text":"The returned object is the newly added object, not the current object. Parameters: Name Type Description Default key MenuButton The button for the new option. required content PageLike The content of the new option. required Returns: Type Description MenuComponent The newly added option. Raises: Type Description KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. Source code in utils\\nav\\menu.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def add_option ( self , key : MenuButton , content : PageLike ) -> MenuComponent : '''Add an option into the current node. Return the newly added node to further add more layers. Warnings -------- The returned object is the newly added object, not the current object. Parameters ---------- key : MenuButton The button for the new option. content : PageLike The content of the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. LookupError There is already a similar key registered. ''' if isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) if self . options is None : self . options = { key : MenuComponent ( content )} self . options [ key ] . __parent__ = self return self . options [ key ] elif self . options . get ( key ) is None : component = MenuComponent ( content ) component . __parent__ = self self . options [ key ] = component return self . options [ key ] else : raise LookupError ( \"Duplicated keys.\" )","title":"Warnings"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.add_options","text":"add_options ( options : t . Dict [ MenuButton , PageLike ]) Add multiple options into the current node.","title":"add_options()"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.add_options--warnings","text":"This will overwrite any possible duplicate keys. Parameters: Name Type Description Default options t . Dict [ MenuButton , PageLike ] A mapping of {button: content}. required Raises: Type Description KeyError The current MenuComponent is already a fake node. Source code in utils\\nav\\menu.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def add_options ( self , options : t . Dict [ MenuButton , PageLike ]): '''Add multiple options into the current node. Warnings -------- This will overwrite any possible duplicate keys. Parameters ---------- options : t.Dict[MenuButton, PageLike] A mapping of {button: content}. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) for key in options : self . options [ key ] = MenuComponent ( options [ key ]) self . options [ key ] . __parent__ = self","title":"Warnings"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.add_list_options","text":"add_list_options ( key : str , contents : t . List [ PageLike ]) -> MenuComponent Append a fake node to this node. Return the newly added node to do whatever you want. Parameters: Name Type Description Default key str The button for the new option. required contents t . List [ PageLike ] A list of content for the new option. required Returns: Type Description MenuComponent The newly added option. Raises: Type Description KeyError The current MenuComponent is already a fake node. Source code in utils\\nav\\menu.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def add_list_options ( self , key : str , contents : t . List [ PageLike ]) -> MenuComponent : '''Append a fake node to this node. Return the newly added node to do whatever you want. Parameters ---------- key : str The button for the new option. contents : t.List[PageLike] A list of content for the new option. Returns ------- MenuComponent The newly added option. Raises ------ KeyError The current MenuComponent is already a fake node. ''' if self . options is None : self . options = {} elif isinstance ( self . options , list ): raise KeyError ( \"Cannot add more options.\" ) component = None if len ( contents ) == 1 : component = MenuComponent ( content = contents [ 0 ]) else : component = MenuComponent ( content = None , options = contents ) component . __parent__ = self self . options [ key ] = component return component","title":"add_list_options()"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.force_add_list_options","text":"force_add_list_options ( contents : t . List [ PageLike ]) Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters: Name Type Description Default contents t . List [ PageLike ] A list of content for the option. required Source code in utils\\nav\\menu.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def force_add_list_options ( self , contents : t . List [ PageLike ]): '''Turn the current node into a fake node. This is also the only way to edit a fake node. Parameters ---------- contents : t.List[PageLike] A list of content for the option. ''' if self . options is None : self . options = [] for content in contents : self . options . append ( content ) self . content = None","title":"force_add_list_options()"},{"location":"dev/menu/#utils.nav.menu.MenuComponent.__getitem__","text":"__getitem__ ( key : MenuButton ) -> t . Optional [ MenuComponent ] Return the MenuComponent with the matching key, or None if none was found. Parameters: Name Type Description Default key MenuButton The option you're retrieving. required Returns: Type Description t . Optional [ MenuComponent ] The option with matching key, or None if none was found. Raises: Type Description IndexError The current MenuComponent is already a fake node. Source code in utils\\nav\\menu.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def __getitem__ ( self , key : MenuButton ) -> t . Optional [ MenuComponent ]: '''Return the MenuComponent with the matching key, or `None` if none was found. Parameters ---------- key : MenuButton The option you're retrieving. Returns ------- t.Optional[MenuComponent] The option with matching key, or `None` if none was found. Raises ------ IndexError The current MenuComponent is already a fake node. ''' if isinstance ( self . options , dict ): return self . options . get ( key ) raise IndexError ( \"Index doesn't exist.\" )","title":"__getitem__()"},{"location":"dev/menu/#utils.nav.menu.MenuButton","text":"Bases: miru . Button Represents a generic button inside ComplexView . This should only be used in ComplexView . Source code in utils\\nav\\menu.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 class MenuButton ( miru . Button ): '''Represents a generic button inside `ComplexView`. This should only be used in `ComplexView`.''' async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the option if the current `MenuComponent` is not a fake node. ''' view : ComplexView = self . view if isinstance ( view . menu . options , dict ): view . menu = view . menu . options [ self ] await view . update ()","title":"MenuButton"},{"location":"dev/menu/#utils.nav.menu.MenuButton.callback","text":"callback ( _ : miru . Context ) -> None Calls when the button is pressed. It'll move to the option if the current MenuComponent is not a fake node. Source code in utils\\nav\\menu.py 186 187 188 189 190 191 192 193 194 195 196 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the option if the current `MenuComponent` is not a fake node. ''' view : ComplexView = self . view if isinstance ( view . menu . options , dict ): view . menu = view . menu . options [ self ] await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.ReturnMenuButton","text":"Bases: MenuButton Represents a return button. Source code in utils\\nav\\menu.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 class ReturnMenuButton ( MenuButton ): '''Represents a return button.''' def __init__ ( self ) -> None : super () . __init__ ( style = hikari . ButtonStyle . SECONDARY , emoji = helpers . get_emote ( \":arrow_up_small:\" ), custom_id = \"return_button\" ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the parent node if it is not `None`. Raises ------ RuntimeError The return button is in the root menu. ''' view : ComplexView = self . view if view . menu . __parent__ is not None : view . menu = view . menu . __parent__ view . current_page = 0 else : raise RuntimeError ( \"A return button is available in the root menu.\" ) await view . update ()","title":"ReturnMenuButton"},{"location":"dev/menu/#utils.nav.menu.ReturnMenuButton.callback","text":"callback ( _ : miru . Context ) -> None Calls when the button is pressed. It'll move to the parent node if it is not None . Raises: Type Description RuntimeError The return button is in the root menu. Source code in utils\\nav\\menu.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll move to the parent node if it is not `None`. Raises ------ RuntimeError The return button is in the root menu. ''' view : ComplexView = self . view if view . menu . __parent__ is not None : view . menu = view . menu . __parent__ view . current_page = 0 else : raise RuntimeError ( \"A return button is available in the root menu.\" ) await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.StopMenuButton","text":"Bases: MenuButton Represents a terminate button. Source code in utils\\nav\\menu.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 class StopMenuButton ( MenuButton ): '''Represents a terminate button.''' def __init__ ( self ) -> None : super () . __init__ ( style = hikari . ButtonStyle . DANGER , emoji = helpers . get_emote ( \":stop_button:\" ), custom_id = \"stop_button\" ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll stop the `ComplexView` and delete the menu. ''' view : ComplexView = self . view view . stop () if view . message : await view . message . delete ()","title":"StopMenuButton"},{"location":"dev/menu/#utils.nav.menu.StopMenuButton.callback","text":"callback ( _ : miru . Context ) -> None Calls when the button is pressed. It'll stop the ComplexView and delete the menu. Source code in utils\\nav\\menu.py 236 237 238 239 240 241 242 243 244 245 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. It'll stop the `ComplexView` and delete the menu. ''' view : ComplexView = self . view view . stop () if view . message : await view . message . delete ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.NextMenuButton","text":"Bases: MenuButton A button to move to the next page list. This behaves similarly to nav.NextButton() . Source code in utils\\nav\\menu.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 class NextMenuButton ( MenuButton ): '''A button to move to the next page list. This behaves similarly to `nav.NextButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"next_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":arrow_forward:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. ''' view : ComplexView = self . view view . current_page += 1 if view . current_page > len ( view . menu . options ) - 1 : view . current_page = 0 await view . update ()","title":"NextMenuButton"},{"location":"dev/menu/#utils.nav.menu.NextMenuButton.callback","text":"callback ( _ : miru . Context ) -> None Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. Source code in utils\\nav\\menu.py 262 263 264 265 266 267 268 269 270 271 272 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the next page, or cycle back if it's already the last page. ''' view : ComplexView = self . view view . current_page += 1 if view . current_page > len ( view . menu . options ) - 1 : view . current_page = 0 await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.PrevMenuButton","text":"Bases: MenuButton A button to move to the previous page list. This behaves similarly to nav.PrevButton() . Source code in utils\\nav\\menu.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 class PrevMenuButton ( MenuButton ): '''A button to move to the previous page list. This behaves similarly to `nav.PrevButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"prev_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":arrow_backward:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. ''' view : ComplexView = self . view view . current_page -= 1 if view . current_page < 0 : view . current_page = len ( view . menu . options ) - 1 await view . update ()","title":"PrevMenuButton"},{"location":"dev/menu/#utils.nav.menu.PrevMenuButton.callback","text":"callback ( _ : miru . Context ) -> None Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. Source code in utils\\nav\\menu.py 289 290 291 292 293 294 295 296 297 298 299 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the previous page, or cycle back if it's already the first page. ''' view : ComplexView = self . view view . current_page -= 1 if view . current_page < 0 : view . current_page = len ( view . menu . options ) - 1 await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.FirstMenuButton","text":"Bases: MenuButton A button to move to the first page list. This behaves similarly to nav.FirstButton() . Source code in utils\\nav\\menu.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 class FirstMenuButton ( MenuButton ): '''A button to move to the first page list. This behaves similarly to `nav.FirstButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"first_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":last_track_button:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the first page. ''' view : ComplexView = self . view view . current_page = 0 await view . update ()","title":"FirstMenuButton"},{"location":"dev/menu/#utils.nav.menu.FirstMenuButton.callback","text":"callback ( _ : miru . Context ) -> None Calls when the button is pressed. Move to the first page. Source code in utils\\nav\\menu.py 316 317 318 319 320 321 322 323 324 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the first page. ''' view : ComplexView = self . view view . current_page = 0 await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.LastMenuButton","text":"Bases: MenuButton A button to move to the last page list. This behaves similarly to nav.LastButton() . Source code in utils\\nav\\menu.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 class LastMenuButton ( MenuButton ): '''A button to move to the last page list. This behaves similarly to `nav.LastButton()`.''' def __init__ ( self , * , style : t . Union [ hikari . ButtonStyle , int ] = hikari . ButtonStyle . PRIMARY , label : t . Optional [ str ] = None , disabled : bool = False , custom_id : t . Optional [ str ] = \"last_menu_button\" , url : t . Optional [ str ] = None , emoji : t . Union [ hikari . Emoji , str , None ] = helpers . get_emote ( \":next_track_button:\" ), row : t . Optional [ int ] = None ) -> None : super () . __init__ ( style = style , label = label , disabled = disabled , custom_id = custom_id , url = url , emoji = emoji , row = row ) async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the last page. ''' view : ComplexView = self . view view . current_page = len ( view . menu . options ) - 1 await view . update ()","title":"LastMenuButton"},{"location":"dev/menu/#utils.nav.menu.LastMenuButton.callback","text":"callback ( _ : miru . Context ) -> None Calls when the button is pressed. Move to the last page. Source code in utils\\nav\\menu.py 341 342 343 344 345 346 347 348 349 async def callback ( self , _ : miru . Context ) -> None : '''Calls when the button is pressed. Move to the last page. ''' view : ComplexView = self . view view . current_page = len ( view . menu . options ) - 1 await view . update ()","title":"callback()"},{"location":"dev/menu/#utils.nav.menu.ComplexView","text":"Bases: miru . View A complex menu. Source code in utils\\nav\\menu.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 class ComplexView ( miru . View ): '''A complex menu.''' def __init__ ( self , menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None : '''Construct a complex menu. Parameters ---------- menu : MenuComponent A `MenuComponent` tree. This must be a root node. timeout : t.Optional[float], optional How long (in seconds) the menu should accept interactions. Default to `120`. autodefer : bool, optional Whether or not the menu should defer when possible. Default to `True`. ''' super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . menu = menu # For list menu self . current_page : int = 0 def _update_button ( self ) -> None : ''' Update the button based on the current menu state. ''' self . clear_items () if isinstance ( self . menu . options , dict ): for button in self . menu . options : self . add_item ( button ) elif isinstance ( self . menu . options , list ): # TODO: Might optimize this so it wouldn't reset the buttons. self . add_item ( FirstMenuButton ()) self . add_item ( PrevMenuButton ()) self . add_item ( NextMenuButton ()) self . add_item ( LastMenuButton ()) for index , item in enumerate ( self . menu . options ): if isinstance ( item , hikari . Embed ): item . set_footer ( f \"Page { index + 1 } / { len ( self . menu . options ) } \" ) if self . menu . __parent__ is None : self . add_item ( StopMenuButton ()) else : self . add_item ( ReturnMenuButton ()) async def update ( self ) -> None : '''Update the menu. This shouldn't be called by the user. Raises ------ RuntimeError The message is not found (for unknown reasons). Notes ----- All `MenuButton` should call this method inside their callbacks once it's done with everything. ''' self . _update_button () content = self . menu . content # If view is in a list menu. Can also check if menu.content is None instead. if isinstance ( self . menu . options , list ): content = self . menu . options [ self . current_page ] if self . message : await self . message . edit ( content , components = self . build ()) else : raise RuntimeError ( \"Oops ComplexView.update() failed.\" ) async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout () async def run ( self , ctx : lightbulb . Context ) -> None : '''Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters ---------- ctx : lightbulb.Context A `lightbulb` context. ''' self . _update_button () await run_view ( self , ctx , self . menu . content )","title":"ComplexView"},{"location":"dev/menu/#utils.nav.menu.ComplexView.__init__","text":"__init__ ( menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None Construct a complex menu. Parameters: Name Type Description Default menu MenuComponent A MenuComponent tree. This must be a root node. required timeout t . Optional [ float ], optional How long (in seconds) the menu should accept interactions. Default to 120 . 120 autodefer bool , optional Whether or not the menu should defer when possible. Default to True . True Source code in utils\\nav\\menu.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 def __init__ ( self , menu : MenuComponent , * , timeout : t . Optional [ float ] = 120 , autodefer : bool = True ) -> None : '''Construct a complex menu. Parameters ---------- menu : MenuComponent A `MenuComponent` tree. This must be a root node. timeout : t.Optional[float], optional How long (in seconds) the menu should accept interactions. Default to `120`. autodefer : bool, optional Whether or not the menu should defer when possible. Default to `True`. ''' super () . __init__ ( timeout = timeout , autodefer = autodefer ) self . menu = menu # For list menu self . current_page : int = 0","title":"__init__()"},{"location":"dev/menu/#utils.nav.menu.ComplexView.update","text":"update () -> None Update the menu. This shouldn't be called by the user. Raises: Type Description RuntimeError The message is not found (for unknown reasons).","title":"update()"},{"location":"dev/menu/#utils.nav.menu.ComplexView.update--notes","text":"All MenuButton should call this method inside their callbacks once it's done with everything. Source code in utils\\nav\\menu.py 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 async def update ( self ) -> None : '''Update the menu. This shouldn't be called by the user. Raises ------ RuntimeError The message is not found (for unknown reasons). Notes ----- All `MenuButton` should call this method inside their callbacks once it's done with everything. ''' self . _update_button () content = self . menu . content # If view is in a list menu. Can also check if menu.content is None instead. if isinstance ( self . menu . options , list ): content = self . menu . options [ self . current_page ] if self . message : await self . message . edit ( content , components = self . build ()) else : raise RuntimeError ( \"Oops ComplexView.update() failed.\" )","title":"Notes"},{"location":"dev/menu/#utils.nav.menu.ComplexView.on_timeout","text":"on_timeout () -> None Called when the view times out.","title":"on_timeout()"},{"location":"dev/menu/#utils.nav.menu.ComplexView.on_timeout--notes","text":"This adds the timeout button into the menu. Source code in utils\\nav\\menu.py 421 422 423 424 425 426 427 428 429 430 async def on_timeout ( self ) -> None : '''Called when the view times out. Notes ----- This adds the timeout button into the menu. ''' self . clear_items () self . add_item ( timeout_button ()) await super () . on_timeout ()","title":"Notes"},{"location":"dev/menu/#utils.nav.menu.ComplexView.run","text":"run ( ctx : lightbulb . Context ) -> None Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters: Name Type Description Default ctx lightbulb . Context A lightbulb context. required Source code in utils\\nav\\menu.py 432 433 434 435 436 437 438 439 440 441 442 443 444 async def run ( self , ctx : lightbulb . Context ) -> None : '''Start the menu and make it listen to the interactions. The menu is guaranteed to be finished once this method is over. Parameters ---------- ctx : lightbulb.Context A `lightbulb` context. ''' self . _update_button () await run_view ( self , ctx , self . menu . content )","title":"run()"},{"location":"dev/models/","text":"Contains many data structures, including the customized MichaelBot class. GuildCache A wrapper around dict[str, psql.Guild] This includes many ways to obtain info, such as get() , keys() , items() , values() , and __getitem__() . These methods will return a deep copy of the desired object, so you can freely edit them. Source code in utils\\models.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class GuildCache : '''A wrapper around `dict[str, psql.Guild]` This includes many ways to obtain info, such as `get()`, `keys()`, `items()`, `values()`, and `__getitem__()`. These methods will return a deep copy of the desired object, so you can freely edit them. ''' def __init__ ( self ) -> None : self . __guild_mapping : dict [ str , psql . Guild ] = {} def __getitem__ ( self , guild_id : int ): return copy . deepcopy ( self . __guild_mapping [ guild_id ]) def get ( self , guild_id : int ): return copy . deepcopy ( self . __guild_mapping . get ( guild_id )) def keys ( self ): return self . __guild_mapping . keys () def items ( self ): return self . __guild_mapping . items () def values ( self ): return self . __guild_mapping . values () async def insert ( self , conn : asyncpg . Connection , guild : psql . Guild ): '''Explicitly add a new guild to the cache and to the db. This is mostly used to save overheads within `psql.Guild.sync()` Warnings -------- Using this method means you're 100% sure the guild doesn't exist. For entries that *might* exist, consider using `update_with()`. Parameters ---------- conn : asyncpg.Connection The connection to use. guild : psql.Guild The guild to insert. ''' await psql . Guild . insert_one ( conn , guild ) self . __guild_mapping [ guild . id ] = guild async def update ( self , conn : asyncpg . Connection , guild : psql . Guild ): await psql . Guild . update ( conn , guild ) self . __guild_mapping [ guild . id ] = guild async def update_from_db ( self , conn : asyncpg . Connection , guild_id : int ): guild = await psql . Guild . get_one ( conn , guild_id ) if guild is None : del self . __guild_mapping [ guild_id ] self . __guild_mapping [ guild . id ] = guild async def update_all_from_db ( self , conn : asyncpg . Connection ): guilds = await psql . Guild . get_all ( conn ) self . __guild_mapping = {} for guild in guilds : self . __guild_mapping [ guild . id ] = guild def update_local ( self , guild : psql . Guild ): self . __guild_mapping [ guild . id ] = guild def remove_local ( self , guild_id : int ): del self . __guild_mapping [ guild_id ] insert async insert ( conn : asyncpg . Connection , guild : psql . Guild ) Explicitly add a new guild to the cache and to the db. This is mostly used to save overheads within psql.Guild.sync() Warnings Using this method means you're 100% sure the guild doesn't exist. For entries that might exist, consider using update_with() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required guild psql . Guild The guild to insert. required Source code in utils\\models.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 async def insert ( self , conn : asyncpg . Connection , guild : psql . Guild ): '''Explicitly add a new guild to the cache and to the db. This is mostly used to save overheads within `psql.Guild.sync()` Warnings -------- Using this method means you're 100% sure the guild doesn't exist. For entries that *might* exist, consider using `update_with()`. Parameters ---------- conn : asyncpg.Connection The connection to use. guild : psql.Guild The guild to insert. ''' await psql . Guild . insert_one ( conn , guild ) self . __guild_mapping [ guild . id ] = guild LogCache A wrapper around dict[str, psql.GuildLog] This includes many ways to obtain info, such as get() , keys() , items() , values() , and __getitem__() . These methods will return a deep copy of the desired object, so you can freely edit them. Source code in utils\\models.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 class LogCache : '''A wrapper around `dict[str, psql.GuildLog]` This includes many ways to obtain info, such as `get()`, `keys()`, `items()`, `values()`, and `__getitem__()`. These methods will return a deep copy of the desired object, so you can freely edit them. ''' def __init__ ( self ) -> None : self . __log_mapping : dict [ str , psql . GuildLog ] = {} def __getitem__ ( self , guild_id : int ): return copy . deepcopy ( self . __log_mapping [ guild_id ]) def get ( self , guild_id : int ): return copy . deepcopy ( self . __log_mapping . get ( guild_id )) def keys ( self ): return self . __log_mapping . keys () def items ( self ): return self . __log_mapping . items () def values ( self ): return self . __log_mapping . values () async def insert ( self , conn : asyncpg . Connection , guild : psql . GuildLog ): await psql . GuildLog . insert_one ( conn , guild . guild_id ) self . __log_mapping [ guild . guild_id ] = guild async def update ( self , conn : asyncpg . Connection , guild : psql . GuildLog ): await psql . GuildLog . update ( conn , guild ) self . __log_mapping [ guild . guild_id ] = guild async def update_from_db ( self , conn : asyncpg . Connection , guild_id : int ): guild = await psql . GuildLog . get_one ( conn , guild_id ) if guild is None : del self . __log_mapping [ guild_id ] self . __log_mapping [ guild . guild_id ] = guild async def update_all_from_db ( self , conn : asyncpg . Connection ): guilds = await psql . GuildLog . get_all ( conn ) self . __log_mapping = {} for guild in guilds : self . __log_mapping [ guild . guild_id ] = guild def update_local ( self , guild : psql . GuildLog ): self . __log_mapping [ guild . guild_id ] = guild def remove_local ( self , guild_id : int ): del self . __log_mapping [ guild_id ] UserCache A wrapper around dict[str, psql.User] This includes many ways to obtain info, such as get() , keys() , items() , values() , and __getitem__() . These methods will return a deep copy of the desired object, so you can freely edit them. Source code in utils\\models.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 class UserCache : '''A wrapper around `dict[str, psql.User]` This includes many ways to obtain info, such as `get()`, `keys()`, `items()`, `values()`, and `__getitem__()`. These methods will return a deep copy of the desired object, so you can freely edit them. ''' def __init__ ( self ) -> None : self . __user_mapping : dict [ str , psql . User ] = {} def __getitem__ ( self , user_id : int ): return copy . deepcopy ( self . __user_mapping [ user_id ]) def get ( self , user_id : int ): return copy . deepcopy ( self . __user_mapping . get ( user_id )) def keys ( self ): return self . __user_mapping . keys () def items ( self ): return self . __user_mapping . items () def values ( self ): return self . __user_mapping . values () async def insert ( self , conn : asyncpg . Connection , user : psql . User ): '''Explicitly add a new user to the cache and to the db. This is mostly used to save overheads within `psql.User.sync()` Warnings -------- Using this method means you're 100% sure the user doesn't exist. For entries that *might* exist, consider using `sync_user()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user : psql.User The user to insert. ''' await psql . User . insert_one ( conn , user ) self . __user_mapping [ user . id ] = user async def update ( self , conn : asyncpg . Connection , user : psql . User ): '''Sync the database with the new value. Parameters ---------- conn : asyncpg.Connection The connection to use. user : psql.User The user value to update with. ''' await psql . User . update ( conn , user ) self . __user_mapping [ user . id ] = user async def update_from_db ( self , conn : asyncpg . Connection , user_id : int ): user = await psql . User . get_one ( conn , user_id ) if user is None : del self . __user_mapping [ user_id ] self . __user_mapping [ user . id ] = user async def update_all_from_db ( self , conn : asyncpg . Connection ): users = await psql . User . get_all ( conn ) self . __user_mapping = {} for user in users : self . __user_mapping [ user . id ] = user def update_local ( self , user : psql . User ): self . __user_mapping [ user . id ] = user insert async insert ( conn : asyncpg . Connection , user : psql . User ) Explicitly add a new user to the cache and to the db. This is mostly used to save overheads within psql.User.sync() Warnings Using this method means you're 100% sure the user doesn't exist. For entries that might exist, consider using sync_user() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required user psql . User The user to insert. required Source code in utils\\models.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 async def insert ( self , conn : asyncpg . Connection , user : psql . User ): '''Explicitly add a new user to the cache and to the db. This is mostly used to save overheads within `psql.User.sync()` Warnings -------- Using this method means you're 100% sure the user doesn't exist. For entries that *might* exist, consider using `sync_user()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user : psql.User The user to insert. ''' await psql . User . insert_one ( conn , user ) self . __user_mapping [ user . id ] = user update async update ( conn : asyncpg . Connection , user : psql . User ) Sync the database with the new value. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required user psql . User The user value to update with. required Source code in utils\\models.py 164 165 166 167 168 169 170 171 172 173 174 175 176 async def update ( self , conn : asyncpg . Connection , user : psql . User ): '''Sync the database with the new value. Parameters ---------- conn : asyncpg.Connection The connection to use. user : psql.User The user value to update with. ''' await psql . User . update ( conn , user ) self . __user_mapping [ user . id ] = user ItemCache A wrapper around dict[str, psql.Item] This includes many ways to obtain info, such as get() , keys() , items() , values() , and __getitem__() . These methods will return a deep copy of the desired object, so you can freely edit them. Source code in utils\\models.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 class ItemCache : '''A wrapper around `dict[str, psql.Item]` This includes many ways to obtain info, such as `get()`, `keys()`, `items()`, `values()`, and `__getitem__()`. These methods will return a deep copy of the desired object, so you can freely edit them. ''' def __init__ ( self ): self . __item_mapping : dict [ str , psql . Item ] = {} def __getitem__ ( self , item_id : str ) -> psql . Item : '''Return a copy of the item matching the item's id.''' return copy . deepcopy ( self . __item_mapping [ item_id ]) def get ( self , item_id : str ) -> t . Optional [ psql . Item ]: '''Return a copy of the item matching the item's id, or `None` if none was found.''' return copy . deepcopy ( self . __item_mapping . get ( item_id )) def get_by_name ( self , name_or_alias : str ): '''Return a copy of the item matching the item's name or alias, or `None` if none was found.''' if self . get ( name_or_alias ): return self . get ( name_or_alias ) name = name_or_alias . lower () for item in self . __item_mapping . values (): if name == item . name . lower (): return copy . deepcopy ( item ) if item . aliases and name in [ alias . lower () for alias in item . aliases ]: return copy . deepcopy ( item ) return None def keys ( self ): '''Return an iterable of keys inside the underlying `dict`.''' return self . __item_mapping . keys () def items ( self ): '''Return an iterable of items inside the underlying `dict`.''' return self . __item_mapping . items () def values ( self ): '''Return an iterable of values inside the underlying `dict`.''' return self . __item_mapping . values () async def update ( self , conn : asyncpg . Connection , item : psql . Item ): await psql . Item . update ( conn , item ) self . __item_mapping [ item . id ] = item def update_local ( self , item : psql . Item ): '''Set the cache item with the new value. This basically sets the internal mapping with the new item. Parameters ---------- item : psql.Item The item value to update with. ''' self . __item_mapping [ item . id ] = item __getitem__ __getitem__ ( item_id : str ) -> psql . Item Return a copy of the item matching the item's id. Source code in utils\\models.py 203 204 205 206 def __getitem__ ( self , item_id : str ) -> psql . Item : '''Return a copy of the item matching the item's id.''' return copy . deepcopy ( self . __item_mapping [ item_id ]) get get ( item_id : str ) -> t . Optional [ psql . Item ] Return a copy of the item matching the item's id, or None if none was found. Source code in utils\\models.py 207 208 209 210 def get ( self , item_id : str ) -> t . Optional [ psql . Item ]: '''Return a copy of the item matching the item's id, or `None` if none was found.''' return copy . deepcopy ( self . __item_mapping . get ( item_id )) get_by_name get_by_name ( name_or_alias : str ) Return a copy of the item matching the item's name or alias, or None if none was found. Source code in utils\\models.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def get_by_name ( self , name_or_alias : str ): '''Return a copy of the item matching the item's name or alias, or `None` if none was found.''' if self . get ( name_or_alias ): return self . get ( name_or_alias ) name = name_or_alias . lower () for item in self . __item_mapping . values (): if name == item . name . lower (): return copy . deepcopy ( item ) if item . aliases and name in [ alias . lower () for alias in item . aliases ]: return copy . deepcopy ( item ) return None keys keys () Return an iterable of keys inside the underlying dict . Source code in utils\\models.py 225 226 227 228 def keys ( self ): '''Return an iterable of keys inside the underlying `dict`.''' return self . __item_mapping . keys () items items () Return an iterable of items inside the underlying dict . Source code in utils\\models.py 229 230 231 232 def items ( self ): '''Return an iterable of items inside the underlying `dict`.''' return self . __item_mapping . items () values values () Return an iterable of values inside the underlying dict . Source code in utils\\models.py 233 234 235 236 def values ( self ): '''Return an iterable of values inside the underlying `dict`.''' return self . __item_mapping . values () update_local update_local ( item : psql . Item ) Set the cache item with the new value. This basically sets the internal mapping with the new item. Parameters: Name Type Description Default item psql . Item The item value to update with. required Source code in utils\\models.py 241 242 243 244 245 246 247 248 249 250 251 252 def update_local ( self , item : psql . Item ): '''Set the cache item with the new value. This basically sets the internal mapping with the new item. Parameters ---------- item : psql.Item The item value to update with. ''' self . __item_mapping [ item . id ] = item DefaultColor dataclass Store several default colors to use instantly. Source code in utils\\models.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 @dataclass ( frozen = True ) class DefaultColor : '''Store several default colors to use instantly.''' teal = hikari . Color ( 0x1abc9c ) dark_teal = hikari . Color ( 0x11806a ) brand_green = hikari . Color ( 0x57F287 ) green = hikari . Color ( 0x2ecc71 ) dark_green = hikari . Color ( 0x1f8b4c ) blue = hikari . Color ( 0x3498db ) dark_blue = hikari . Color ( 0x206694 ) purple = hikari . Color ( 0x9b59b6 ) dark_purple = hikari . Color ( 0x71368a ) magenta = hikari . Color ( 0xe91e63 ) dark_magenta = hikari . Color ( 0xad1457 ) gold = hikari . Color ( 0xf1c40f ) dark_gold = hikari . Color ( 0xc27c0e ) orange = hikari . Color ( 0xe67e22 ) dark_orange = hikari . Color ( 0xa84300 ) brand_red = hikari . Color ( 0xED4245 ) red = hikari . Color ( 0xe74c3c ) dark_red = hikari . Color ( 0x992d22 ) lighter_gray = hikari . Color ( 0x95a5a6 ) dark_gray = hikari . Color ( 0x607d8b ) light_gray = hikari . Color ( 0x979c9f ) darker_gray = hikari . Color ( 0x546e7a ) og_blurple = hikari . Color ( 0x7289da ) blurple = hikari . Color ( 0x5865F2 ) greyple = hikari . Color ( 0x5865F2 ) dark_theme = hikari . Color ( 0x36393F ) fuchsia = hikari . Color ( 0xEB459E ) yellow = hikari . Color ( 0xFEE75C ) black = hikari . Color ( 0x000000 ) white = hikari . Color ( 0xFFFFFF ) available_names = [] def __init__ ( self ): if DefaultColor . available_names : return for attr in DefaultColor . __dict__ : if attr . startswith ( \"__\" ): continue if attr in ( \"get_color\" , \"available_names\" ): continue DefaultColor . available_names . append ( attr ) @staticmethod def get_color ( color : str ): return getattr ( DefaultColor (), color ) NodeExtra dataclass A class to store extra data for the lavaplayer.Node Source code in utils\\models.py 307 308 309 310 311 @dataclass class NodeExtra : '''A class to store extra data for the `lavaplayer.Node`''' queue_loop : bool = False working_channel : int = 0 MichaelBot Bases: lightbulb . BotApp A subclass of lightbulb.BotApp . This allows syntax highlight on many custom attributes. Source code in utils\\models.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 class MichaelBot ( lightbulb . BotApp ): '''A subclass of `lightbulb.BotApp`. This allows syntax highlight on many custom attributes.''' __slots__ = ( \"info\" , \"secrets\" , \"online_at\" , \"logging\" , \"pool\" , \"aio_session\" , \"guild_cache\" , \"log_cache\" , \"user_cache\" , \"item_cache\" , \"lavalink\" , \"node_extra\" ) def __init__ ( self , token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None : ''' Parameters ----------------- info : dict The bot info. Store the one in `config.json`. secrets : dict The bot's secrets such as token, database info, etc. ''' self . info : dict = kwargs . pop ( \"info\" ) self . secrets : dict = kwargs . pop ( \"secrets\" ) self . online_at : dt . datetime = None self . pool : t . Optional [ asyncpg . Pool ] = None self . aio_session : t . Optional [ aiohttp . ClientSession ] = None # Store some db info. This allows read-only operation much cheaper. self . guild_cache = GuildCache () self . log_cache = LogCache () self . user_cache = UserCache () self . item_cache = ItemCache () self . lavalink : t . Optional [ lavaplayer . LavalinkClient ] = None # Currently lavaplayer doesn't support adding attr to lavaplayer.objects.Node # so we'll make a dictionary to manually track additional info. self . node_extra : dict [ int , NodeExtra ] = {} launch_options = self . info . get ( \"launch_options\" ) log_level = \"INFO\" if launch_options is None : launch_options = \"\" for option in launch_options . split (): if option in [ \"--debug\" , \"-d\" ]: default_enabled_guilds = self . info [ \"default_guilds\" ] log_level = \"DEBUG\" if option in [ \"--quiet\" , \"-q\" ]: log_level = \"\" super () . __init__ ( token , prefix , ignore_bots , owner_ids , default_enabled_guilds , help_class , help_slash_command , delete_unbound_commands , case_insensitive_prefix_commands , logs = log_level if bool ( log_level ) else None , ** kwargs ) def get_slash_command ( self , name : str ) -> t . Optional [ lightbulb . SlashCommand ]: '''Get the slash command with the given name, or `None` if none was found. Unlike the default behavior in `lightbulb.BotApp`, this also searches for subcommands. Parameters ---------- name : str The command name to search. Returns ------- t.Optional[lightbulb.SlashCommand] The slash command with that name, or `None` if none was found. ''' # Reference: https://hikari-lightbulb.readthedocs.io/en/latest/_modules/lightbulb/app.html#BotApp.get_prefix_command parts = name . split () if len ( parts ) == 1 : return self . _slash_commands . get ( name ) maybe_group = self . _slash_commands . get ( parts . pop ( 0 )) if not isinstance ( maybe_group , lightbulb . SlashCommandGroup ): return None this : t . Optional [ t . Union [ lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup , lightbulb . SlashSubCommand ] ] = maybe_group for part in parts : if this is None or isinstance ( this , lightbulb . SlashSubCommand ): return None this = this . get_subcommand ( part ) return this async def reset_cooldown ( self , ctx : lightbulb . Context ): '''A shortcut to reset a command's cooldown. Parameters ---------- ctx : lightbulb.Context The context the command is invoked. ''' await ctx . invoked . cooldown_manager . reset_cooldown ( ctx ) __init__ __init__ ( token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None Parameters: Name Type Description Default info dict The bot info. Store the one in config.json . required secrets dict The bot's secrets such as token, database info, etc. required Source code in utils\\models.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 def __init__ ( self , token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None : ''' Parameters ----------------- info : dict The bot info. Store the one in `config.json`. secrets : dict The bot's secrets such as token, database info, etc. ''' self . info : dict = kwargs . pop ( \"info\" ) self . secrets : dict = kwargs . pop ( \"secrets\" ) self . online_at : dt . datetime = None self . pool : t . Optional [ asyncpg . Pool ] = None self . aio_session : t . Optional [ aiohttp . ClientSession ] = None # Store some db info. This allows read-only operation much cheaper. self . guild_cache = GuildCache () self . log_cache = LogCache () self . user_cache = UserCache () self . item_cache = ItemCache () self . lavalink : t . Optional [ lavaplayer . LavalinkClient ] = None # Currently lavaplayer doesn't support adding attr to lavaplayer.objects.Node # so we'll make a dictionary to manually track additional info. self . node_extra : dict [ int , NodeExtra ] = {} launch_options = self . info . get ( \"launch_options\" ) log_level = \"INFO\" if launch_options is None : launch_options = \"\" for option in launch_options . split (): if option in [ \"--debug\" , \"-d\" ]: default_enabled_guilds = self . info [ \"default_guilds\" ] log_level = \"DEBUG\" if option in [ \"--quiet\" , \"-q\" ]: log_level = \"\" super () . __init__ ( token , prefix , ignore_bots , owner_ids , default_enabled_guilds , help_class , help_slash_command , delete_unbound_commands , case_insensitive_prefix_commands , logs = log_level if bool ( log_level ) else None , ** kwargs ) get_slash_command get_slash_command ( name : str ) -> t . Optional [ lightbulb . SlashCommand ] Get the slash command with the given name, or None if none was found. Unlike the default behavior in lightbulb.BotApp , this also searches for subcommands. Parameters: Name Type Description Default name str The command name to search. required Returns: Type Description t . Optional [ lightbulb . SlashCommand ] The slash command with that name, or None if none was found. Source code in utils\\models.py 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 def get_slash_command ( self , name : str ) -> t . Optional [ lightbulb . SlashCommand ]: '''Get the slash command with the given name, or `None` if none was found. Unlike the default behavior in `lightbulb.BotApp`, this also searches for subcommands. Parameters ---------- name : str The command name to search. Returns ------- t.Optional[lightbulb.SlashCommand] The slash command with that name, or `None` if none was found. ''' # Reference: https://hikari-lightbulb.readthedocs.io/en/latest/_modules/lightbulb/app.html#BotApp.get_prefix_command parts = name . split () if len ( parts ) == 1 : return self . _slash_commands . get ( name ) maybe_group = self . _slash_commands . get ( parts . pop ( 0 )) if not isinstance ( maybe_group , lightbulb . SlashCommandGroup ): return None this : t . Optional [ t . Union [ lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup , lightbulb . SlashSubCommand ] ] = maybe_group for part in parts : if this is None or isinstance ( this , lightbulb . SlashSubCommand ): return None this = this . get_subcommand ( part ) return this reset_cooldown async reset_cooldown ( ctx : lightbulb . Context ) A shortcut to reset a command's cooldown. Parameters: Name Type Description Default ctx lightbulb . Context The context the command is invoked. required Source code in utils\\models.py 431 432 433 434 435 436 437 438 439 440 async def reset_cooldown ( self , ctx : lightbulb . Context ): '''A shortcut to reset a command's cooldown. Parameters ---------- ctx : lightbulb.Context The context the command is invoked. ''' await ctx . invoked . cooldown_manager . reset_cooldown ( ctx )","title":"models.py"},{"location":"dev/models/#utils.models.GuildCache","text":"A wrapper around dict[str, psql.Guild] This includes many ways to obtain info, such as get() , keys() , items() , values() , and __getitem__() . These methods will return a deep copy of the desired object, so you can freely edit them. Source code in utils\\models.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class GuildCache : '''A wrapper around `dict[str, psql.Guild]` This includes many ways to obtain info, such as `get()`, `keys()`, `items()`, `values()`, and `__getitem__()`. These methods will return a deep copy of the desired object, so you can freely edit them. ''' def __init__ ( self ) -> None : self . __guild_mapping : dict [ str , psql . Guild ] = {} def __getitem__ ( self , guild_id : int ): return copy . deepcopy ( self . __guild_mapping [ guild_id ]) def get ( self , guild_id : int ): return copy . deepcopy ( self . __guild_mapping . get ( guild_id )) def keys ( self ): return self . __guild_mapping . keys () def items ( self ): return self . __guild_mapping . items () def values ( self ): return self . __guild_mapping . values () async def insert ( self , conn : asyncpg . Connection , guild : psql . Guild ): '''Explicitly add a new guild to the cache and to the db. This is mostly used to save overheads within `psql.Guild.sync()` Warnings -------- Using this method means you're 100% sure the guild doesn't exist. For entries that *might* exist, consider using `update_with()`. Parameters ---------- conn : asyncpg.Connection The connection to use. guild : psql.Guild The guild to insert. ''' await psql . Guild . insert_one ( conn , guild ) self . __guild_mapping [ guild . id ] = guild async def update ( self , conn : asyncpg . Connection , guild : psql . Guild ): await psql . Guild . update ( conn , guild ) self . __guild_mapping [ guild . id ] = guild async def update_from_db ( self , conn : asyncpg . Connection , guild_id : int ): guild = await psql . Guild . get_one ( conn , guild_id ) if guild is None : del self . __guild_mapping [ guild_id ] self . __guild_mapping [ guild . id ] = guild async def update_all_from_db ( self , conn : asyncpg . Connection ): guilds = await psql . Guild . get_all ( conn ) self . __guild_mapping = {} for guild in guilds : self . __guild_mapping [ guild . id ] = guild def update_local ( self , guild : psql . Guild ): self . __guild_mapping [ guild . id ] = guild def remove_local ( self , guild_id : int ): del self . __guild_mapping [ guild_id ]","title":"GuildCache"},{"location":"dev/models/#utils.models.GuildCache.insert","text":"insert ( conn : asyncpg . Connection , guild : psql . Guild ) Explicitly add a new guild to the cache and to the db. This is mostly used to save overheads within psql.Guild.sync()","title":"insert()"},{"location":"dev/models/#utils.models.GuildCache.insert--warnings","text":"Using this method means you're 100% sure the guild doesn't exist. For entries that might exist, consider using update_with() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required guild psql . Guild The guild to insert. required Source code in utils\\models.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 async def insert ( self , conn : asyncpg . Connection , guild : psql . Guild ): '''Explicitly add a new guild to the cache and to the db. This is mostly used to save overheads within `psql.Guild.sync()` Warnings -------- Using this method means you're 100% sure the guild doesn't exist. For entries that *might* exist, consider using `update_with()`. Parameters ---------- conn : asyncpg.Connection The connection to use. guild : psql.Guild The guild to insert. ''' await psql . Guild . insert_one ( conn , guild ) self . __guild_mapping [ guild . id ] = guild","title":"Warnings"},{"location":"dev/models/#utils.models.LogCache","text":"A wrapper around dict[str, psql.GuildLog] This includes many ways to obtain info, such as get() , keys() , items() , values() , and __getitem__() . These methods will return a deep copy of the desired object, so you can freely edit them. Source code in utils\\models.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 class LogCache : '''A wrapper around `dict[str, psql.GuildLog]` This includes many ways to obtain info, such as `get()`, `keys()`, `items()`, `values()`, and `__getitem__()`. These methods will return a deep copy of the desired object, so you can freely edit them. ''' def __init__ ( self ) -> None : self . __log_mapping : dict [ str , psql . GuildLog ] = {} def __getitem__ ( self , guild_id : int ): return copy . deepcopy ( self . __log_mapping [ guild_id ]) def get ( self , guild_id : int ): return copy . deepcopy ( self . __log_mapping . get ( guild_id )) def keys ( self ): return self . __log_mapping . keys () def items ( self ): return self . __log_mapping . items () def values ( self ): return self . __log_mapping . values () async def insert ( self , conn : asyncpg . Connection , guild : psql . GuildLog ): await psql . GuildLog . insert_one ( conn , guild . guild_id ) self . __log_mapping [ guild . guild_id ] = guild async def update ( self , conn : asyncpg . Connection , guild : psql . GuildLog ): await psql . GuildLog . update ( conn , guild ) self . __log_mapping [ guild . guild_id ] = guild async def update_from_db ( self , conn : asyncpg . Connection , guild_id : int ): guild = await psql . GuildLog . get_one ( conn , guild_id ) if guild is None : del self . __log_mapping [ guild_id ] self . __log_mapping [ guild . guild_id ] = guild async def update_all_from_db ( self , conn : asyncpg . Connection ): guilds = await psql . GuildLog . get_all ( conn ) self . __log_mapping = {} for guild in guilds : self . __log_mapping [ guild . guild_id ] = guild def update_local ( self , guild : psql . GuildLog ): self . __log_mapping [ guild . guild_id ] = guild def remove_local ( self , guild_id : int ): del self . __log_mapping [ guild_id ]","title":"LogCache"},{"location":"dev/models/#utils.models.UserCache","text":"A wrapper around dict[str, psql.User] This includes many ways to obtain info, such as get() , keys() , items() , values() , and __getitem__() . These methods will return a deep copy of the desired object, so you can freely edit them. Source code in utils\\models.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 class UserCache : '''A wrapper around `dict[str, psql.User]` This includes many ways to obtain info, such as `get()`, `keys()`, `items()`, `values()`, and `__getitem__()`. These methods will return a deep copy of the desired object, so you can freely edit them. ''' def __init__ ( self ) -> None : self . __user_mapping : dict [ str , psql . User ] = {} def __getitem__ ( self , user_id : int ): return copy . deepcopy ( self . __user_mapping [ user_id ]) def get ( self , user_id : int ): return copy . deepcopy ( self . __user_mapping . get ( user_id )) def keys ( self ): return self . __user_mapping . keys () def items ( self ): return self . __user_mapping . items () def values ( self ): return self . __user_mapping . values () async def insert ( self , conn : asyncpg . Connection , user : psql . User ): '''Explicitly add a new user to the cache and to the db. This is mostly used to save overheads within `psql.User.sync()` Warnings -------- Using this method means you're 100% sure the user doesn't exist. For entries that *might* exist, consider using `sync_user()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user : psql.User The user to insert. ''' await psql . User . insert_one ( conn , user ) self . __user_mapping [ user . id ] = user async def update ( self , conn : asyncpg . Connection , user : psql . User ): '''Sync the database with the new value. Parameters ---------- conn : asyncpg.Connection The connection to use. user : psql.User The user value to update with. ''' await psql . User . update ( conn , user ) self . __user_mapping [ user . id ] = user async def update_from_db ( self , conn : asyncpg . Connection , user_id : int ): user = await psql . User . get_one ( conn , user_id ) if user is None : del self . __user_mapping [ user_id ] self . __user_mapping [ user . id ] = user async def update_all_from_db ( self , conn : asyncpg . Connection ): users = await psql . User . get_all ( conn ) self . __user_mapping = {} for user in users : self . __user_mapping [ user . id ] = user def update_local ( self , user : psql . User ): self . __user_mapping [ user . id ] = user","title":"UserCache"},{"location":"dev/models/#utils.models.UserCache.insert","text":"insert ( conn : asyncpg . Connection , user : psql . User ) Explicitly add a new user to the cache and to the db. This is mostly used to save overheads within psql.User.sync()","title":"insert()"},{"location":"dev/models/#utils.models.UserCache.insert--warnings","text":"Using this method means you're 100% sure the user doesn't exist. For entries that might exist, consider using sync_user() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required user psql . User The user to insert. required Source code in utils\\models.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 async def insert ( self , conn : asyncpg . Connection , user : psql . User ): '''Explicitly add a new user to the cache and to the db. This is mostly used to save overheads within `psql.User.sync()` Warnings -------- Using this method means you're 100% sure the user doesn't exist. For entries that *might* exist, consider using `sync_user()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user : psql.User The user to insert. ''' await psql . User . insert_one ( conn , user ) self . __user_mapping [ user . id ] = user","title":"Warnings"},{"location":"dev/models/#utils.models.UserCache.update","text":"update ( conn : asyncpg . Connection , user : psql . User ) Sync the database with the new value. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required user psql . User The user value to update with. required Source code in utils\\models.py 164 165 166 167 168 169 170 171 172 173 174 175 176 async def update ( self , conn : asyncpg . Connection , user : psql . User ): '''Sync the database with the new value. Parameters ---------- conn : asyncpg.Connection The connection to use. user : psql.User The user value to update with. ''' await psql . User . update ( conn , user ) self . __user_mapping [ user . id ] = user","title":"update()"},{"location":"dev/models/#utils.models.ItemCache","text":"A wrapper around dict[str, psql.Item] This includes many ways to obtain info, such as get() , keys() , items() , values() , and __getitem__() . These methods will return a deep copy of the desired object, so you can freely edit them. Source code in utils\\models.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 class ItemCache : '''A wrapper around `dict[str, psql.Item]` This includes many ways to obtain info, such as `get()`, `keys()`, `items()`, `values()`, and `__getitem__()`. These methods will return a deep copy of the desired object, so you can freely edit them. ''' def __init__ ( self ): self . __item_mapping : dict [ str , psql . Item ] = {} def __getitem__ ( self , item_id : str ) -> psql . Item : '''Return a copy of the item matching the item's id.''' return copy . deepcopy ( self . __item_mapping [ item_id ]) def get ( self , item_id : str ) -> t . Optional [ psql . Item ]: '''Return a copy of the item matching the item's id, or `None` if none was found.''' return copy . deepcopy ( self . __item_mapping . get ( item_id )) def get_by_name ( self , name_or_alias : str ): '''Return a copy of the item matching the item's name or alias, or `None` if none was found.''' if self . get ( name_or_alias ): return self . get ( name_or_alias ) name = name_or_alias . lower () for item in self . __item_mapping . values (): if name == item . name . lower (): return copy . deepcopy ( item ) if item . aliases and name in [ alias . lower () for alias in item . aliases ]: return copy . deepcopy ( item ) return None def keys ( self ): '''Return an iterable of keys inside the underlying `dict`.''' return self . __item_mapping . keys () def items ( self ): '''Return an iterable of items inside the underlying `dict`.''' return self . __item_mapping . items () def values ( self ): '''Return an iterable of values inside the underlying `dict`.''' return self . __item_mapping . values () async def update ( self , conn : asyncpg . Connection , item : psql . Item ): await psql . Item . update ( conn , item ) self . __item_mapping [ item . id ] = item def update_local ( self , item : psql . Item ): '''Set the cache item with the new value. This basically sets the internal mapping with the new item. Parameters ---------- item : psql.Item The item value to update with. ''' self . __item_mapping [ item . id ] = item","title":"ItemCache"},{"location":"dev/models/#utils.models.ItemCache.__getitem__","text":"__getitem__ ( item_id : str ) -> psql . Item Return a copy of the item matching the item's id. Source code in utils\\models.py 203 204 205 206 def __getitem__ ( self , item_id : str ) -> psql . Item : '''Return a copy of the item matching the item's id.''' return copy . deepcopy ( self . __item_mapping [ item_id ])","title":"__getitem__()"},{"location":"dev/models/#utils.models.ItemCache.get","text":"get ( item_id : str ) -> t . Optional [ psql . Item ] Return a copy of the item matching the item's id, or None if none was found. Source code in utils\\models.py 207 208 209 210 def get ( self , item_id : str ) -> t . Optional [ psql . Item ]: '''Return a copy of the item matching the item's id, or `None` if none was found.''' return copy . deepcopy ( self . __item_mapping . get ( item_id ))","title":"get()"},{"location":"dev/models/#utils.models.ItemCache.get_by_name","text":"get_by_name ( name_or_alias : str ) Return a copy of the item matching the item's name or alias, or None if none was found. Source code in utils\\models.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def get_by_name ( self , name_or_alias : str ): '''Return a copy of the item matching the item's name or alias, or `None` if none was found.''' if self . get ( name_or_alias ): return self . get ( name_or_alias ) name = name_or_alias . lower () for item in self . __item_mapping . values (): if name == item . name . lower (): return copy . deepcopy ( item ) if item . aliases and name in [ alias . lower () for alias in item . aliases ]: return copy . deepcopy ( item ) return None","title":"get_by_name()"},{"location":"dev/models/#utils.models.ItemCache.keys","text":"keys () Return an iterable of keys inside the underlying dict . Source code in utils\\models.py 225 226 227 228 def keys ( self ): '''Return an iterable of keys inside the underlying `dict`.''' return self . __item_mapping . keys ()","title":"keys()"},{"location":"dev/models/#utils.models.ItemCache.items","text":"items () Return an iterable of items inside the underlying dict . Source code in utils\\models.py 229 230 231 232 def items ( self ): '''Return an iterable of items inside the underlying `dict`.''' return self . __item_mapping . items ()","title":"items()"},{"location":"dev/models/#utils.models.ItemCache.values","text":"values () Return an iterable of values inside the underlying dict . Source code in utils\\models.py 233 234 235 236 def values ( self ): '''Return an iterable of values inside the underlying `dict`.''' return self . __item_mapping . values ()","title":"values()"},{"location":"dev/models/#utils.models.ItemCache.update_local","text":"update_local ( item : psql . Item ) Set the cache item with the new value. This basically sets the internal mapping with the new item. Parameters: Name Type Description Default item psql . Item The item value to update with. required Source code in utils\\models.py 241 242 243 244 245 246 247 248 249 250 251 252 def update_local ( self , item : psql . Item ): '''Set the cache item with the new value. This basically sets the internal mapping with the new item. Parameters ---------- item : psql.Item The item value to update with. ''' self . __item_mapping [ item . id ] = item","title":"update_local()"},{"location":"dev/models/#utils.models.DefaultColor","text":"Store several default colors to use instantly. Source code in utils\\models.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 @dataclass ( frozen = True ) class DefaultColor : '''Store several default colors to use instantly.''' teal = hikari . Color ( 0x1abc9c ) dark_teal = hikari . Color ( 0x11806a ) brand_green = hikari . Color ( 0x57F287 ) green = hikari . Color ( 0x2ecc71 ) dark_green = hikari . Color ( 0x1f8b4c ) blue = hikari . Color ( 0x3498db ) dark_blue = hikari . Color ( 0x206694 ) purple = hikari . Color ( 0x9b59b6 ) dark_purple = hikari . Color ( 0x71368a ) magenta = hikari . Color ( 0xe91e63 ) dark_magenta = hikari . Color ( 0xad1457 ) gold = hikari . Color ( 0xf1c40f ) dark_gold = hikari . Color ( 0xc27c0e ) orange = hikari . Color ( 0xe67e22 ) dark_orange = hikari . Color ( 0xa84300 ) brand_red = hikari . Color ( 0xED4245 ) red = hikari . Color ( 0xe74c3c ) dark_red = hikari . Color ( 0x992d22 ) lighter_gray = hikari . Color ( 0x95a5a6 ) dark_gray = hikari . Color ( 0x607d8b ) light_gray = hikari . Color ( 0x979c9f ) darker_gray = hikari . Color ( 0x546e7a ) og_blurple = hikari . Color ( 0x7289da ) blurple = hikari . Color ( 0x5865F2 ) greyple = hikari . Color ( 0x5865F2 ) dark_theme = hikari . Color ( 0x36393F ) fuchsia = hikari . Color ( 0xEB459E ) yellow = hikari . Color ( 0xFEE75C ) black = hikari . Color ( 0x000000 ) white = hikari . Color ( 0xFFFFFF ) available_names = [] def __init__ ( self ): if DefaultColor . available_names : return for attr in DefaultColor . __dict__ : if attr . startswith ( \"__\" ): continue if attr in ( \"get_color\" , \"available_names\" ): continue DefaultColor . available_names . append ( attr ) @staticmethod def get_color ( color : str ): return getattr ( DefaultColor (), color )","title":"DefaultColor"},{"location":"dev/models/#utils.models.NodeExtra","text":"A class to store extra data for the lavaplayer.Node Source code in utils\\models.py 307 308 309 310 311 @dataclass class NodeExtra : '''A class to store extra data for the `lavaplayer.Node`''' queue_loop : bool = False working_channel : int = 0","title":"NodeExtra"},{"location":"dev/models/#utils.models.MichaelBot","text":"Bases: lightbulb . BotApp A subclass of lightbulb.BotApp . This allows syntax highlight on many custom attributes. Source code in utils\\models.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 class MichaelBot ( lightbulb . BotApp ): '''A subclass of `lightbulb.BotApp`. This allows syntax highlight on many custom attributes.''' __slots__ = ( \"info\" , \"secrets\" , \"online_at\" , \"logging\" , \"pool\" , \"aio_session\" , \"guild_cache\" , \"log_cache\" , \"user_cache\" , \"item_cache\" , \"lavalink\" , \"node_extra\" ) def __init__ ( self , token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None : ''' Parameters ----------------- info : dict The bot info. Store the one in `config.json`. secrets : dict The bot's secrets such as token, database info, etc. ''' self . info : dict = kwargs . pop ( \"info\" ) self . secrets : dict = kwargs . pop ( \"secrets\" ) self . online_at : dt . datetime = None self . pool : t . Optional [ asyncpg . Pool ] = None self . aio_session : t . Optional [ aiohttp . ClientSession ] = None # Store some db info. This allows read-only operation much cheaper. self . guild_cache = GuildCache () self . log_cache = LogCache () self . user_cache = UserCache () self . item_cache = ItemCache () self . lavalink : t . Optional [ lavaplayer . LavalinkClient ] = None # Currently lavaplayer doesn't support adding attr to lavaplayer.objects.Node # so we'll make a dictionary to manually track additional info. self . node_extra : dict [ int , NodeExtra ] = {} launch_options = self . info . get ( \"launch_options\" ) log_level = \"INFO\" if launch_options is None : launch_options = \"\" for option in launch_options . split (): if option in [ \"--debug\" , \"-d\" ]: default_enabled_guilds = self . info [ \"default_guilds\" ] log_level = \"DEBUG\" if option in [ \"--quiet\" , \"-q\" ]: log_level = \"\" super () . __init__ ( token , prefix , ignore_bots , owner_ids , default_enabled_guilds , help_class , help_slash_command , delete_unbound_commands , case_insensitive_prefix_commands , logs = log_level if bool ( log_level ) else None , ** kwargs ) def get_slash_command ( self , name : str ) -> t . Optional [ lightbulb . SlashCommand ]: '''Get the slash command with the given name, or `None` if none was found. Unlike the default behavior in `lightbulb.BotApp`, this also searches for subcommands. Parameters ---------- name : str The command name to search. Returns ------- t.Optional[lightbulb.SlashCommand] The slash command with that name, or `None` if none was found. ''' # Reference: https://hikari-lightbulb.readthedocs.io/en/latest/_modules/lightbulb/app.html#BotApp.get_prefix_command parts = name . split () if len ( parts ) == 1 : return self . _slash_commands . get ( name ) maybe_group = self . _slash_commands . get ( parts . pop ( 0 )) if not isinstance ( maybe_group , lightbulb . SlashCommandGroup ): return None this : t . Optional [ t . Union [ lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup , lightbulb . SlashSubCommand ] ] = maybe_group for part in parts : if this is None or isinstance ( this , lightbulb . SlashSubCommand ): return None this = this . get_subcommand ( part ) return this async def reset_cooldown ( self , ctx : lightbulb . Context ): '''A shortcut to reset a command's cooldown. Parameters ---------- ctx : lightbulb.Context The context the command is invoked. ''' await ctx . invoked . cooldown_manager . reset_cooldown ( ctx )","title":"MichaelBot"},{"location":"dev/models/#utils.models.MichaelBot.__init__","text":"__init__ ( token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None Parameters: Name Type Description Default info dict The bot info. Store the one in config.json . required secrets dict The bot's secrets such as token, database info, etc. required Source code in utils\\models.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 def __init__ ( self , token , prefix = None , ignore_bots = True , owner_ids : t . Sequence [ int ] = (), default_enabled_guilds : t . Union [ int , t . Sequence [ int ]] = (), help_class = None , help_slash_command = False , delete_unbound_commands = True , case_insensitive_prefix_commands = False , ** kwargs ) -> None : ''' Parameters ----------------- info : dict The bot info. Store the one in `config.json`. secrets : dict The bot's secrets such as token, database info, etc. ''' self . info : dict = kwargs . pop ( \"info\" ) self . secrets : dict = kwargs . pop ( \"secrets\" ) self . online_at : dt . datetime = None self . pool : t . Optional [ asyncpg . Pool ] = None self . aio_session : t . Optional [ aiohttp . ClientSession ] = None # Store some db info. This allows read-only operation much cheaper. self . guild_cache = GuildCache () self . log_cache = LogCache () self . user_cache = UserCache () self . item_cache = ItemCache () self . lavalink : t . Optional [ lavaplayer . LavalinkClient ] = None # Currently lavaplayer doesn't support adding attr to lavaplayer.objects.Node # so we'll make a dictionary to manually track additional info. self . node_extra : dict [ int , NodeExtra ] = {} launch_options = self . info . get ( \"launch_options\" ) log_level = \"INFO\" if launch_options is None : launch_options = \"\" for option in launch_options . split (): if option in [ \"--debug\" , \"-d\" ]: default_enabled_guilds = self . info [ \"default_guilds\" ] log_level = \"DEBUG\" if option in [ \"--quiet\" , \"-q\" ]: log_level = \"\" super () . __init__ ( token , prefix , ignore_bots , owner_ids , default_enabled_guilds , help_class , help_slash_command , delete_unbound_commands , case_insensitive_prefix_commands , logs = log_level if bool ( log_level ) else None , ** kwargs )","title":"__init__()"},{"location":"dev/models/#utils.models.MichaelBot.get_slash_command","text":"get_slash_command ( name : str ) -> t . Optional [ lightbulb . SlashCommand ] Get the slash command with the given name, or None if none was found. Unlike the default behavior in lightbulb.BotApp , this also searches for subcommands. Parameters: Name Type Description Default name str The command name to search. required Returns: Type Description t . Optional [ lightbulb . SlashCommand ] The slash command with that name, or None if none was found. Source code in utils\\models.py 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 def get_slash_command ( self , name : str ) -> t . Optional [ lightbulb . SlashCommand ]: '''Get the slash command with the given name, or `None` if none was found. Unlike the default behavior in `lightbulb.BotApp`, this also searches for subcommands. Parameters ---------- name : str The command name to search. Returns ------- t.Optional[lightbulb.SlashCommand] The slash command with that name, or `None` if none was found. ''' # Reference: https://hikari-lightbulb.readthedocs.io/en/latest/_modules/lightbulb/app.html#BotApp.get_prefix_command parts = name . split () if len ( parts ) == 1 : return self . _slash_commands . get ( name ) maybe_group = self . _slash_commands . get ( parts . pop ( 0 )) if not isinstance ( maybe_group , lightbulb . SlashCommandGroup ): return None this : t . Optional [ t . Union [ lightbulb . SlashCommandGroup , lightbulb . SlashSubGroup , lightbulb . SlashSubCommand ] ] = maybe_group for part in parts : if this is None or isinstance ( this , lightbulb . SlashSubCommand ): return None this = this . get_subcommand ( part ) return this","title":"get_slash_command()"},{"location":"dev/models/#utils.models.MichaelBot.reset_cooldown","text":"reset_cooldown ( ctx : lightbulb . Context ) A shortcut to reset a command's cooldown. Parameters: Name Type Description Default ctx lightbulb . Context The context the command is invoked. required Source code in utils\\models.py 431 432 433 434 435 436 437 438 439 440 async def reset_cooldown ( self , ctx : lightbulb . Context ): '''A shortcut to reset a command's cooldown. Parameters ---------- ctx : lightbulb.Context The context the command is invoked. ''' await ctx . invoked . cooldown_manager . reset_cooldown ( ctx )","title":"reset_cooldown()"},{"location":"dev/psql/","text":"Contains many functions that hide all \"naked\" SQL to use. Error Bases: Exception A base error for high-level PostgreSQL operations. Source code in utils\\psql.py 25 26 class Error ( Exception ): '''A base error for high-level PostgreSQL operations.''' GetError Bases: Error A base error for SELECT operations. Notes This should only be raised when get_x() is implicitly called. This will NOT be raised if the user explicitly calls get_x() . Source code in utils\\psql.py 28 29 30 31 32 33 34 35 class GetError ( Error ): '''A base error for SELECT operations. Notes ----- This should only be raised when `get_x()` is implicitly called. This will NOT be raised if the user explicitly calls `get_x()`. ''' InsertError Bases: Error A base error for INSERT operations. Source code in utils\\psql.py 37 38 class InsertError ( Error ): '''A base error for INSERT operations.''' DeleteError Bases: Error A base error for DELETE operations. Source code in utils\\psql.py 40 41 class DeleteError ( Error ): '''A base error for DELETE operations.''' UpdateError Bases: Error A base error for UPDATE operations. Source code in utils\\psql.py 43 44 class UpdateError ( Error ): '''A base error for UPDATE operations.''' DuplicateArrayElement Bases: UpdateError Raised when trying to add an element that's already available in a unique-only list (set). Source code in utils\\psql.py 46 47 class DuplicateArrayElement ( UpdateError ): '''Raised when trying to add an element that's already available in a unique-only list (set).''' Guild dataclass Bases: ClassToDict Represent an entry in the Guilds table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. Source code in utils\\psql.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 @dataclasses . dataclass ( slots = True ) class Guild ( ClassToDict ): '''Represent an entry in the `Guilds` table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. ''' id : int name : str is_whitelist : bool = True prefix : str = '$' __PREVENT_UPDATE = ( \"id\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entries in the table.''' return await Guild . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Guilds ORDER BY Guilds.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Guild if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ Guild , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM Guilds WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Guild if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , guild : Guild ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"Guilds\" , len ( guild . __slots__ )) return await run_and_return_count ( conn , query , guild . id , guild . name , guild . is_whitelist , guild . prefix ) @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Guilds WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Guild . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Guilds SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) @staticmethod async def update ( conn : asyncpg . Connection , guild : Guild ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_guild = await Guild . get_one ( conn , guild . id ) if not existed_guild : return await Guild . insert_one ( conn , guild ) diff_col = [] for col in existed_guild . __slots__ : if getattr ( existed_guild , col ) != getattr ( guild , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Guild . update_column ( conn , guild . id , change , getattr ( guild , change )) get_all async staticmethod get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]] Get all entries in the table. Source code in utils\\psql.py 222 223 224 225 226 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entries in the table.''' return await Guild . get_all_where ( conn , as_dict = as_dict ) get_all_where async staticmethod get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]] Get all entires in the table that matches the condition. Source code in utils\\psql.py 227 228 229 230 231 232 233 234 235 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Guilds ORDER BY Guilds.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Guild if not as_dict else dict ) get_one async staticmethod get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ Guild , dict ] Get the first entry in the table that matches the pkey provided. Source code in utils\\psql.py 236 237 238 239 240 241 242 243 244 @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ Guild , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM Guilds WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Guild if not as_dict else dict ) insert_one async staticmethod insert_one ( conn : asyncpg . Connection , guild : Guild ) -> int Insert an entry into the table. Source code in utils\\psql.py 245 246 247 248 249 250 @staticmethod async def insert_one ( conn : asyncpg . Connection , guild : Guild ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"Guilds\" , len ( guild . __slots__ )) return await run_and_return_count ( conn , query , guild . id , guild . name , guild . is_whitelist , guild . prefix ) delete async staticmethod delete ( conn : asyncpg . Connection , id : int ) -> int Delete an entry in the table based on the provided key. Source code in utils\\psql.py 251 252 253 254 255 256 257 258 259 @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Guilds WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) update_column async staticmethod update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int Update a specific column with a new value. Warnings Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes Always prefer using other functions to update rather than this function if possible. Source code in utils\\psql.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Guild . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Guilds SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) update async staticmethod update ( conn : asyncpg . Connection , guild : Guild ) -> int Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead. Notes This function has its own transaction. Source code in utils\\psql.py 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 @staticmethod async def update ( conn : asyncpg . Connection , guild : Guild ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_guild = await Guild . get_one ( conn , guild . id ) if not existed_guild : return await Guild . insert_one ( conn , guild ) diff_col = [] for col in existed_guild . __slots__ : if getattr ( existed_guild , col ) != getattr ( guild , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Guild . update_column ( conn , guild . id , change , getattr ( guild , change )) GuildLog dataclass Bases: ClassToDict Represent an entry in the GuildsLogs table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. Source code in utils\\psql.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 @dataclasses . dataclass ( slots = True ) class GuildLog ( ClassToDict ): '''Represent an entry in the `GuildsLogs` table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. ''' guild_id : int log_channel : int = None guild_channel_create : bool = True guild_channel_delete : bool = True guild_channel_update : bool = True guild_ban : bool = True guild_unban : bool = True guild_update : bool = True member_join : bool = True member_leave : bool = True member_update : bool = True guild_bulk_message_delete : bool = True guild_message_delete : bool = True guild_message_update : bool = True role_create : bool = True role_delete : bool = True role_update : bool = True command_complete : bool = True command_error : bool = True __PREVENT_UPDATE = ( \"guild_id\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]]: '''Get all entries in the table.''' return await GuildLog . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM GuildsLogs; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = GuildLog if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ GuildLog , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = GuildLog if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , guild_id : int ) -> int : '''Insert an entry into the table.''' # Only guild_id is required. query = insert_into_query ( \"GuildsLogs\" , 1 ) return await run_and_return_count ( conn , query , guild_id ) @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in GuildLog . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE GuildsLogs SET { column } = ($1) WHERE guild_id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) @staticmethod async def update ( conn : asyncpg . Connection , guild : GuildLog ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_guild = await GuildLog . get_one ( conn , guild . guild_id ) if not existed_guild : return await GuildLog . insert_one ( conn , guild . guild_id ) diff_col = [] for col in existed_guild . __slots__ : if getattr ( existed_guild , col ) != getattr ( guild , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await GuildLog . update_column ( conn , guild . guild_id , change , getattr ( guild , change )) get_all async staticmethod get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]] Get all entries in the table. Source code in utils\\psql.py 335 336 337 338 339 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]]: '''Get all entries in the table.''' return await GuildLog . get_all_where ( conn , as_dict = as_dict ) get_all_where async staticmethod get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]] Get all entires in the table that matches the condition. Source code in utils\\psql.py 340 341 342 343 344 345 346 347 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM GuildsLogs; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = GuildLog if not as_dict else dict ) get_one async staticmethod get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ GuildLog , dict ] Get the first entry in the table that matches the pkey provided. Source code in utils\\psql.py 348 349 350 351 352 353 354 355 356 @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ GuildLog , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = GuildLog if not as_dict else dict ) insert_one async staticmethod insert_one ( conn : asyncpg . Connection , guild_id : int ) -> int Insert an entry into the table. Source code in utils\\psql.py 357 358 359 360 361 362 363 @staticmethod async def insert_one ( conn : asyncpg . Connection , guild_id : int ) -> int : '''Insert an entry into the table.''' # Only guild_id is required. query = insert_into_query ( \"GuildsLogs\" , 1 ) return await run_and_return_count ( conn , query , guild_id ) delete async staticmethod delete ( conn : asyncpg . Connection , id : int ) -> int Delete an entry in the table based on the provided key. Source code in utils\\psql.py 364 365 366 367 368 369 370 371 372 @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) update_column async staticmethod update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int Update a specific column with a new value. Warnings Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes Always prefer using other functions to update rather than this function if possible. Source code in utils\\psql.py 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in GuildLog . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE GuildsLogs SET { column } = ($1) WHERE guild_id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) update async staticmethod update ( conn : asyncpg . Connection , guild : GuildLog ) -> int Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead. Notes This function has its own transaction. Source code in utils\\psql.py 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 @staticmethod async def update ( conn : asyncpg . Connection , guild : GuildLog ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_guild = await GuildLog . get_one ( conn , guild . guild_id ) if not existed_guild : return await GuildLog . insert_one ( conn , guild . guild_id ) diff_col = [] for col in existed_guild . __slots__ : if getattr ( existed_guild , col ) != getattr ( guild , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await GuildLog . update_column ( conn , guild . guild_id , change , getattr ( guild , change )) User dataclass Bases: ClassToDict Represent an entry in the Users table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. Source code in utils\\psql.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 @dataclasses . dataclass ( slots = True ) class User ( ClassToDict ): '''Represent an entry in the `Users` table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. ''' id : int name : str is_whitelist : bool = True balance : int = 0 world : str = \"overworld\" last_travel : dt . datetime = None daily_streak : int = 0 last_daily : dt . datetime = None __WORLD_TYPE = ( \"overworld\" , \"nether\" , \"end\" ) __PREVENT_UPDATE = ( \"id\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ User ]: '''Get all entries in the table.''' return await User . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ User , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Users ORDER BY Users.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = User if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , as_dict : bool = False ) -> t . Union [ User , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM Users WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = User if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , user : User ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"Users\" , len ( user . __slots__ )) return await run_and_return_count ( conn , query , user . id , user . name , user . is_whitelist , user . balance , user . world , user . last_travel , user . daily_streak , user . last_daily ) @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Users WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in User . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Users SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) @staticmethod async def update_balance ( conn : asyncpg . Connection , id : int , new_balance : int ) -> int : if new_balance < 0 : # Might raise a warning here? return 0 return await User . update_column ( conn , id , \"balance\" , new_balance ) @staticmethod async def update_streak ( conn : asyncpg . Connection , id : int , new_streak : int ) -> int : if new_streak < 0 : # Might raise a warning here? return 0 return await User . update_column ( conn , id , \"daily_streak\" , new_streak ) @staticmethod async def add_money ( conn : asyncpg . Connection , id : int , amount : int ) -> int : if amount <= 0 : return 0 existed = await User . get_one ( conn , id ) if not existed : raise UpdateError ( f \"Trying to update entry ' { id } ', but it is not found.\" ) return await User . update_balance ( conn , id , existed . balance + amount ) @staticmethod async def remove_money ( conn : asyncpg . Connection , id : int , amount : int ) -> int : if amount <= 0 : return 0 existed = await User . get_one ( conn , id ) if not existed : raise UpdateError ( f \"Trying to update entry ' { id } ', but it is not found.\" ) if existed . balance <= amount : # Might raise a warning here? Idk. existed . balance = 0 else : existed . balance -= amount return await User . update_balance ( conn , id , existed . balance ) @staticmethod async def update ( conn : asyncpg . Connection , user : User ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_user = await User . get_one ( conn , user . id ) if not existed_user : return await User . insert_one ( conn , user ) diff_col = [] for col in existed_user . __slots__ : if getattr ( existed_user , col ) != getattr ( user , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await User . update_column ( conn , user . id , change , getattr ( user , change )) get_all async staticmethod get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ User ] Get all entries in the table. Source code in utils\\psql.py 438 439 440 441 442 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ User ]: '''Get all entries in the table.''' return await User . get_all_where ( conn , as_dict = as_dict ) get_all_where async staticmethod get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ User , dict ]] Get all entires in the table that matches the condition. Source code in utils\\psql.py 443 444 445 446 447 448 449 450 451 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ User , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Users ORDER BY Users.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = User if not as_dict else dict ) get_one async staticmethod get_one ( conn : asyncpg . Connection , id : int , as_dict : bool = False ) -> t . Union [ User , dict ] Get the first entry in the table that matches the pkey provided. Source code in utils\\psql.py 452 453 454 455 456 457 458 459 460 @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , as_dict : bool = False ) -> t . Union [ User , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM Users WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = User if not as_dict else dict ) insert_one async staticmethod insert_one ( conn : asyncpg . Connection , user : User ) -> int Insert an entry into the table. Source code in utils\\psql.py 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 @staticmethod async def insert_one ( conn : asyncpg . Connection , user : User ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"Users\" , len ( user . __slots__ )) return await run_and_return_count ( conn , query , user . id , user . name , user . is_whitelist , user . balance , user . world , user . last_travel , user . daily_streak , user . last_daily ) delete async staticmethod delete ( conn : asyncpg . Connection , id : int ) -> int Delete an entry in the table based on the provided key. Source code in utils\\psql.py 476 477 478 479 480 481 482 483 484 @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Users WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) update_column async staticmethod update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int Update a specific column with a new value. Warnings Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes Always prefer using other functions to update rather than this function if possible. Source code in utils\\psql.py 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in User . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Users SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) update async staticmethod update ( conn : asyncpg . Connection , user : User ) -> int Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead. Notes This function has its own transaction. Source code in utils\\psql.py 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 @staticmethod async def update ( conn : asyncpg . Connection , user : User ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_user = await User . get_one ( conn , user . id ) if not existed_user : return await User . insert_one ( conn , user ) diff_col = [] for col in existed_user . __slots__ : if getattr ( existed_user , col ) != getattr ( user , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await User . update_column ( conn , user . id , change , getattr ( user , change )) Reminders dataclass Bases: ClassToDict Represent an entry in the Reminders table along with possible operations related to the table. Source code in utils\\psql.py 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 @dataclasses . dataclass ( slots = True ) class Reminders ( ClassToDict ): '''Represent an entry in the `Reminders` table along with possible operations related to the table.''' remind_id : int user_id : int awake_time : dt . datetime message : str __PREVENT_UPDATE = ( \"remind_id\" , \"user_id\" ) @staticmethod async def get_user_reminders ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders a user have.''' query = \"\"\" SELECT * FROM Reminders WHERE user_id = ($1); \"\"\" result = await conn . fetch ( query , user_id ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] @staticmethod async def get_reminders ( conn : asyncpg . Connection , lower_time : dt . datetime , upper_time : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders within `(lower_time, upper_time]`.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time > ($1) AND awake_time <= ($2); \"\"\" result = await conn . fetch ( query , lower_time , upper_time ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] @staticmethod async def get_past_reminders ( conn : asyncpg . Connection , now : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders that are supposed to be cleared before the time provided.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time < ($1); \"\"\" result = await conn . fetch ( query , now ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] @staticmethod async def insert_reminder ( conn : asyncpg . Connection , user_id : int , when : dt . datetime , message : str ) -> int : '''Insert a reminder entry.''' query = \"\"\" INSERT INTO Reminders (user_id, awake_time, message) VALUES ($1, $2, $3); \"\"\" return await run_and_return_count ( conn , query , user_id , when , message ) @staticmethod async def delete_reminder ( conn : asyncpg . Connection , remind_id : int , user_id : int ) -> int : '''Delete a reminder entry.''' # Although remind_id is sufficient, user_id is to make sure a user can't remove another reminder. query = \"\"\" DELETE FROM Reminders WHERE remind_id = ($1) AND user_id = ($2); \"\"\" return await run_and_return_count ( conn , query , remind_id , user_id ) get_user_reminders async staticmethod get_user_reminders ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]] Get a list of reminders a user have. Source code in utils\\psql.py 582 583 584 585 586 587 588 589 590 591 592 @staticmethod async def get_user_reminders ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders a user have.''' query = \"\"\" SELECT * FROM Reminders WHERE user_id = ($1); \"\"\" result = await conn . fetch ( query , user_id ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] get_reminders async staticmethod get_reminders ( conn : asyncpg . Connection , lower_time : dt . datetime , upper_time : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]] Get a list of reminders within (lower_time, upper_time] . Source code in utils\\psql.py 593 594 595 596 597 598 599 600 601 602 603 @staticmethod async def get_reminders ( conn : asyncpg . Connection , lower_time : dt . datetime , upper_time : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders within `(lower_time, upper_time]`.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time > ($1) AND awake_time <= ($2); \"\"\" result = await conn . fetch ( query , lower_time , upper_time ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] get_past_reminders async staticmethod get_past_reminders ( conn : asyncpg . Connection , now : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]] Get a list of reminders that are supposed to be cleared before the time provided. Source code in utils\\psql.py 604 605 606 607 608 609 610 611 612 613 614 @staticmethod async def get_past_reminders ( conn : asyncpg . Connection , now : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders that are supposed to be cleared before the time provided.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time < ($1); \"\"\" result = await conn . fetch ( query , now ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] insert_reminder async staticmethod insert_reminder ( conn : asyncpg . Connection , user_id : int , when : dt . datetime , message : str ) -> int Insert a reminder entry. Source code in utils\\psql.py 615 616 617 618 619 620 621 622 623 @staticmethod async def insert_reminder ( conn : asyncpg . Connection , user_id : int , when : dt . datetime , message : str ) -> int : '''Insert a reminder entry.''' query = \"\"\" INSERT INTO Reminders (user_id, awake_time, message) VALUES ($1, $2, $3); \"\"\" return await run_and_return_count ( conn , query , user_id , when , message ) delete_reminder async staticmethod delete_reminder ( conn : asyncpg . Connection , remind_id : int , user_id : int ) -> int Delete a reminder entry. Source code in utils\\psql.py 624 625 626 627 628 629 630 631 632 633 @staticmethod async def delete_reminder ( conn : asyncpg . Connection , remind_id : int , user_id : int ) -> int : '''Delete a reminder entry.''' # Although remind_id is sufficient, user_id is to make sure a user can't remove another reminder. query = \"\"\" DELETE FROM Reminders WHERE remind_id = ($1) AND user_id = ($2); \"\"\" return await run_and_return_count ( conn , query , remind_id , user_id ) Item dataclass Bases: ClassToDict Represent an entry in the Items table along with possible operations related to the table. This is mostly used for the bot's cache purpose. If you're using this directly in a code, you're probably doing it wrong. Source code in utils\\psql.py 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 @dataclasses . dataclass ( slots = True ) class Item ( ClassToDict ): '''Represent an entry in the `Items` table along with possible operations related to the table. This is mostly used for the bot's cache purpose. If you're using this directly in a code, you're probably doing it wrong. ''' id : str sort_id : int name : str emoji : str description : str rarity : str sell_price : int buy_price : t . Optional [ int ] = None aliases : list [ str ] = dataclasses . field ( default_factory = list ) durability : int = None __PREVENT_UPDATE = ( \"id\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]]: '''Get all entries in the table.''' return await Item . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Item ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Items ORDER by sort_id; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Item if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ]: '''Get the first entry in the table that matches the condition.''' query = \"\"\" SELECT * FROM Items WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Item if not as_dict else dict ) @staticmethod async def get_by_name ( conn : asyncpg . Connection , name_or_alias : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ]: '''Get the first item that has its name/aliases match the provided.''' def filter_name_alias ( record : Item ): return record . name . lower () == name_or_alias . lower () or name_or_alias . lower () in [ alias . lower () for alias in record . aliases ] res = await Item . get_all_where ( conn , where = filter_name_alias , as_dict = as_dict ) assert len ( res ) <= 1 if res : return res [ 0 ] return None @staticmethod async def insert_one ( conn : asyncpg . Connection , item : Item ): '''Insert an entry into the table.''' query = insert_into_query ( \"Items\" , len ( item . __slots__ )) return await run_and_return_count ( conn , query , item . id , item . sort_id , item . name , item . aliases , item . emoji , item . description , item . rarity , item . buy_price , item . sell_price , item . durability , ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Item . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Items SET { column } = ($2) WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id , new_value ) @staticmethod async def update ( conn : asyncpg . Connection , item : Item ): '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_item = await Item . get_one ( conn , item . id ) if existing_item is None : await Item . insert_one ( conn , item ) logger . info ( \"Loaded new item ' %s ' into the database.\" , item . id ) else : diff_col = [] for col in existing_item . __slots__ : if getattr ( existing_item , col ) != getattr ( item , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Item . update_column ( conn , item . id , change , getattr ( item , change )) if diff_col : logger . info ( \"Updated item ' %s ' in the following columns: %s .\" , item . id , diff_col ) get_all async staticmethod get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]] Get all entries in the table. Source code in utils\\psql.py 655 656 657 658 659 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]]: '''Get all entries in the table.''' return await Item . get_all_where ( conn , as_dict = as_dict ) get_all_where async staticmethod get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Item ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]] Get all entires in the table that matches the condition. Source code in utils\\psql.py 660 661 662 663 664 665 666 667 668 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Item ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Items ORDER by sort_id; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Item if not as_dict else dict ) get_one async staticmethod get_one ( conn : asyncpg . Connection , id : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ] Get the first entry in the table that matches the condition. Source code in utils\\psql.py 669 670 671 672 673 674 675 676 677 @staticmethod async def get_one ( conn : asyncpg . Connection , id : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ]: '''Get the first entry in the table that matches the condition.''' query = \"\"\" SELECT * FROM Items WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Item if not as_dict else dict ) get_by_name async staticmethod get_by_name ( conn : asyncpg . Connection , name_or_alias : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ] Get the first item that has its name/aliases match the provided. Source code in utils\\psql.py 678 679 680 681 682 683 684 685 686 687 688 689 690 @staticmethod async def get_by_name ( conn : asyncpg . Connection , name_or_alias : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ]: '''Get the first item that has its name/aliases match the provided.''' def filter_name_alias ( record : Item ): return record . name . lower () == name_or_alias . lower () or name_or_alias . lower () in [ alias . lower () for alias in record . aliases ] res = await Item . get_all_where ( conn , where = filter_name_alias , as_dict = as_dict ) assert len ( res ) <= 1 if res : return res [ 0 ] return None insert_one async staticmethod insert_one ( conn : asyncpg . Connection , item : Item ) Insert an entry into the table. Source code in utils\\psql.py 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 @staticmethod async def insert_one ( conn : asyncpg . Connection , item : Item ): '''Insert an entry into the table.''' query = insert_into_query ( \"Items\" , len ( item . __slots__ )) return await run_and_return_count ( conn , query , item . id , item . sort_id , item . name , item . aliases , item . emoji , item . description , item . rarity , item . buy_price , item . sell_price , item . durability , ) update_column async staticmethod update_column ( conn : asyncpg . Connection , id : str , column : str , new_value ) -> int Update a specific column with a new value. Warnings Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes Always prefer using other functions to update rather than this function if possible. Source code in utils\\psql.py 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 @staticmethod async def update_column ( conn : asyncpg . Connection , id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Item . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Items SET { column } = ($2) WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id , new_value ) update async staticmethod update ( conn : asyncpg . Connection , item : Item ) Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead. Notes This function has its own transaction. Source code in utils\\psql.py 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 @staticmethod async def update ( conn : asyncpg . Connection , item : Item ): '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_item = await Item . get_one ( conn , item . id ) if existing_item is None : await Item . insert_one ( conn , item ) logger . info ( \"Loaded new item ' %s ' into the database.\" , item . id ) else : diff_col = [] for col in existing_item . __slots__ : if getattr ( existing_item , col ) != getattr ( item , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Item . update_column ( conn , item . id , change , getattr ( item , change )) if diff_col : logger . info ( \"Updated item ' %s ' in the following columns: %s .\" , item . id , diff_col ) Inventory dataclass Bases: ClassToDict Represent an entry in the UserInventory table along with possible operations related to the table. Source code in utils\\psql.py 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 @dataclasses . dataclass ( slots = True ) class Inventory ( ClassToDict ): '''Represent an entry in the `UserInventory` table along with possible operations related to the table.''' user_id : int item_id : str amount : int __PREVENT_UPDATE = ( \"user_id\" , \"item_id\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entries in the table.''' return await Inventory . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Inventory ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM UserInventory ORDER BY amount DESC; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Inventory if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Inventory , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM UserInventory WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , item_id , result_type = Inventory if not as_dict else dict ) @staticmethod async def get_user_inventory ( conn , user_id : int , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entries in the table that belongs to a user.''' return await Inventory . get_all_where ( conn , where = lambda r : r . user_id == user_id , as_dict = as_dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"UserInventory\" , len ( Inventory . __slots__ )) return await run_and_return_count ( conn , query , inventory . user_id , inventory . item_id , inventory . amount ) @staticmethod async def delete ( conn : asyncpg . Connection , user_id : int , item_id : str ) -> int : query = \"\"\" DELETE FROM UserInventory WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id ) @staticmethod async def update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Inventory . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE UserInventory SET { column } = ($3) WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id , new_value ) @staticmethod async def add ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int : '''Add item into the user's inventory. Notes ----- This should be preferred over `Inventory.insert_one()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user_id : int The user's id to insert. item_id : str The item's id to insert. amount : int, optional The amount of items to add. Default to 1. Returns ------- int The number of entries affected. Should be 1 or 0. ''' existed = await Inventory . get_one ( conn , user_id , item_id ) if not existed : return await Inventory . insert_one ( conn , Inventory ( user_id , item_id , amount )) else : return await Inventory . update_column ( conn , user_id , item_id , \"amount\" , existed . amount + amount ) @staticmethod async def remove ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int : '''Remove item from the user's inventory. Notes ----- This should be preferred over `Inventory.delete()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user_id : int The user's id to insert. item_id : str The item's id to insert. amount : int, optional The amount of items to remove. Default to 1. Returns ------- int The number of entries affected. Should be 1 or 0. ''' existed = await Inventory . get_one ( conn , user_id , item_id ) if not existed : return 0 elif existed . amount <= amount : return await Inventory . delete ( conn , user_id , item_id ) else : return await Inventory . update_column ( conn , user_id , item_id , \"amount\" , existed . amount - amount ) @staticmethod async def update ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_inv = await Inventory . get_one ( conn , inventory . user_id , inventory . item_id ) if not existing_inv : return await Inventory . insert_one ( conn , inventory ) if inventory . amount <= 0 : return await Inventory . delete ( conn , inventory . user_id , inventory . item_id ) diff_col = [] for col in existing_inv . __slots__ : if col in ( \"user_id\" , \"item_id\" , \"amount\" ): if getattr ( existing_inv , col ) != getattr ( inventory , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Inventory . update_column ( conn , inventory . user_id , inventory . item_id , change , getattr ( inventory , change )) get_all async staticmethod get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]] Get all entries in the table. Source code in utils\\psql.py 768 769 770 771 772 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entries in the table.''' return await Inventory . get_all_where ( conn , as_dict = as_dict ) get_all_where async staticmethod get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Inventory ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]] Get all entires in the table that matches the condition. Source code in utils\\psql.py 773 774 775 776 777 778 779 780 781 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Inventory ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM UserInventory ORDER BY amount DESC; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Inventory if not as_dict else dict ) get_one async staticmethod get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Inventory , dict ] Get the first entry in the table that matches the pkey provided. Source code in utils\\psql.py 782 783 784 785 786 787 788 789 790 791 @staticmethod async def get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Inventory , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM UserInventory WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , item_id , result_type = Inventory if not as_dict else dict ) get_user_inventory async staticmethod get_user_inventory ( conn , user_id : int , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]] Get all entries in the table that belongs to a user. Source code in utils\\psql.py 792 793 794 795 796 @staticmethod async def get_user_inventory ( conn , user_id : int , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entries in the table that belongs to a user.''' return await Inventory . get_all_where ( conn , where = lambda r : r . user_id == user_id , as_dict = as_dict ) insert_one async staticmethod insert_one ( conn : asyncpg . Connection , inventory : Inventory ) -> int Insert an entry into the table. Source code in utils\\psql.py 797 798 799 800 801 802 @staticmethod async def insert_one ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"UserInventory\" , len ( Inventory . __slots__ )) return await run_and_return_count ( conn , query , inventory . user_id , inventory . item_id , inventory . amount ) update_column async staticmethod update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int Update a specific column with a new value. Warnings Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes Always prefer using other functions to update rather than this function if possible. Source code in utils\\psql.py 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 @staticmethod async def update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Inventory . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE UserInventory SET { column } = ($3) WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id , new_value ) add async staticmethod add ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int Add item into the user's inventory. Notes This should be preferred over Inventory.insert_one() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required user_id int The user's id to insert. required item_id str The item's id to insert. required amount int , optional The amount of items to add. Default to 1. 1 Returns: Type Description int The number of entries affected. Should be 1 or 0. Source code in utils\\psql.py 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 @staticmethod async def add ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int : '''Add item into the user's inventory. Notes ----- This should be preferred over `Inventory.insert_one()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user_id : int The user's id to insert. item_id : str The item's id to insert. amount : int, optional The amount of items to add. Default to 1. Returns ------- int The number of entries affected. Should be 1 or 0. ''' existed = await Inventory . get_one ( conn , user_id , item_id ) if not existed : return await Inventory . insert_one ( conn , Inventory ( user_id , item_id , amount )) else : return await Inventory . update_column ( conn , user_id , item_id , \"amount\" , existed . amount + amount ) remove async staticmethod remove ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int Remove item from the user's inventory. Notes This should be preferred over Inventory.delete() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required user_id int The user's id to insert. required item_id str The item's id to insert. required amount int , optional The amount of items to remove. Default to 1. 1 Returns: Type Description int The number of entries affected. Should be 1 or 0. Source code in utils\\psql.py 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 @staticmethod async def remove ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int : '''Remove item from the user's inventory. Notes ----- This should be preferred over `Inventory.delete()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user_id : int The user's id to insert. item_id : str The item's id to insert. amount : int, optional The amount of items to remove. Default to 1. Returns ------- int The number of entries affected. Should be 1 or 0. ''' existed = await Inventory . get_one ( conn , user_id , item_id ) if not existed : return 0 elif existed . amount <= amount : return await Inventory . delete ( conn , user_id , item_id ) else : return await Inventory . update_column ( conn , user_id , item_id , \"amount\" , existed . amount - amount ) update async staticmethod update ( conn : asyncpg . Connection , inventory : Inventory ) -> int Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead. Notes This function has its own transaction. Source code in utils\\psql.py 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 @staticmethod async def update ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_inv = await Inventory . get_one ( conn , inventory . user_id , inventory . item_id ) if not existing_inv : return await Inventory . insert_one ( conn , inventory ) if inventory . amount <= 0 : return await Inventory . delete ( conn , inventory . user_id , inventory . item_id ) diff_col = [] for col in existing_inv . __slots__ : if col in ( \"user_id\" , \"item_id\" , \"amount\" ): if getattr ( existing_inv , col ) != getattr ( inventory , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Inventory . update_column ( conn , inventory . user_id , inventory . item_id , change , getattr ( inventory , change )) Equipment dataclass Bases: ClassToDict Represent an entry in the UserEquipment table along with possible operations related to the table. Source code in utils\\psql.py 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 @dataclasses . dataclass ( slots = True ) class Equipment ( ClassToDict ): '''Represent an entry in the `UserEquipment` table along with possible operations related to the table.''' user_id : int item_id : str eq_type : str remain_durability : int __EQUIPMENT_TYPE__ = ( \"_sword\" , \"_pickaxe\" , \"_axe\" , \"_potion\" ) __PREVENT_UPDATE = ( \"user_id\" , \"item_id\" , \"eq_type\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: '''Get all entries in the table.''' return await Equipment . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Equipment ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM UserEquipment; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Equipment if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM UserEquipment WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , item_id , result_type = Equipment if not as_dict else dict ) @staticmethod async def get_equipment ( conn : asyncpg . Connection , user_id : int , equipment_type : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ]: '''Get a user's equipment based on equipment type.''' query = \"\"\" SELECT * FROM UserEquipment WHERE user_id = ($1) AND eq_type = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , equipment_type , result_type = Equipment if not as_dict else dict ) @staticmethod async def get_user_equipments ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: return await Equipment . get_all_where ( conn , where = lambda r : r . user_id == user_id , as_dict = as_dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , equipment : Equipment ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"UserEquipment\" , len ( equipment . __slots__ )) return await run_and_return_count ( conn , query , equipment . user_id , equipment . item_id , equipment . eq_type , equipment . remain_durability ) @staticmethod async def transfer_from_inventory ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Transfer an equipment from the inventory. Warnings -------- This does not check whether the user already has that equipment. This must be checked by the user, otherwise an `asyncpg.UniqueViolationError` might be raised. Notes ----- This function already has its own transaction. There is no need to wrap a transaction for this function. Parameters ---------- conn : asyncpg.Connection The connection to use. inventory : Inventory The inventory wrapping the equipment. Returns ------- int The number of entries affected. Should be 1 or 0. Raises ------ asyncpg.UniqueViolationError The unique constraint on `(user_id, eq_type)` is violated. ''' is_equipment = False for eq_type in Equipment . __EQUIPMENT_TYPE__ : if eq_type in inventory . item_id : is_equipment = True item = await Item . get_one ( conn , inventory . item_id ) equipment = Equipment ( inventory . user_id , inventory . item_id , eq_type , item . durability ) break if not is_equipment : return 0 async with conn . transaction (): status = await Inventory . remove ( conn , inventory . user_id , inventory . item_id ) if status == 0 : return 0 # TODO: Add a check to see if the same equipment type is already there. return await Equipment . insert_one ( conn , equipment ) @staticmethod async def delete ( conn : asyncpg . Connection , user_id : int , item_id : str ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM UserEquipment WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id ) @staticmethod async def update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Equipment . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE UserEquipment SET { column } = ($3) WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id , new_value ) @staticmethod async def update_durability ( conn : asyncpg . Connection , user_id : int , item_id : str , new_durability : int ) -> int : '''Update an equipment's durability and remove if needed.''' if new_durability <= 0 : return await Equipment . delete ( conn , user_id , item_id ) return await Equipment . update_column ( conn , user_id , item_id , \"remain_durability\" , new_durability ) @staticmethod def is_equipment ( item_id : str ) -> bool : '''Check if the item is an equipment or not. Parameters ---------- item_id : str The item's id to check. Returns ------- bool Whether the item is an equipment or not. ''' for eq_type in Equipment . __EQUIPMENT_TYPE__ : if eq_type in item_id : return True return False @staticmethod def is_true_equipment ( item_id : str ) -> bool : return Equipment . is_equipment ( item_id ) and not Equipment . is_potion ( item_id ) @staticmethod def is_potion ( item_id : str ) -> bool : return \"_potion\" in item_id @staticmethod def get_equipment_type ( item_id : str ) -> t . Optional [ str ]: '''Return the equipment type of the equipment. Parameters ---------- item_id : str The item's id. Returns ------- t.Optional[str] The equipment type of the equipment, or `None` if it is not an equipment. ''' if not Equipment . is_equipment ( item_id ): return None return '_' + item_id . split ( '_' )[ - 1 ] get_all async staticmethod get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]] Get all entries in the table. Source code in utils\\psql.py 932 933 934 935 936 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: '''Get all entries in the table.''' return await Equipment . get_all_where ( conn , as_dict = as_dict ) get_all_where async staticmethod get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Equipment ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]] Get all entires in the table that matches the condition. Source code in utils\\psql.py 937 938 939 940 941 942 943 944 945 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Equipment ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM UserEquipment; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Equipment if not as_dict else dict ) get_one async staticmethod get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ] Get the first entry in the table that matches the pkey provided. Source code in utils\\psql.py 946 947 948 949 950 951 952 953 954 955 @staticmethod async def get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM UserEquipment WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , item_id , result_type = Equipment if not as_dict else dict ) get_equipment async staticmethod get_equipment ( conn : asyncpg . Connection , user_id : int , equipment_type : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ] Get a user's equipment based on equipment type. Source code in utils\\psql.py 956 957 958 959 960 961 962 963 964 965 @staticmethod async def get_equipment ( conn : asyncpg . Connection , user_id : int , equipment_type : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ]: '''Get a user's equipment based on equipment type.''' query = \"\"\" SELECT * FROM UserEquipment WHERE user_id = ($1) AND eq_type = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , equipment_type , result_type = Equipment if not as_dict else dict ) insert_one async staticmethod insert_one ( conn : asyncpg . Connection , equipment : Equipment ) -> int Insert an entry into the table. Source code in utils\\psql.py 969 970 971 972 973 974 @staticmethod async def insert_one ( conn : asyncpg . Connection , equipment : Equipment ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"UserEquipment\" , len ( equipment . __slots__ )) return await run_and_return_count ( conn , query , equipment . user_id , equipment . item_id , equipment . eq_type , equipment . remain_durability ) transfer_from_inventory async staticmethod transfer_from_inventory ( conn : asyncpg . Connection , inventory : Inventory ) -> int Transfer an equipment from the inventory. Warnings This does not check whether the user already has that equipment. This must be checked by the user, otherwise an asyncpg.UniqueViolationError might be raised. Notes This function already has its own transaction. There is no need to wrap a transaction for this function. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required inventory Inventory The inventory wrapping the equipment. required Returns: Type Description int The number of entries affected. Should be 1 or 0. Raises: Type Description asyncpg . UniqueViolationError The unique constraint on (user_id, eq_type) is violated. Source code in utils\\psql.py 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 @staticmethod async def transfer_from_inventory ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Transfer an equipment from the inventory. Warnings -------- This does not check whether the user already has that equipment. This must be checked by the user, otherwise an `asyncpg.UniqueViolationError` might be raised. Notes ----- This function already has its own transaction. There is no need to wrap a transaction for this function. Parameters ---------- conn : asyncpg.Connection The connection to use. inventory : Inventory The inventory wrapping the equipment. Returns ------- int The number of entries affected. Should be 1 or 0. Raises ------ asyncpg.UniqueViolationError The unique constraint on `(user_id, eq_type)` is violated. ''' is_equipment = False for eq_type in Equipment . __EQUIPMENT_TYPE__ : if eq_type in inventory . item_id : is_equipment = True item = await Item . get_one ( conn , inventory . item_id ) equipment = Equipment ( inventory . user_id , inventory . item_id , eq_type , item . durability ) break if not is_equipment : return 0 async with conn . transaction (): status = await Inventory . remove ( conn , inventory . user_id , inventory . item_id ) if status == 0 : return 0 # TODO: Add a check to see if the same equipment type is already there. return await Equipment . insert_one ( conn , equipment ) delete async staticmethod delete ( conn : asyncpg . Connection , user_id : int , item_id : str ) -> int Delete an entry in the table based on the provided key. Source code in utils\\psql.py 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 @staticmethod async def delete ( conn : asyncpg . Connection , user_id : int , item_id : str ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM UserEquipment WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id ) update_column async staticmethod update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int Update a specific column with a new value. Warnings Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes Always prefer using other functions to update rather than this function if possible. Source code in utils\\psql.py 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 @staticmethod async def update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Equipment . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE UserEquipment SET { column } = ($3) WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id , new_value ) update_durability async staticmethod update_durability ( conn : asyncpg . Connection , user_id : int , item_id : str , new_durability : int ) -> int Update an equipment's durability and remove if needed. Source code in utils\\psql.py 1057 1058 1059 1060 1061 1062 1063 @staticmethod async def update_durability ( conn : asyncpg . Connection , user_id : int , item_id : str , new_durability : int ) -> int : '''Update an equipment's durability and remove if needed.''' if new_durability <= 0 : return await Equipment . delete ( conn , user_id , item_id ) return await Equipment . update_column ( conn , user_id , item_id , \"remain_durability\" , new_durability ) is_equipment staticmethod is_equipment ( item_id : str ) -> bool Check if the item is an equipment or not. Parameters: Name Type Description Default item_id str The item's id to check. required Returns: Type Description bool Whether the item is an equipment or not. Source code in utils\\psql.py 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 @staticmethod def is_equipment ( item_id : str ) -> bool : '''Check if the item is an equipment or not. Parameters ---------- item_id : str The item's id to check. Returns ------- bool Whether the item is an equipment or not. ''' for eq_type in Equipment . __EQUIPMENT_TYPE__ : if eq_type in item_id : return True return False get_equipment_type staticmethod get_equipment_type ( item_id : str ) -> t . Optional [ str ] Return the equipment type of the equipment. Parameters: Name Type Description Default item_id str The item's id. required Returns: Type Description t . Optional [ str ] The equipment type of the equipment, or None if it is not an equipment. Source code in utils\\psql.py 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 @staticmethod def get_equipment_type ( item_id : str ) -> t . Optional [ str ]: '''Return the equipment type of the equipment. Parameters ---------- item_id : str The item's id. Returns ------- t.Optional[str] The equipment type of the equipment, or `None` if it is not an equipment. ''' if not Equipment . is_equipment ( item_id ): return None return '_' + item_id . split ( '_' )[ - 1 ] record_to_type record_to_type ( / , record : asyncpg . Record , result_type : t . Type [ T ] = dict ) -> T Convert a asyncpg.Record into a dict or None if the object is already None . This is for convenience purpose, where dict(Record) will return {} which is not an accurate representation of empty. obj is None or obj is not None is more obvious to anyone than bool(obj) or not bool(obj) . Parameters: Name Type Description Default record asyncpg . Record The record to convert. required result_type t . Type The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a dict . Default to dict . dict Return t.Optional[T] Either None or result_type . Source code in utils\\psql.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def record_to_type ( record : asyncpg . Record , / , result_type : t . Type [ T ] = dict ) -> T : '''Convert a `asyncpg.Record` into a `dict` or `None` if the object is already `None`. This is for convenience purpose, where `dict(Record)` will return `{}` which is not an accurate representation of empty. `obj is None` or `obj is not None` is more obvious to anyone than `bool(obj)` or `not bool(obj)`. Parameters ---------- record : asyncpg.Record The record to convert. result_type : t.Type The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a `dict`. Default to `dict`. Return ------ t.Optional[T] Either `None` or `result_type`. ''' if record is None : return None d = dict ( record ) if result_type is dict : return d return result_type ( ** d ) legacy_insert_into async legacy_insert_into ( conn , table_name : str , * args ) Insert values into table_name . Warning: This function is an old function from pre-rewrite. It is advised to do the logic by yourself. Source code in utils\\psql.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 async def legacy_insert_into ( conn , table_name : str , * args ): ''' Insert values into `table_name`. Warning: This function is an old function from pre-rewrite. It is advised to do the logic by yourself. ''' arg_str = \"(\" # max(*args, key = len): Get the longest tuple in the list. for j in range ( len ( max ( * args , key = len ))): arg_str += f \"$ { j + 1 } , \" arg_str = arg_str [: - 2 ] + ')' await conn . executemany ( f ''' INSERT INTO { table_name } VALUES { arg_str } ''' , * args ) insert_into_query insert_into_query ( table_name : str , len_col : int ) -> str Return the query to insert into a table that has len_col columns. Parameters: Name Type Description Default table_name str The table to insert. required len_col int How many column does the table have. required Returns: Type Description str An INSERT SQL statement with query formatter ready to use in .execute() Source code in utils\\psql.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def insert_into_query ( table_name : str , len_col : int ) -> str : '''Return the query to insert into a table that has `len_col` columns. Parameters ---------- table_name : str The table to insert. len_col : int How many column does the table have. Returns ------- str An INSERT SQL statement with query formatter ready to use in `.execute()` ''' arg_str = \"(\" for index in range ( len_col ): arg_str += f \"$ { index + 1 } , \" arg_str = arg_str [: - 2 ] + ')' return f \"INSERT INTO { table_name } VALUES { arg_str } ;\" __get_all__ async __get_all__ ( conn : asyncpg . Connection , query : str , * , where : t . Callable [[ T ], bool ] = lambda r : True , result_type : t . Type [ T ] = dict ) -> list [ T ] Run a SELECT statement and return a list of objects. This should NOT be used outside of the module. Instead, use table_name.get_all() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required query str The SELECT statement to run. This should not contain WHERE clause. Conditions should be set in where parameter. required where t . Callable [[ dict ], bool ] Additional conditions to filter. By default, no condition is applied (always return True ). lambda r: True result_type t . Type [ T ] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a dict . Default to dict . dict Returns: Type Description list [ T ] A list of result_type or empty list. Source code in utils\\psql.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 async def __get_all__ ( conn : asyncpg . Connection , query : str , * , where : t . Callable [[ T ], bool ] = lambda r : True , result_type : t . Type [ T ] = dict ) -> list [ T ]: '''Run a `SELECT` statement and return a list of objects. This should NOT be used outside of the module. Instead, use `table_name.get_all()`. Parameters ---------- conn : asyncpg.Connection The connection to use. query : str The `SELECT` statement to run. This should not contain `WHERE` clause. Conditions should be set in `where` parameter. where : t.Callable[[dict], bool] Additional conditions to filter. By default, no condition is applied (always return `True`). result_type : t.Type[T] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a `dict`. Default to `dict`. Returns ------- list[T] A list of `result_type` or empty list. ''' result = await conn . fetch ( query ) l = [] record_obj = None for record in result : # NOTE: This code is for handling dict case; will remove soon. #record_obj = record_to_type(record) #if record_obj is None or (record_obj is not None and where(record_obj)): # l.append(record_obj) record_obj = record_to_type ( record , result_type ) if record_obj is None or ( record_obj is not None and where ( record_obj )): l . append ( record_obj ) return l __get_one__ async __get_one__ ( conn : asyncpg . Connection , query : str , * constraints , result_type : t . Type [ T ] = dict ) -> t . Optional [ T ] Run a SELECT statement and return the first object that matches the constraints. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required query str The SELECT statement to run. This should contain a WHERE clause. required *constraints str Arguments to be formatted into the query. () result_type t . Type [ T ] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a dict . Default to dict . dict Returns: Type Description t . Optional [ T ] A result_type or None if no object is found. Source code in utils\\psql.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 async def __get_one__ ( conn : asyncpg . Connection , query : str , * constraints , result_type : t . Type [ T ] = dict ) -> t . Optional [ T ]: '''Run a `SELECT` statement and return the first object that matches the constraints. Parameters ---------- conn : asyncpg.Connection The connection to use. query : str The `SELECT` statement to run. This should contain a `WHERE` clause. *constraints : str Arguments to be formatted into the query. result_type : t.Type[T] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a `dict`. Default to `dict`. Returns ------- t.Optional[T] A `result_type` or `None` if no object is found. ''' record = await conn . fetchrow ( query , * constraints ) return record_to_type ( record , result_type ) run_and_return_count async run_and_return_count ( conn : asyncpg . Connection , query : str , * args , ** kwargs ) -> t . Optional [ int ] Execute an SQL operation and return the number of entries affected. Warnings This is meant to run INSERT, DELETE, and UPDATE statements. Other statement might or might not work. Parameters: Name Type Description Default conn asyncpg . Connection The connection to execute. required *args tuple The arguments to pass into conn.execute() () **kwargs The arguments to pass into conn.execute() {} Returns: Type Description t . Optional [ int ] The number of rows affected. If the operation doesn't return the row count, None is returned. Source code in utils\\psql.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 async def run_and_return_count ( conn : asyncpg . Connection , query : str , * args , ** kwargs ) -> t . Optional [ int ]: '''Execute an SQL operation and return the number of entries affected. Warnings -------- This is meant to run INSERT, DELETE, and UPDATE statements. Other statement might or might not work. Parameters ---------- conn : asyncpg.Connection The connection to execute. *args : tuple The arguments to pass into `conn.execute()` **kwargs: dict The arguments to pass into `conn.execute()` Returns ------- t.Optional[int] The number of rows affected. If the operation doesn't return the row count, `None` is returned. ''' status = await conn . execute ( query , * args , ** kwargs ) # INSERT returns \"INSERT oid count\". try : count = int ( status . split ()[ - 1 ]) return count except ValueError : return None","title":"psql.py"},{"location":"dev/psql/#utils.psql.Error","text":"Bases: Exception A base error for high-level PostgreSQL operations. Source code in utils\\psql.py 25 26 class Error ( Exception ): '''A base error for high-level PostgreSQL operations.'''","title":"Error"},{"location":"dev/psql/#utils.psql.GetError","text":"Bases: Error A base error for SELECT operations.","title":"GetError"},{"location":"dev/psql/#utils.psql.GetError--notes","text":"This should only be raised when get_x() is implicitly called. This will NOT be raised if the user explicitly calls get_x() . Source code in utils\\psql.py 28 29 30 31 32 33 34 35 class GetError ( Error ): '''A base error for SELECT operations. Notes ----- This should only be raised when `get_x()` is implicitly called. This will NOT be raised if the user explicitly calls `get_x()`. '''","title":"Notes"},{"location":"dev/psql/#utils.psql.InsertError","text":"Bases: Error A base error for INSERT operations. Source code in utils\\psql.py 37 38 class InsertError ( Error ): '''A base error for INSERT operations.'''","title":"InsertError"},{"location":"dev/psql/#utils.psql.DeleteError","text":"Bases: Error A base error for DELETE operations. Source code in utils\\psql.py 40 41 class DeleteError ( Error ): '''A base error for DELETE operations.'''","title":"DeleteError"},{"location":"dev/psql/#utils.psql.UpdateError","text":"Bases: Error A base error for UPDATE operations. Source code in utils\\psql.py 43 44 class UpdateError ( Error ): '''A base error for UPDATE operations.'''","title":"UpdateError"},{"location":"dev/psql/#utils.psql.DuplicateArrayElement","text":"Bases: UpdateError Raised when trying to add an element that's already available in a unique-only list (set). Source code in utils\\psql.py 46 47 class DuplicateArrayElement ( UpdateError ): '''Raised when trying to add an element that's already available in a unique-only list (set).'''","title":"DuplicateArrayElement"},{"location":"dev/psql/#utils.psql.Guild","text":"Bases: ClassToDict Represent an entry in the Guilds table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. Source code in utils\\psql.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 @dataclasses . dataclass ( slots = True ) class Guild ( ClassToDict ): '''Represent an entry in the `Guilds` table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. ''' id : int name : str is_whitelist : bool = True prefix : str = '$' __PREVENT_UPDATE = ( \"id\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entries in the table.''' return await Guild . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Guilds ORDER BY Guilds.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Guild if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ Guild , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM Guilds WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Guild if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , guild : Guild ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"Guilds\" , len ( guild . __slots__ )) return await run_and_return_count ( conn , query , guild . id , guild . name , guild . is_whitelist , guild . prefix ) @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Guilds WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Guild . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Guilds SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) @staticmethod async def update ( conn : asyncpg . Connection , guild : Guild ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_guild = await Guild . get_one ( conn , guild . id ) if not existed_guild : return await Guild . insert_one ( conn , guild ) diff_col = [] for col in existed_guild . __slots__ : if getattr ( existed_guild , col ) != getattr ( guild , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Guild . update_column ( conn , guild . id , change , getattr ( guild , change ))","title":"Guild"},{"location":"dev/psql/#utils.psql.Guild.get_all","text":"get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]] Get all entries in the table. Source code in utils\\psql.py 222 223 224 225 226 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entries in the table.''' return await Guild . get_all_where ( conn , as_dict = as_dict )","title":"get_all()"},{"location":"dev/psql/#utils.psql.Guild.get_all_where","text":"get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]] Get all entires in the table that matches the condition. Source code in utils\\psql.py 227 228 229 230 231 232 233 234 235 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Guild , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Guilds ORDER BY Guilds.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Guild if not as_dict else dict )","title":"get_all_where()"},{"location":"dev/psql/#utils.psql.Guild.get_one","text":"get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ Guild , dict ] Get the first entry in the table that matches the pkey provided. Source code in utils\\psql.py 236 237 238 239 240 241 242 243 244 @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ Guild , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM Guilds WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Guild if not as_dict else dict )","title":"get_one()"},{"location":"dev/psql/#utils.psql.Guild.insert_one","text":"insert_one ( conn : asyncpg . Connection , guild : Guild ) -> int Insert an entry into the table. Source code in utils\\psql.py 245 246 247 248 249 250 @staticmethod async def insert_one ( conn : asyncpg . Connection , guild : Guild ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"Guilds\" , len ( guild . __slots__ )) return await run_and_return_count ( conn , query , guild . id , guild . name , guild . is_whitelist , guild . prefix )","title":"insert_one()"},{"location":"dev/psql/#utils.psql.Guild.delete","text":"delete ( conn : asyncpg . Connection , id : int ) -> int Delete an entry in the table based on the provided key. Source code in utils\\psql.py 251 252 253 254 255 256 257 258 259 @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Guilds WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id )","title":"delete()"},{"location":"dev/psql/#utils.psql.Guild.update_column","text":"update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int Update a specific column with a new value.","title":"update_column()"},{"location":"dev/psql/#utils.psql.Guild.update_column--warnings","text":"Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL.","title":"Warnings"},{"location":"dev/psql/#utils.psql.Guild.update_column--notes","text":"Always prefer using other functions to update rather than this function if possible. Source code in utils\\psql.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Guild . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Guilds SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id )","title":"Notes"},{"location":"dev/psql/#utils.psql.Guild.update","text":"update ( conn : asyncpg . Connection , guild : Guild ) -> int Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead.","title":"update()"},{"location":"dev/psql/#utils.psql.Guild.update--notes","text":"This function has its own transaction. Source code in utils\\psql.py 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 @staticmethod async def update ( conn : asyncpg . Connection , guild : Guild ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_guild = await Guild . get_one ( conn , guild . id ) if not existed_guild : return await Guild . insert_one ( conn , guild ) diff_col = [] for col in existed_guild . __slots__ : if getattr ( existed_guild , col ) != getattr ( guild , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Guild . update_column ( conn , guild . id , change , getattr ( guild , change ))","title":"Notes"},{"location":"dev/psql/#utils.psql.GuildLog","text":"Bases: ClassToDict Represent an entry in the GuildsLogs table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. Source code in utils\\psql.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 @dataclasses . dataclass ( slots = True ) class GuildLog ( ClassToDict ): '''Represent an entry in the `GuildsLogs` table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. ''' guild_id : int log_channel : int = None guild_channel_create : bool = True guild_channel_delete : bool = True guild_channel_update : bool = True guild_ban : bool = True guild_unban : bool = True guild_update : bool = True member_join : bool = True member_leave : bool = True member_update : bool = True guild_bulk_message_delete : bool = True guild_message_delete : bool = True guild_message_update : bool = True role_create : bool = True role_delete : bool = True role_update : bool = True command_complete : bool = True command_error : bool = True __PREVENT_UPDATE = ( \"guild_id\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]]: '''Get all entries in the table.''' return await GuildLog . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM GuildsLogs; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = GuildLog if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ GuildLog , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = GuildLog if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , guild_id : int ) -> int : '''Insert an entry into the table.''' # Only guild_id is required. query = insert_into_query ( \"GuildsLogs\" , 1 ) return await run_and_return_count ( conn , query , guild_id ) @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in GuildLog . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE GuildsLogs SET { column } = ($1) WHERE guild_id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) @staticmethod async def update ( conn : asyncpg . Connection , guild : GuildLog ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_guild = await GuildLog . get_one ( conn , guild . guild_id ) if not existed_guild : return await GuildLog . insert_one ( conn , guild . guild_id ) diff_col = [] for col in existed_guild . __slots__ : if getattr ( existed_guild , col ) != getattr ( guild , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await GuildLog . update_column ( conn , guild . guild_id , change , getattr ( guild , change ))","title":"GuildLog"},{"location":"dev/psql/#utils.psql.GuildLog.get_all","text":"get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]] Get all entries in the table. Source code in utils\\psql.py 335 336 337 338 339 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]]: '''Get all entries in the table.''' return await GuildLog . get_all_where ( conn , as_dict = as_dict )","title":"get_all()"},{"location":"dev/psql/#utils.psql.GuildLog.get_all_where","text":"get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]] Get all entires in the table that matches the condition. Source code in utils\\psql.py 340 341 342 343 344 345 346 347 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ GuildLog , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM GuildsLogs; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = GuildLog if not as_dict else dict )","title":"get_all_where()"},{"location":"dev/psql/#utils.psql.GuildLog.get_one","text":"get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ GuildLog , dict ] Get the first entry in the table that matches the pkey provided. Source code in utils\\psql.py 348 349 350 351 352 353 354 355 356 @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , * , as_dict : bool = False ) -> t . Union [ GuildLog , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = GuildLog if not as_dict else dict )","title":"get_one()"},{"location":"dev/psql/#utils.psql.GuildLog.insert_one","text":"insert_one ( conn : asyncpg . Connection , guild_id : int ) -> int Insert an entry into the table. Source code in utils\\psql.py 357 358 359 360 361 362 363 @staticmethod async def insert_one ( conn : asyncpg . Connection , guild_id : int ) -> int : '''Insert an entry into the table.''' # Only guild_id is required. query = insert_into_query ( \"GuildsLogs\" , 1 ) return await run_and_return_count ( conn , query , guild_id )","title":"insert_one()"},{"location":"dev/psql/#utils.psql.GuildLog.delete","text":"delete ( conn : asyncpg . Connection , id : int ) -> int Delete an entry in the table based on the provided key. Source code in utils\\psql.py 364 365 366 367 368 369 370 371 372 @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM GuildsLogs WHERE guild_id = ($1); \"\"\" return await run_and_return_count ( conn , query , id )","title":"delete()"},{"location":"dev/psql/#utils.psql.GuildLog.update_column","text":"update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int Update a specific column with a new value.","title":"update_column()"},{"location":"dev/psql/#utils.psql.GuildLog.update_column--warnings","text":"Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL.","title":"Warnings"},{"location":"dev/psql/#utils.psql.GuildLog.update_column--notes","text":"Always prefer using other functions to update rather than this function if possible. Source code in utils\\psql.py 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in GuildLog . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE GuildsLogs SET { column } = ($1) WHERE guild_id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id )","title":"Notes"},{"location":"dev/psql/#utils.psql.GuildLog.update","text":"update ( conn : asyncpg . Connection , guild : GuildLog ) -> int Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead.","title":"update()"},{"location":"dev/psql/#utils.psql.GuildLog.update--notes","text":"This function has its own transaction. Source code in utils\\psql.py 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 @staticmethod async def update ( conn : asyncpg . Connection , guild : GuildLog ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_guild = await GuildLog . get_one ( conn , guild . guild_id ) if not existed_guild : return await GuildLog . insert_one ( conn , guild . guild_id ) diff_col = [] for col in existed_guild . __slots__ : if getattr ( existed_guild , col ) != getattr ( guild , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await GuildLog . update_column ( conn , guild . guild_id , change , getattr ( guild , change ))","title":"Notes"},{"location":"dev/psql/#utils.psql.User","text":"Bases: ClassToDict Represent an entry in the Users table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. Source code in utils\\psql.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 @dataclasses . dataclass ( slots = True ) class User ( ClassToDict ): '''Represent an entry in the `Users` table along with possible operations related to the table. It is advised to use the cache in the bot instead. These methods are for mostly cache construction. ''' id : int name : str is_whitelist : bool = True balance : int = 0 world : str = \"overworld\" last_travel : dt . datetime = None daily_streak : int = 0 last_daily : dt . datetime = None __WORLD_TYPE = ( \"overworld\" , \"nether\" , \"end\" ) __PREVENT_UPDATE = ( \"id\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ User ]: '''Get all entries in the table.''' return await User . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ User , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Users ORDER BY Users.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = User if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , as_dict : bool = False ) -> t . Union [ User , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM Users WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = User if not as_dict else dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , user : User ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"Users\" , len ( user . __slots__ )) return await run_and_return_count ( conn , query , user . id , user . name , user . is_whitelist , user . balance , user . world , user . last_travel , user . daily_streak , user . last_daily ) @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Users WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in User . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Users SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id ) @staticmethod async def update_balance ( conn : asyncpg . Connection , id : int , new_balance : int ) -> int : if new_balance < 0 : # Might raise a warning here? return 0 return await User . update_column ( conn , id , \"balance\" , new_balance ) @staticmethod async def update_streak ( conn : asyncpg . Connection , id : int , new_streak : int ) -> int : if new_streak < 0 : # Might raise a warning here? return 0 return await User . update_column ( conn , id , \"daily_streak\" , new_streak ) @staticmethod async def add_money ( conn : asyncpg . Connection , id : int , amount : int ) -> int : if amount <= 0 : return 0 existed = await User . get_one ( conn , id ) if not existed : raise UpdateError ( f \"Trying to update entry ' { id } ', but it is not found.\" ) return await User . update_balance ( conn , id , existed . balance + amount ) @staticmethod async def remove_money ( conn : asyncpg . Connection , id : int , amount : int ) -> int : if amount <= 0 : return 0 existed = await User . get_one ( conn , id ) if not existed : raise UpdateError ( f \"Trying to update entry ' { id } ', but it is not found.\" ) if existed . balance <= amount : # Might raise a warning here? Idk. existed . balance = 0 else : existed . balance -= amount return await User . update_balance ( conn , id , existed . balance ) @staticmethod async def update ( conn : asyncpg . Connection , user : User ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_user = await User . get_one ( conn , user . id ) if not existed_user : return await User . insert_one ( conn , user ) diff_col = [] for col in existed_user . __slots__ : if getattr ( existed_user , col ) != getattr ( user , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await User . update_column ( conn , user . id , change , getattr ( user , change ))","title":"User"},{"location":"dev/psql/#utils.psql.User.get_all","text":"get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ User ] Get all entries in the table. Source code in utils\\psql.py 438 439 440 441 442 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ User ]: '''Get all entries in the table.''' return await User . get_all_where ( conn , as_dict = as_dict )","title":"get_all()"},{"location":"dev/psql/#utils.psql.User.get_all_where","text":"get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ User , dict ]] Get all entires in the table that matches the condition. Source code in utils\\psql.py 443 444 445 446 447 448 449 450 451 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ dict ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ User , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Users ORDER BY Users.name; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = User if not as_dict else dict )","title":"get_all_where()"},{"location":"dev/psql/#utils.psql.User.get_one","text":"get_one ( conn : asyncpg . Connection , id : int , as_dict : bool = False ) -> t . Union [ User , dict ] Get the first entry in the table that matches the pkey provided. Source code in utils\\psql.py 452 453 454 455 456 457 458 459 460 @staticmethod async def get_one ( conn : asyncpg . Connection , id : int , as_dict : bool = False ) -> t . Union [ User , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM Users WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = User if not as_dict else dict )","title":"get_one()"},{"location":"dev/psql/#utils.psql.User.insert_one","text":"insert_one ( conn : asyncpg . Connection , user : User ) -> int Insert an entry into the table. Source code in utils\\psql.py 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 @staticmethod async def insert_one ( conn : asyncpg . Connection , user : User ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"Users\" , len ( user . __slots__ )) return await run_and_return_count ( conn , query , user . id , user . name , user . is_whitelist , user . balance , user . world , user . last_travel , user . daily_streak , user . last_daily )","title":"insert_one()"},{"location":"dev/psql/#utils.psql.User.delete","text":"delete ( conn : asyncpg . Connection , id : int ) -> int Delete an entry in the table based on the provided key. Source code in utils\\psql.py 476 477 478 479 480 481 482 483 484 @staticmethod async def delete ( conn : asyncpg . Connection , id : int ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM Users WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id )","title":"delete()"},{"location":"dev/psql/#utils.psql.User.update_column","text":"update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int Update a specific column with a new value.","title":"update_column()"},{"location":"dev/psql/#utils.psql.User.update_column--warnings","text":"Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL.","title":"Warnings"},{"location":"dev/psql/#utils.psql.User.update_column--notes","text":"Always prefer using other functions to update rather than this function if possible. Source code in utils\\psql.py 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 @staticmethod async def update_column ( conn : asyncpg . Connection , id : int , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in User . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Users SET { column } = ($1) WHERE id = ($2); \"\"\" return await run_and_return_count ( conn , query , new_value , id )","title":"Notes"},{"location":"dev/psql/#utils.psql.User.update","text":"update ( conn : asyncpg . Connection , user : User ) -> int Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead.","title":"update()"},{"location":"dev/psql/#utils.psql.User.update--notes","text":"This function has its own transaction. Source code in utils\\psql.py 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 @staticmethod async def update ( conn : asyncpg . Connection , user : User ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existed_user = await User . get_one ( conn , user . id ) if not existed_user : return await User . insert_one ( conn , user ) diff_col = [] for col in existed_user . __slots__ : if getattr ( existed_user , col ) != getattr ( user , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await User . update_column ( conn , user . id , change , getattr ( user , change ))","title":"Notes"},{"location":"dev/psql/#utils.psql.Reminders","text":"Bases: ClassToDict Represent an entry in the Reminders table along with possible operations related to the table. Source code in utils\\psql.py 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 @dataclasses . dataclass ( slots = True ) class Reminders ( ClassToDict ): '''Represent an entry in the `Reminders` table along with possible operations related to the table.''' remind_id : int user_id : int awake_time : dt . datetime message : str __PREVENT_UPDATE = ( \"remind_id\" , \"user_id\" ) @staticmethod async def get_user_reminders ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders a user have.''' query = \"\"\" SELECT * FROM Reminders WHERE user_id = ($1); \"\"\" result = await conn . fetch ( query , user_id ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] @staticmethod async def get_reminders ( conn : asyncpg . Connection , lower_time : dt . datetime , upper_time : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders within `(lower_time, upper_time]`.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time > ($1) AND awake_time <= ($2); \"\"\" result = await conn . fetch ( query , lower_time , upper_time ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] @staticmethod async def get_past_reminders ( conn : asyncpg . Connection , now : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders that are supposed to be cleared before the time provided.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time < ($1); \"\"\" result = await conn . fetch ( query , now ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ] @staticmethod async def insert_reminder ( conn : asyncpg . Connection , user_id : int , when : dt . datetime , message : str ) -> int : '''Insert a reminder entry.''' query = \"\"\" INSERT INTO Reminders (user_id, awake_time, message) VALUES ($1, $2, $3); \"\"\" return await run_and_return_count ( conn , query , user_id , when , message ) @staticmethod async def delete_reminder ( conn : asyncpg . Connection , remind_id : int , user_id : int ) -> int : '''Delete a reminder entry.''' # Although remind_id is sufficient, user_id is to make sure a user can't remove another reminder. query = \"\"\" DELETE FROM Reminders WHERE remind_id = ($1) AND user_id = ($2); \"\"\" return await run_and_return_count ( conn , query , remind_id , user_id )","title":"Reminders"},{"location":"dev/psql/#utils.psql.Reminders.get_user_reminders","text":"get_user_reminders ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]] Get a list of reminders a user have. Source code in utils\\psql.py 582 583 584 585 586 587 588 589 590 591 592 @staticmethod async def get_user_reminders ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders a user have.''' query = \"\"\" SELECT * FROM Reminders WHERE user_id = ($1); \"\"\" result = await conn . fetch ( query , user_id ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ]","title":"get_user_reminders()"},{"location":"dev/psql/#utils.psql.Reminders.get_reminders","text":"get_reminders ( conn : asyncpg . Connection , lower_time : dt . datetime , upper_time : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]] Get a list of reminders within (lower_time, upper_time] . Source code in utils\\psql.py 593 594 595 596 597 598 599 600 601 602 603 @staticmethod async def get_reminders ( conn : asyncpg . Connection , lower_time : dt . datetime , upper_time : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders within `(lower_time, upper_time]`.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time > ($1) AND awake_time <= ($2); \"\"\" result = await conn . fetch ( query , lower_time , upper_time ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ]","title":"get_reminders()"},{"location":"dev/psql/#utils.psql.Reminders.get_past_reminders","text":"get_past_reminders ( conn : asyncpg . Connection , now : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]] Get a list of reminders that are supposed to be cleared before the time provided. Source code in utils\\psql.py 604 605 606 607 608 609 610 611 612 613 614 @staticmethod async def get_past_reminders ( conn : asyncpg . Connection , now : dt . datetime , * , as_dict : bool = False ) -> list [ t . Optional [ t . Union [ Reminders , dict ]]]: '''Get a list of reminders that are supposed to be cleared before the time provided.''' query = \"\"\" SELECT * FROM Reminders WHERE awake_time < ($1); \"\"\" result = await conn . fetch ( query , now ) return [ record_to_type ( record , result_type = Reminders if not as_dict else dict ) for record in result ]","title":"get_past_reminders()"},{"location":"dev/psql/#utils.psql.Reminders.insert_reminder","text":"insert_reminder ( conn : asyncpg . Connection , user_id : int , when : dt . datetime , message : str ) -> int Insert a reminder entry. Source code in utils\\psql.py 615 616 617 618 619 620 621 622 623 @staticmethod async def insert_reminder ( conn : asyncpg . Connection , user_id : int , when : dt . datetime , message : str ) -> int : '''Insert a reminder entry.''' query = \"\"\" INSERT INTO Reminders (user_id, awake_time, message) VALUES ($1, $2, $3); \"\"\" return await run_and_return_count ( conn , query , user_id , when , message )","title":"insert_reminder()"},{"location":"dev/psql/#utils.psql.Reminders.delete_reminder","text":"delete_reminder ( conn : asyncpg . Connection , remind_id : int , user_id : int ) -> int Delete a reminder entry. Source code in utils\\psql.py 624 625 626 627 628 629 630 631 632 633 @staticmethod async def delete_reminder ( conn : asyncpg . Connection , remind_id : int , user_id : int ) -> int : '''Delete a reminder entry.''' # Although remind_id is sufficient, user_id is to make sure a user can't remove another reminder. query = \"\"\" DELETE FROM Reminders WHERE remind_id = ($1) AND user_id = ($2); \"\"\" return await run_and_return_count ( conn , query , remind_id , user_id )","title":"delete_reminder()"},{"location":"dev/psql/#utils.psql.Item","text":"Bases: ClassToDict Represent an entry in the Items table along with possible operations related to the table. This is mostly used for the bot's cache purpose. If you're using this directly in a code, you're probably doing it wrong. Source code in utils\\psql.py 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 @dataclasses . dataclass ( slots = True ) class Item ( ClassToDict ): '''Represent an entry in the `Items` table along with possible operations related to the table. This is mostly used for the bot's cache purpose. If you're using this directly in a code, you're probably doing it wrong. ''' id : str sort_id : int name : str emoji : str description : str rarity : str sell_price : int buy_price : t . Optional [ int ] = None aliases : list [ str ] = dataclasses . field ( default_factory = list ) durability : int = None __PREVENT_UPDATE = ( \"id\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]]: '''Get all entries in the table.''' return await Item . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Item ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Items ORDER by sort_id; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Item if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , id : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ]: '''Get the first entry in the table that matches the condition.''' query = \"\"\" SELECT * FROM Items WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Item if not as_dict else dict ) @staticmethod async def get_by_name ( conn : asyncpg . Connection , name_or_alias : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ]: '''Get the first item that has its name/aliases match the provided.''' def filter_name_alias ( record : Item ): return record . name . lower () == name_or_alias . lower () or name_or_alias . lower () in [ alias . lower () for alias in record . aliases ] res = await Item . get_all_where ( conn , where = filter_name_alias , as_dict = as_dict ) assert len ( res ) <= 1 if res : return res [ 0 ] return None @staticmethod async def insert_one ( conn : asyncpg . Connection , item : Item ): '''Insert an entry into the table.''' query = insert_into_query ( \"Items\" , len ( item . __slots__ )) return await run_and_return_count ( conn , query , item . id , item . sort_id , item . name , item . aliases , item . emoji , item . description , item . rarity , item . buy_price , item . sell_price , item . durability , ) @staticmethod async def update_column ( conn : asyncpg . Connection , id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Item . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Items SET { column } = ($2) WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id , new_value ) @staticmethod async def update ( conn : asyncpg . Connection , item : Item ): '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_item = await Item . get_one ( conn , item . id ) if existing_item is None : await Item . insert_one ( conn , item ) logger . info ( \"Loaded new item ' %s ' into the database.\" , item . id ) else : diff_col = [] for col in existing_item . __slots__ : if getattr ( existing_item , col ) != getattr ( item , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Item . update_column ( conn , item . id , change , getattr ( item , change )) if diff_col : logger . info ( \"Updated item ' %s ' in the following columns: %s .\" , item . id , diff_col )","title":"Item"},{"location":"dev/psql/#utils.psql.Item.get_all","text":"get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]] Get all entries in the table. Source code in utils\\psql.py 655 656 657 658 659 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]]: '''Get all entries in the table.''' return await Item . get_all_where ( conn , as_dict = as_dict )","title":"get_all()"},{"location":"dev/psql/#utils.psql.Item.get_all_where","text":"get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Item ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]] Get all entires in the table that matches the condition. Source code in utils\\psql.py 660 661 662 663 664 665 666 667 668 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Item ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Item , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM Items ORDER by sort_id; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Item if not as_dict else dict )","title":"get_all_where()"},{"location":"dev/psql/#utils.psql.Item.get_one","text":"get_one ( conn : asyncpg . Connection , id : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ] Get the first entry in the table that matches the condition. Source code in utils\\psql.py 669 670 671 672 673 674 675 676 677 @staticmethod async def get_one ( conn : asyncpg . Connection , id : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ]: '''Get the first entry in the table that matches the condition.''' query = \"\"\" SELECT * FROM Items WHERE id = ($1); \"\"\" return await __get_one__ ( conn , query , id , result_type = Item if not as_dict else dict )","title":"get_one()"},{"location":"dev/psql/#utils.psql.Item.get_by_name","text":"get_by_name ( conn : asyncpg . Connection , name_or_alias : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ] Get the first item that has its name/aliases match the provided. Source code in utils\\psql.py 678 679 680 681 682 683 684 685 686 687 688 689 690 @staticmethod async def get_by_name ( conn : asyncpg . Connection , name_or_alias : str , * , as_dict : bool = False ) -> t . Union [ Item , dict ]: '''Get the first item that has its name/aliases match the provided.''' def filter_name_alias ( record : Item ): return record . name . lower () == name_or_alias . lower () or name_or_alias . lower () in [ alias . lower () for alias in record . aliases ] res = await Item . get_all_where ( conn , where = filter_name_alias , as_dict = as_dict ) assert len ( res ) <= 1 if res : return res [ 0 ] return None","title":"get_by_name()"},{"location":"dev/psql/#utils.psql.Item.insert_one","text":"insert_one ( conn : asyncpg . Connection , item : Item ) Insert an entry into the table. Source code in utils\\psql.py 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 @staticmethod async def insert_one ( conn : asyncpg . Connection , item : Item ): '''Insert an entry into the table.''' query = insert_into_query ( \"Items\" , len ( item . __slots__ )) return await run_and_return_count ( conn , query , item . id , item . sort_id , item . name , item . aliases , item . emoji , item . description , item . rarity , item . buy_price , item . sell_price , item . durability , )","title":"insert_one()"},{"location":"dev/psql/#utils.psql.Item.update_column","text":"update_column ( conn : asyncpg . Connection , id : str , column : str , new_value ) -> int Update a specific column with a new value.","title":"update_column()"},{"location":"dev/psql/#utils.psql.Item.update_column--warnings","text":"Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL.","title":"Warnings"},{"location":"dev/psql/#utils.psql.Item.update_column--notes","text":"Always prefer using other functions to update rather than this function if possible. Source code in utils\\psql.py 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 @staticmethod async def update_column ( conn : asyncpg . Connection , id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Item . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE Items SET { column } = ($2) WHERE id = ($1); \"\"\" return await run_and_return_count ( conn , query , id , new_value )","title":"Notes"},{"location":"dev/psql/#utils.psql.Item.update","text":"update ( conn : asyncpg . Connection , item : Item ) Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead.","title":"update()"},{"location":"dev/psql/#utils.psql.Item.update--notes","text":"This function has its own transaction. Source code in utils\\psql.py 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 @staticmethod async def update ( conn : asyncpg . Connection , item : Item ): '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_item = await Item . get_one ( conn , item . id ) if existing_item is None : await Item . insert_one ( conn , item ) logger . info ( \"Loaded new item ' %s ' into the database.\" , item . id ) else : diff_col = [] for col in existing_item . __slots__ : if getattr ( existing_item , col ) != getattr ( item , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Item . update_column ( conn , item . id , change , getattr ( item , change )) if diff_col : logger . info ( \"Updated item ' %s ' in the following columns: %s .\" , item . id , diff_col )","title":"Notes"},{"location":"dev/psql/#utils.psql.Inventory","text":"Bases: ClassToDict Represent an entry in the UserInventory table along with possible operations related to the table. Source code in utils\\psql.py 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 @dataclasses . dataclass ( slots = True ) class Inventory ( ClassToDict ): '''Represent an entry in the `UserInventory` table along with possible operations related to the table.''' user_id : int item_id : str amount : int __PREVENT_UPDATE = ( \"user_id\" , \"item_id\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entries in the table.''' return await Inventory . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Inventory ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM UserInventory ORDER BY amount DESC; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Inventory if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Inventory , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM UserInventory WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , item_id , result_type = Inventory if not as_dict else dict ) @staticmethod async def get_user_inventory ( conn , user_id : int , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entries in the table that belongs to a user.''' return await Inventory . get_all_where ( conn , where = lambda r : r . user_id == user_id , as_dict = as_dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"UserInventory\" , len ( Inventory . __slots__ )) return await run_and_return_count ( conn , query , inventory . user_id , inventory . item_id , inventory . amount ) @staticmethod async def delete ( conn : asyncpg . Connection , user_id : int , item_id : str ) -> int : query = \"\"\" DELETE FROM UserInventory WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id ) @staticmethod async def update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Inventory . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE UserInventory SET { column } = ($3) WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id , new_value ) @staticmethod async def add ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int : '''Add item into the user's inventory. Notes ----- This should be preferred over `Inventory.insert_one()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user_id : int The user's id to insert. item_id : str The item's id to insert. amount : int, optional The amount of items to add. Default to 1. Returns ------- int The number of entries affected. Should be 1 or 0. ''' existed = await Inventory . get_one ( conn , user_id , item_id ) if not existed : return await Inventory . insert_one ( conn , Inventory ( user_id , item_id , amount )) else : return await Inventory . update_column ( conn , user_id , item_id , \"amount\" , existed . amount + amount ) @staticmethod async def remove ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int : '''Remove item from the user's inventory. Notes ----- This should be preferred over `Inventory.delete()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user_id : int The user's id to insert. item_id : str The item's id to insert. amount : int, optional The amount of items to remove. Default to 1. Returns ------- int The number of entries affected. Should be 1 or 0. ''' existed = await Inventory . get_one ( conn , user_id , item_id ) if not existed : return 0 elif existed . amount <= amount : return await Inventory . delete ( conn , user_id , item_id ) else : return await Inventory . update_column ( conn , user_id , item_id , \"amount\" , existed . amount - amount ) @staticmethod async def update ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_inv = await Inventory . get_one ( conn , inventory . user_id , inventory . item_id ) if not existing_inv : return await Inventory . insert_one ( conn , inventory ) if inventory . amount <= 0 : return await Inventory . delete ( conn , inventory . user_id , inventory . item_id ) diff_col = [] for col in existing_inv . __slots__ : if col in ( \"user_id\" , \"item_id\" , \"amount\" ): if getattr ( existing_inv , col ) != getattr ( inventory , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Inventory . update_column ( conn , inventory . user_id , inventory . item_id , change , getattr ( inventory , change ))","title":"Inventory"},{"location":"dev/psql/#utils.psql.Inventory.get_all","text":"get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]] Get all entries in the table. Source code in utils\\psql.py 768 769 770 771 772 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entries in the table.''' return await Inventory . get_all_where ( conn , as_dict = as_dict )","title":"get_all()"},{"location":"dev/psql/#utils.psql.Inventory.get_all_where","text":"get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Inventory ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]] Get all entires in the table that matches the condition. Source code in utils\\psql.py 773 774 775 776 777 778 779 780 781 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Inventory ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM UserInventory ORDER BY amount DESC; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Inventory if not as_dict else dict )","title":"get_all_where()"},{"location":"dev/psql/#utils.psql.Inventory.get_one","text":"get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Inventory , dict ] Get the first entry in the table that matches the pkey provided. Source code in utils\\psql.py 782 783 784 785 786 787 788 789 790 791 @staticmethod async def get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Inventory , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM UserInventory WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , item_id , result_type = Inventory if not as_dict else dict )","title":"get_one()"},{"location":"dev/psql/#utils.psql.Inventory.get_user_inventory","text":"get_user_inventory ( conn , user_id : int , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]] Get all entries in the table that belongs to a user. Source code in utils\\psql.py 792 793 794 795 796 @staticmethod async def get_user_inventory ( conn , user_id : int , * , as_dict : bool = False ) -> list [ t . Union [ Inventory , dict ]]: '''Get all entries in the table that belongs to a user.''' return await Inventory . get_all_where ( conn , where = lambda r : r . user_id == user_id , as_dict = as_dict )","title":"get_user_inventory()"},{"location":"dev/psql/#utils.psql.Inventory.insert_one","text":"insert_one ( conn : asyncpg . Connection , inventory : Inventory ) -> int Insert an entry into the table. Source code in utils\\psql.py 797 798 799 800 801 802 @staticmethod async def insert_one ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"UserInventory\" , len ( Inventory . __slots__ )) return await run_and_return_count ( conn , query , inventory . user_id , inventory . item_id , inventory . amount )","title":"insert_one()"},{"location":"dev/psql/#utils.psql.Inventory.update_column","text":"update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int Update a specific column with a new value.","title":"update_column()"},{"location":"dev/psql/#utils.psql.Inventory.update_column--warnings","text":"Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL.","title":"Warnings"},{"location":"dev/psql/#utils.psql.Inventory.update_column--notes","text":"Always prefer using other functions to update rather than this function if possible. Source code in utils\\psql.py 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 @staticmethod async def update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Inventory . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE UserInventory SET { column } = ($3) WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id , new_value )","title":"Notes"},{"location":"dev/psql/#utils.psql.Inventory.add","text":"add ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int Add item into the user's inventory.","title":"add()"},{"location":"dev/psql/#utils.psql.Inventory.add--notes","text":"This should be preferred over Inventory.insert_one() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required user_id int The user's id to insert. required item_id str The item's id to insert. required amount int , optional The amount of items to add. Default to 1. 1 Returns: Type Description int The number of entries affected. Should be 1 or 0. Source code in utils\\psql.py 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 @staticmethod async def add ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int : '''Add item into the user's inventory. Notes ----- This should be preferred over `Inventory.insert_one()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user_id : int The user's id to insert. item_id : str The item's id to insert. amount : int, optional The amount of items to add. Default to 1. Returns ------- int The number of entries affected. Should be 1 or 0. ''' existed = await Inventory . get_one ( conn , user_id , item_id ) if not existed : return await Inventory . insert_one ( conn , Inventory ( user_id , item_id , amount )) else : return await Inventory . update_column ( conn , user_id , item_id , \"amount\" , existed . amount + amount )","title":"Notes"},{"location":"dev/psql/#utils.psql.Inventory.remove","text":"remove ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int Remove item from the user's inventory.","title":"remove()"},{"location":"dev/psql/#utils.psql.Inventory.remove--notes","text":"This should be preferred over Inventory.delete() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required user_id int The user's id to insert. required item_id str The item's id to insert. required amount int , optional The amount of items to remove. Default to 1. 1 Returns: Type Description int The number of entries affected. Should be 1 or 0. Source code in utils\\psql.py 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 @staticmethod async def remove ( conn : asyncpg . Connection , user_id : int , item_id : str , amount : int = 1 ) -> int : '''Remove item from the user's inventory. Notes ----- This should be preferred over `Inventory.delete()`. Parameters ---------- conn : asyncpg.Connection The connection to use. user_id : int The user's id to insert. item_id : str The item's id to insert. amount : int, optional The amount of items to remove. Default to 1. Returns ------- int The number of entries affected. Should be 1 or 0. ''' existed = await Inventory . get_one ( conn , user_id , item_id ) if not existed : return 0 elif existed . amount <= amount : return await Inventory . delete ( conn , user_id , item_id ) else : return await Inventory . update_column ( conn , user_id , item_id , \"amount\" , existed . amount - amount )","title":"Notes"},{"location":"dev/psql/#utils.psql.Inventory.update","text":"update ( conn : asyncpg . Connection , inventory : Inventory ) -> int Update an entry based on the provided object, or insert it if not existed. This function calls get_one() internally, causing an overhead.","title":"update()"},{"location":"dev/psql/#utils.psql.Inventory.update--notes","text":"This function has its own transaction. Source code in utils\\psql.py 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 @staticmethod async def update ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Update an entry based on the provided object, or insert it if not existed. This function calls `get_one()` internally, causing an overhead. Notes ----- This function has its own transaction. ''' existing_inv = await Inventory . get_one ( conn , inventory . user_id , inventory . item_id ) if not existing_inv : return await Inventory . insert_one ( conn , inventory ) if inventory . amount <= 0 : return await Inventory . delete ( conn , inventory . user_id , inventory . item_id ) diff_col = [] for col in existing_inv . __slots__ : if col in ( \"user_id\" , \"item_id\" , \"amount\" ): if getattr ( existing_inv , col ) != getattr ( inventory , col ): diff_col . append ( col ) async with conn . transaction (): for change in diff_col : await Inventory . update_column ( conn , inventory . user_id , inventory . item_id , change , getattr ( inventory , change ))","title":"Notes"},{"location":"dev/psql/#utils.psql.Equipment","text":"Bases: ClassToDict Represent an entry in the UserEquipment table along with possible operations related to the table. Source code in utils\\psql.py 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 @dataclasses . dataclass ( slots = True ) class Equipment ( ClassToDict ): '''Represent an entry in the `UserEquipment` table along with possible operations related to the table.''' user_id : int item_id : str eq_type : str remain_durability : int __EQUIPMENT_TYPE__ = ( \"_sword\" , \"_pickaxe\" , \"_axe\" , \"_potion\" ) __PREVENT_UPDATE = ( \"user_id\" , \"item_id\" , \"eq_type\" ) @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: '''Get all entries in the table.''' return await Equipment . get_all_where ( conn , as_dict = as_dict ) @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Equipment ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM UserEquipment; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Equipment if not as_dict else dict ) @staticmethod async def get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM UserEquipment WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , item_id , result_type = Equipment if not as_dict else dict ) @staticmethod async def get_equipment ( conn : asyncpg . Connection , user_id : int , equipment_type : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ]: '''Get a user's equipment based on equipment type.''' query = \"\"\" SELECT * FROM UserEquipment WHERE user_id = ($1) AND eq_type = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , equipment_type , result_type = Equipment if not as_dict else dict ) @staticmethod async def get_user_equipments ( conn : asyncpg . Connection , user_id : int , * , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: return await Equipment . get_all_where ( conn , where = lambda r : r . user_id == user_id , as_dict = as_dict ) @staticmethod async def insert_one ( conn : asyncpg . Connection , equipment : Equipment ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"UserEquipment\" , len ( equipment . __slots__ )) return await run_and_return_count ( conn , query , equipment . user_id , equipment . item_id , equipment . eq_type , equipment . remain_durability ) @staticmethod async def transfer_from_inventory ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Transfer an equipment from the inventory. Warnings -------- This does not check whether the user already has that equipment. This must be checked by the user, otherwise an `asyncpg.UniqueViolationError` might be raised. Notes ----- This function already has its own transaction. There is no need to wrap a transaction for this function. Parameters ---------- conn : asyncpg.Connection The connection to use. inventory : Inventory The inventory wrapping the equipment. Returns ------- int The number of entries affected. Should be 1 or 0. Raises ------ asyncpg.UniqueViolationError The unique constraint on `(user_id, eq_type)` is violated. ''' is_equipment = False for eq_type in Equipment . __EQUIPMENT_TYPE__ : if eq_type in inventory . item_id : is_equipment = True item = await Item . get_one ( conn , inventory . item_id ) equipment = Equipment ( inventory . user_id , inventory . item_id , eq_type , item . durability ) break if not is_equipment : return 0 async with conn . transaction (): status = await Inventory . remove ( conn , inventory . user_id , inventory . item_id ) if status == 0 : return 0 # TODO: Add a check to see if the same equipment type is already there. return await Equipment . insert_one ( conn , equipment ) @staticmethod async def delete ( conn : asyncpg . Connection , user_id : int , item_id : str ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM UserEquipment WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id ) @staticmethod async def update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Equipment . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE UserEquipment SET { column } = ($3) WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id , new_value ) @staticmethod async def update_durability ( conn : asyncpg . Connection , user_id : int , item_id : str , new_durability : int ) -> int : '''Update an equipment's durability and remove if needed.''' if new_durability <= 0 : return await Equipment . delete ( conn , user_id , item_id ) return await Equipment . update_column ( conn , user_id , item_id , \"remain_durability\" , new_durability ) @staticmethod def is_equipment ( item_id : str ) -> bool : '''Check if the item is an equipment or not. Parameters ---------- item_id : str The item's id to check. Returns ------- bool Whether the item is an equipment or not. ''' for eq_type in Equipment . __EQUIPMENT_TYPE__ : if eq_type in item_id : return True return False @staticmethod def is_true_equipment ( item_id : str ) -> bool : return Equipment . is_equipment ( item_id ) and not Equipment . is_potion ( item_id ) @staticmethod def is_potion ( item_id : str ) -> bool : return \"_potion\" in item_id @staticmethod def get_equipment_type ( item_id : str ) -> t . Optional [ str ]: '''Return the equipment type of the equipment. Parameters ---------- item_id : str The item's id. Returns ------- t.Optional[str] The equipment type of the equipment, or `None` if it is not an equipment. ''' if not Equipment . is_equipment ( item_id ): return None return '_' + item_id . split ( '_' )[ - 1 ]","title":"Equipment"},{"location":"dev/psql/#utils.psql.Equipment.get_all","text":"get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]] Get all entries in the table. Source code in utils\\psql.py 932 933 934 935 936 @staticmethod async def get_all ( conn : asyncpg . Connection , * , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: '''Get all entries in the table.''' return await Equipment . get_all_where ( conn , as_dict = as_dict )","title":"get_all()"},{"location":"dev/psql/#utils.psql.Equipment.get_all_where","text":"get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Equipment ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]] Get all entires in the table that matches the condition. Source code in utils\\psql.py 937 938 939 940 941 942 943 944 945 @staticmethod async def get_all_where ( conn : asyncpg . Connection , * , where : t . Callable [[ Equipment ], bool ] = lambda r : True , as_dict : bool = False ) -> list [ t . Union [ Equipment , dict ]]: '''Get all entires in the table that matches the condition.''' query = \"\"\" SELECT * FROM UserEquipment; \"\"\" return await __get_all__ ( conn , query , where = where , result_type = Equipment if not as_dict else dict )","title":"get_all_where()"},{"location":"dev/psql/#utils.psql.Equipment.get_one","text":"get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ] Get the first entry in the table that matches the pkey provided. Source code in utils\\psql.py 946 947 948 949 950 951 952 953 954 955 @staticmethod async def get_one ( conn : asyncpg . Connection , user_id : int , item_id : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ]: '''Get the first entry in the table that matches the pkey provided.''' query = \"\"\" SELECT * FROM UserEquipment WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , item_id , result_type = Equipment if not as_dict else dict )","title":"get_one()"},{"location":"dev/psql/#utils.psql.Equipment.get_equipment","text":"get_equipment ( conn : asyncpg . Connection , user_id : int , equipment_type : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ] Get a user's equipment based on equipment type. Source code in utils\\psql.py 956 957 958 959 960 961 962 963 964 965 @staticmethod async def get_equipment ( conn : asyncpg . Connection , user_id : int , equipment_type : str , * , as_dict : bool = False ) -> t . Union [ Equipment , dict ]: '''Get a user's equipment based on equipment type.''' query = \"\"\" SELECT * FROM UserEquipment WHERE user_id = ($1) AND eq_type = ($2); \"\"\" return await __get_one__ ( conn , query , user_id , equipment_type , result_type = Equipment if not as_dict else dict )","title":"get_equipment()"},{"location":"dev/psql/#utils.psql.Equipment.insert_one","text":"insert_one ( conn : asyncpg . Connection , equipment : Equipment ) -> int Insert an entry into the table. Source code in utils\\psql.py 969 970 971 972 973 974 @staticmethod async def insert_one ( conn : asyncpg . Connection , equipment : Equipment ) -> int : '''Insert an entry into the table.''' query = insert_into_query ( \"UserEquipment\" , len ( equipment . __slots__ )) return await run_and_return_count ( conn , query , equipment . user_id , equipment . item_id , equipment . eq_type , equipment . remain_durability )","title":"insert_one()"},{"location":"dev/psql/#utils.psql.Equipment.transfer_from_inventory","text":"transfer_from_inventory ( conn : asyncpg . Connection , inventory : Inventory ) -> int Transfer an equipment from the inventory.","title":"transfer_from_inventory()"},{"location":"dev/psql/#utils.psql.Equipment.transfer_from_inventory--warnings","text":"This does not check whether the user already has that equipment. This must be checked by the user, otherwise an asyncpg.UniqueViolationError might be raised.","title":"Warnings"},{"location":"dev/psql/#utils.psql.Equipment.transfer_from_inventory--notes","text":"This function already has its own transaction. There is no need to wrap a transaction for this function. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required inventory Inventory The inventory wrapping the equipment. required Returns: Type Description int The number of entries affected. Should be 1 or 0. Raises: Type Description asyncpg . UniqueViolationError The unique constraint on (user_id, eq_type) is violated. Source code in utils\\psql.py 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 @staticmethod async def transfer_from_inventory ( conn : asyncpg . Connection , inventory : Inventory ) -> int : '''Transfer an equipment from the inventory. Warnings -------- This does not check whether the user already has that equipment. This must be checked by the user, otherwise an `asyncpg.UniqueViolationError` might be raised. Notes ----- This function already has its own transaction. There is no need to wrap a transaction for this function. Parameters ---------- conn : asyncpg.Connection The connection to use. inventory : Inventory The inventory wrapping the equipment. Returns ------- int The number of entries affected. Should be 1 or 0. Raises ------ asyncpg.UniqueViolationError The unique constraint on `(user_id, eq_type)` is violated. ''' is_equipment = False for eq_type in Equipment . __EQUIPMENT_TYPE__ : if eq_type in inventory . item_id : is_equipment = True item = await Item . get_one ( conn , inventory . item_id ) equipment = Equipment ( inventory . user_id , inventory . item_id , eq_type , item . durability ) break if not is_equipment : return 0 async with conn . transaction (): status = await Inventory . remove ( conn , inventory . user_id , inventory . item_id ) if status == 0 : return 0 # TODO: Add a check to see if the same equipment type is already there. return await Equipment . insert_one ( conn , equipment )","title":"Notes"},{"location":"dev/psql/#utils.psql.Equipment.delete","text":"delete ( conn : asyncpg . Connection , user_id : int , item_id : str ) -> int Delete an entry in the table based on the provided key. Source code in utils\\psql.py 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 @staticmethod async def delete ( conn : asyncpg . Connection , user_id : int , item_id : str ) -> int : '''Delete an entry in the table based on the provided key.''' query = \"\"\" DELETE FROM UserEquipment WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id )","title":"delete()"},{"location":"dev/psql/#utils.psql.Equipment.update_column","text":"update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int Update a specific column with a new value.","title":"update_column()"},{"location":"dev/psql/#utils.psql.Equipment.update_column--warnings","text":"Columns that are in __PREVENT_UPDATE (usually primary keys) will be ignored. To update such columns, use raw SQL.","title":"Warnings"},{"location":"dev/psql/#utils.psql.Equipment.update_column--notes","text":"Always prefer using other functions to update rather than this function if possible. Source code in utils\\psql.py 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 @staticmethod async def update_column ( conn : asyncpg . Connection , user_id : int , item_id : str , column : str , new_value ) -> int : '''Update a specific column with a new value. Warnings -------- Columns that are in `__PREVENT_UPDATE` (usually primary keys) will be ignored. To update such columns, use raw SQL. Notes ----- Always prefer using other functions to update rather than this function if possible. ''' if column in Equipment . __PREVENT_UPDATE : return 0 query = f \"\"\" UPDATE UserEquipment SET { column } = ($3) WHERE user_id = ($1) AND item_id = ($2); \"\"\" return await run_and_return_count ( conn , query , user_id , item_id , new_value )","title":"Notes"},{"location":"dev/psql/#utils.psql.Equipment.update_durability","text":"update_durability ( conn : asyncpg . Connection , user_id : int , item_id : str , new_durability : int ) -> int Update an equipment's durability and remove if needed. Source code in utils\\psql.py 1057 1058 1059 1060 1061 1062 1063 @staticmethod async def update_durability ( conn : asyncpg . Connection , user_id : int , item_id : str , new_durability : int ) -> int : '''Update an equipment's durability and remove if needed.''' if new_durability <= 0 : return await Equipment . delete ( conn , user_id , item_id ) return await Equipment . update_column ( conn , user_id , item_id , \"remain_durability\" , new_durability )","title":"update_durability()"},{"location":"dev/psql/#utils.psql.Equipment.is_equipment","text":"is_equipment ( item_id : str ) -> bool Check if the item is an equipment or not. Parameters: Name Type Description Default item_id str The item's id to check. required Returns: Type Description bool Whether the item is an equipment or not. Source code in utils\\psql.py 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 @staticmethod def is_equipment ( item_id : str ) -> bool : '''Check if the item is an equipment or not. Parameters ---------- item_id : str The item's id to check. Returns ------- bool Whether the item is an equipment or not. ''' for eq_type in Equipment . __EQUIPMENT_TYPE__ : if eq_type in item_id : return True return False","title":"is_equipment()"},{"location":"dev/psql/#utils.psql.Equipment.get_equipment_type","text":"get_equipment_type ( item_id : str ) -> t . Optional [ str ] Return the equipment type of the equipment. Parameters: Name Type Description Default item_id str The item's id. required Returns: Type Description t . Optional [ str ] The equipment type of the equipment, or None if it is not an equipment. Source code in utils\\psql.py 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 @staticmethod def get_equipment_type ( item_id : str ) -> t . Optional [ str ]: '''Return the equipment type of the equipment. Parameters ---------- item_id : str The item's id. Returns ------- t.Optional[str] The equipment type of the equipment, or `None` if it is not an equipment. ''' if not Equipment . is_equipment ( item_id ): return None return '_' + item_id . split ( '_' )[ - 1 ]","title":"get_equipment_type()"},{"location":"dev/psql/#utils.psql.record_to_type","text":"record_to_type ( / , record : asyncpg . Record , result_type : t . Type [ T ] = dict ) -> T Convert a asyncpg.Record into a dict or None if the object is already None . This is for convenience purpose, where dict(Record) will return {} which is not an accurate representation of empty. obj is None or obj is not None is more obvious to anyone than bool(obj) or not bool(obj) . Parameters: Name Type Description Default record asyncpg . Record The record to convert. required result_type t . Type The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a dict . Default to dict . dict","title":"record_to_type()"},{"location":"dev/psql/#utils.psql.record_to_type--return","text":"t.Optional[T] Either None or result_type . Source code in utils\\psql.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def record_to_type ( record : asyncpg . Record , / , result_type : t . Type [ T ] = dict ) -> T : '''Convert a `asyncpg.Record` into a `dict` or `None` if the object is already `None`. This is for convenience purpose, where `dict(Record)` will return `{}` which is not an accurate representation of empty. `obj is None` or `obj is not None` is more obvious to anyone than `bool(obj)` or `not bool(obj)`. Parameters ---------- record : asyncpg.Record The record to convert. result_type : t.Type The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a `dict`. Default to `dict`. Return ------ t.Optional[T] Either `None` or `result_type`. ''' if record is None : return None d = dict ( record ) if result_type is dict : return d return result_type ( ** d )","title":"Return"},{"location":"dev/psql/#utils.psql.legacy_insert_into","text":"legacy_insert_into ( conn , table_name : str , * args ) Insert values into table_name . Warning: This function is an old function from pre-rewrite. It is advised to do the logic by yourself. Source code in utils\\psql.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 async def legacy_insert_into ( conn , table_name : str , * args ): ''' Insert values into `table_name`. Warning: This function is an old function from pre-rewrite. It is advised to do the logic by yourself. ''' arg_str = \"(\" # max(*args, key = len): Get the longest tuple in the list. for j in range ( len ( max ( * args , key = len ))): arg_str += f \"$ { j + 1 } , \" arg_str = arg_str [: - 2 ] + ')' await conn . executemany ( f ''' INSERT INTO { table_name } VALUES { arg_str } ''' , * args )","title":"legacy_insert_into()"},{"location":"dev/psql/#utils.psql.insert_into_query","text":"insert_into_query ( table_name : str , len_col : int ) -> str Return the query to insert into a table that has len_col columns. Parameters: Name Type Description Default table_name str The table to insert. required len_col int How many column does the table have. required Returns: Type Description str An INSERT SQL statement with query formatter ready to use in .execute() Source code in utils\\psql.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def insert_into_query ( table_name : str , len_col : int ) -> str : '''Return the query to insert into a table that has `len_col` columns. Parameters ---------- table_name : str The table to insert. len_col : int How many column does the table have. Returns ------- str An INSERT SQL statement with query formatter ready to use in `.execute()` ''' arg_str = \"(\" for index in range ( len_col ): arg_str += f \"$ { index + 1 } , \" arg_str = arg_str [: - 2 ] + ')' return f \"INSERT INTO { table_name } VALUES { arg_str } ;\"","title":"insert_into_query()"},{"location":"dev/psql/#utils.psql.__get_all__","text":"__get_all__ ( conn : asyncpg . Connection , query : str , * , where : t . Callable [[ T ], bool ] = lambda r : True , result_type : t . Type [ T ] = dict ) -> list [ T ] Run a SELECT statement and return a list of objects. This should NOT be used outside of the module. Instead, use table_name.get_all() . Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required query str The SELECT statement to run. This should not contain WHERE clause. Conditions should be set in where parameter. required where t . Callable [[ dict ], bool ] Additional conditions to filter. By default, no condition is applied (always return True ). lambda r: True result_type t . Type [ T ] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a dict . Default to dict . dict Returns: Type Description list [ T ] A list of result_type or empty list. Source code in utils\\psql.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 async def __get_all__ ( conn : asyncpg . Connection , query : str , * , where : t . Callable [[ T ], bool ] = lambda r : True , result_type : t . Type [ T ] = dict ) -> list [ T ]: '''Run a `SELECT` statement and return a list of objects. This should NOT be used outside of the module. Instead, use `table_name.get_all()`. Parameters ---------- conn : asyncpg.Connection The connection to use. query : str The `SELECT` statement to run. This should not contain `WHERE` clause. Conditions should be set in `where` parameter. where : t.Callable[[dict], bool] Additional conditions to filter. By default, no condition is applied (always return `True`). result_type : t.Type[T] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a `dict`. Default to `dict`. Returns ------- list[T] A list of `result_type` or empty list. ''' result = await conn . fetch ( query ) l = [] record_obj = None for record in result : # NOTE: This code is for handling dict case; will remove soon. #record_obj = record_to_type(record) #if record_obj is None or (record_obj is not None and where(record_obj)): # l.append(record_obj) record_obj = record_to_type ( record , result_type ) if record_obj is None or ( record_obj is not None and where ( record_obj )): l . append ( record_obj ) return l","title":"__get_all__()"},{"location":"dev/psql/#utils.psql.__get_one__","text":"__get_one__ ( conn : asyncpg . Connection , query : str , * constraints , result_type : t . Type [ T ] = dict ) -> t . Optional [ T ] Run a SELECT statement and return the first object that matches the constraints. Parameters: Name Type Description Default conn asyncpg . Connection The connection to use. required query str The SELECT statement to run. This should contain a WHERE clause. required *constraints str Arguments to be formatted into the query. () result_type t . Type [ T ] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a dict . Default to dict . dict Returns: Type Description t . Optional [ T ] A result_type or None if no object is found. Source code in utils\\psql.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 async def __get_one__ ( conn : asyncpg . Connection , query : str , * constraints , result_type : t . Type [ T ] = dict ) -> t . Optional [ T ]: '''Run a `SELECT` statement and return the first object that matches the constraints. Parameters ---------- conn : asyncpg.Connection The connection to use. query : str The `SELECT` statement to run. This should contain a `WHERE` clause. *constraints : str Arguments to be formatted into the query. result_type : t.Type[T] The type to convert to. The type must be a dataclass or an object that can be initialized via kwargs or a `dict`. Default to `dict`. Returns ------- t.Optional[T] A `result_type` or `None` if no object is found. ''' record = await conn . fetchrow ( query , * constraints ) return record_to_type ( record , result_type )","title":"__get_one__()"},{"location":"dev/psql/#utils.psql.run_and_return_count","text":"run_and_return_count ( conn : asyncpg . Connection , query : str , * args , ** kwargs ) -> t . Optional [ int ] Execute an SQL operation and return the number of entries affected.","title":"run_and_return_count()"},{"location":"dev/psql/#utils.psql.run_and_return_count--warnings","text":"This is meant to run INSERT, DELETE, and UPDATE statements. Other statement might or might not work. Parameters: Name Type Description Default conn asyncpg . Connection The connection to execute. required *args tuple The arguments to pass into conn.execute() () **kwargs The arguments to pass into conn.execute() {} Returns: Type Description t . Optional [ int ] The number of rows affected. If the operation doesn't return the row count, None is returned. Source code in utils\\psql.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 async def run_and_return_count ( conn : asyncpg . Connection , query : str , * args , ** kwargs ) -> t . Optional [ int ]: '''Execute an SQL operation and return the number of entries affected. Warnings -------- This is meant to run INSERT, DELETE, and UPDATE statements. Other statement might or might not work. Parameters ---------- conn : asyncpg.Connection The connection to execute. *args : tuple The arguments to pass into `conn.execute()` **kwargs: dict The arguments to pass into `conn.execute()` Returns ------- t.Optional[int] The number of rows affected. If the operation doesn't return the row count, `None` is returned. ''' status = await conn . execute ( query , * args , ** kwargs ) # INSERT returns \"INSERT oid count\". try : count = int ( status . split ()[ - 1 ]) return count except ValueError : return None","title":"Warnings"},{"location":"user/bot/","text":"Bot Category Bot-related Commands changelog [option = stable] Show 10 latest stable changes to the bot. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: option : Additional options. Valid options are dev / development and stable . Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command. help [*name = None] Get help information for the bot. Type: Prefix Command , Slash Command Aliases: h Parameters: name : Category name or command name. Is case-sensitive. info Show information about the bot. Type: Prefix Command , Slash Command Aliases: about info bot Show information about the bot. Type: Prefix Command , Slash Command info host Show information about the machine hosting the bot. Type: Prefix Command , Slash Command info item Show information for an item. Type: Prefix Command , Slash Command Additional Note: Refer to this to have context on this command. info member [member] Show information about yourself or another member. Type: Prefix Command , Slash Command Parameters: member : A Discord member. Default to yourself. info role <role> Show information about a role. Type: Prefix Command , Slash Command Parameters: role : A Discord role. info server Show information about this server. Type: Prefix Command , Slash Command ping Check the bot if it's alive. Type: Prefix Command , Slash Command prefix [new_prefix = None] View or edit the bot prefix for the guild. This only affects Prefix Commands. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: new_prefix : The new prefix. Should not be longer than 5 characters or contain spaces. Additional Info: Author needs to have Manage Server permission. report <type> <*reason> Report a bug or suggest a feature for the bot. Please be constructive. Type: Prefix Command , Slash Command (recommended). Cooldown: 5 seconds after 1 use per user. Parameters: type : The type of report you're making. Either bug or suggest . reason : The content you're trying to send. Last updated on Jul 25, 2022","title":"Bot"},{"location":"user/bot/#bot-category","text":"Bot-related Commands","title":"Bot Category"},{"location":"user/bot/#changelog-option-stable","text":"Show 10 latest stable changes to the bot. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: option : Additional options. Valid options are dev / development and stable . Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command.","title":"changelog [option = stable]"},{"location":"user/bot/#help-name-none","text":"Get help information for the bot. Type: Prefix Command , Slash Command Aliases: h Parameters: name : Category name or command name. Is case-sensitive.","title":"help [*name = None]"},{"location":"user/bot/#info","text":"Show information about the bot. Type: Prefix Command , Slash Command Aliases: about","title":"info"},{"location":"user/bot/#info-bot","text":"Show information about the bot. Type: Prefix Command , Slash Command","title":"info bot"},{"location":"user/bot/#info-host","text":"Show information about the machine hosting the bot. Type: Prefix Command , Slash Command","title":"info host"},{"location":"user/bot/#info-item","text":"Show information for an item. Type: Prefix Command , Slash Command Additional Note: Refer to this to have context on this command.","title":"info item"},{"location":"user/bot/#info-member-member","text":"Show information about yourself or another member. Type: Prefix Command , Slash Command Parameters: member : A Discord member. Default to yourself.","title":"info member [member]"},{"location":"user/bot/#info-role-role","text":"Show information about a role. Type: Prefix Command , Slash Command Parameters: role : A Discord role.","title":"info role &lt;role&gt;"},{"location":"user/bot/#info-server","text":"Show information about this server. Type: Prefix Command , Slash Command","title":"info server"},{"location":"user/bot/#ping","text":"Check the bot if it's alive. Type: Prefix Command , Slash Command","title":"ping"},{"location":"user/bot/#prefix-new_prefix-none","text":"View or edit the bot prefix for the guild. This only affects Prefix Commands. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: new_prefix : The new prefix. Should not be longer than 5 characters or contain spaces. Additional Info: Author needs to have Manage Server permission.","title":"prefix [new_prefix = None]"},{"location":"user/bot/#report-type-reason","text":"Report a bug or suggest a feature for the bot. Please be constructive. Type: Prefix Command , Slash Command (recommended). Cooldown: 5 seconds after 1 use per user. Parameters: type : The type of report you're making. Either bug or suggest . reason : The content you're trying to send. Last updated on Jul 25, 2022","title":"report &lt;type&gt; &lt;*reason&gt;"},{"location":"user/economy/","text":"Economy Category Economy Commands balance View your balance. Type: Prefix Command , Slash Command Aliases: bal barter View and/or perform a barter. Get your gold ready. Type: Prefix Command , Slash Command Cooldown: 5 seconds per 1 use per user. Additional Info: Barters can contains purchases that can't be made via market . Barters will reset every 4 hours. This can only be used when you're in the Nether. bet <number> [money = 1] Bet your money to guess a number in the range 0-50. Don't worry, I won't cheat :) Type: Prefix Command , Slash Command Parameters: number : Your guessing number. Stay within 0-50! money : The amount to bet. You'll either lose this or get 2x back. At least 1. craft <item> [times = 1] Craft various items. Type: Prefix Command , Slash Command (recommended) Cooldown: 1 second per 1 use per user. Parameters: item : The name or alias of the item to craft. times : How many times this command is executed. Default to 1. Max is 100. daily Receive rewards everyday. Don't miss it though! Type: Prefix Command , Slash Command Cooldown: 1 day per 1 use per user (hard). Additional Info: The higher the daily streak, the better your reward will be. If you don't collect your daily within 48 hours since the last time you collect, your streak will be reset to 1. equip <equipment> Equip a tool. Get to work! Type: Prefix Command , Slash Command (recommended) Cooldown: 10 seconds per 1 use per user. Parameters: equipment : The equipment's name or alias to equip. equipments View your current equipments. Type: Prefix Command , Slash Command Cooldown: 10 seconds per 1 use per user. explore Explore the world and get resources by killing monsters. You'll need a sword equipped. Type: Prefix Command , Slash Command Cooldown: 300 seconds per 1 use per user. inventory [view_option = compact] View your inventory. Type: Prefix Command , Slash Command Cooldown: 10 seconds per 1 use per user. Aliases: inv Parameters: view_option : Options to view inventory. Valid options are full , compact , and value . Default to compact . market View public purchases. Type: Prefix Command , Slash Command market view View public purchases. Type: Prefix Command , Slash Command market buy <item> [amount = 1] Buy an item from the market. Type: Prefix Command , Slash Command Parameters: item : The item to purchase. amount : The amount to purchase. Default to 1. market sell <item> [amount = 1] Sell an item from your inventory. Type: Prefix Command , Slash Command Parameters: item : The item to sell. amount : The amount to sell, or 0 to sell all. Default to 1. mine Mine for resources. You'll need a pickaxe equipped. Type: Prefix Command , Slash Command Cooldown: 300 seconds per 1 use per user. trade View and/or perform a trade. Get your money ready. Type: Prefix Command , Slash Command Cooldown: 5 seconds per 1 use per user. Additional Info: Trades can contains purchases that can't be made via market . Trades will reset every 4 hours. This can only be used when you're in the Overworld. travel <world> Travel to another world. Type: Prefix Command , Slash Command Cooldown: 1 day per 1 use per user (hard). Parameters: world : The world to travel to. Valid options are overworld and nether . Last updated on Jul 25, 2022","title":"Economy"},{"location":"user/economy/#economy-category","text":"Economy Commands","title":"Economy Category"},{"location":"user/economy/#balance","text":"View your balance. Type: Prefix Command , Slash Command Aliases: bal","title":"balance"},{"location":"user/economy/#barter","text":"View and/or perform a barter. Get your gold ready. Type: Prefix Command , Slash Command Cooldown: 5 seconds per 1 use per user. Additional Info: Barters can contains purchases that can't be made via market . Barters will reset every 4 hours. This can only be used when you're in the Nether.","title":"barter"},{"location":"user/economy/#bet-number-money-1","text":"Bet your money to guess a number in the range 0-50. Don't worry, I won't cheat :) Type: Prefix Command , Slash Command Parameters: number : Your guessing number. Stay within 0-50! money : The amount to bet. You'll either lose this or get 2x back. At least 1.","title":"bet &lt;number&gt; [money = 1]"},{"location":"user/economy/#craft-item-times-1","text":"Craft various items. Type: Prefix Command , Slash Command (recommended) Cooldown: 1 second per 1 use per user. Parameters: item : The name or alias of the item to craft. times : How many times this command is executed. Default to 1. Max is 100.","title":"craft &lt;item&gt; [times = 1]"},{"location":"user/economy/#daily","text":"Receive rewards everyday. Don't miss it though! Type: Prefix Command , Slash Command Cooldown: 1 day per 1 use per user (hard). Additional Info: The higher the daily streak, the better your reward will be. If you don't collect your daily within 48 hours since the last time you collect, your streak will be reset to 1.","title":"daily"},{"location":"user/economy/#equip-equipment","text":"Equip a tool. Get to work! Type: Prefix Command , Slash Command (recommended) Cooldown: 10 seconds per 1 use per user. Parameters: equipment : The equipment's name or alias to equip.","title":"equip &lt;equipment&gt;"},{"location":"user/economy/#equipments","text":"View your current equipments. Type: Prefix Command , Slash Command Cooldown: 10 seconds per 1 use per user.","title":"equipments"},{"location":"user/economy/#explore","text":"Explore the world and get resources by killing monsters. You'll need a sword equipped. Type: Prefix Command , Slash Command Cooldown: 300 seconds per 1 use per user.","title":"explore"},{"location":"user/economy/#inventory-view_option-compact","text":"View your inventory. Type: Prefix Command , Slash Command Cooldown: 10 seconds per 1 use per user. Aliases: inv Parameters: view_option : Options to view inventory. Valid options are full , compact , and value . Default to compact .","title":"inventory [view_option = compact]"},{"location":"user/economy/#market","text":"View public purchases. Type: Prefix Command , Slash Command","title":"market"},{"location":"user/economy/#market-view","text":"View public purchases. Type: Prefix Command , Slash Command","title":"market view"},{"location":"user/economy/#market-buy-item-amount-1","text":"Buy an item from the market. Type: Prefix Command , Slash Command Parameters: item : The item to purchase. amount : The amount to purchase. Default to 1.","title":"market buy &lt;item&gt; [amount = 1]"},{"location":"user/economy/#market-sell-item-amount-1","text":"Sell an item from your inventory. Type: Prefix Command , Slash Command Parameters: item : The item to sell. amount : The amount to sell, or 0 to sell all. Default to 1.","title":"market sell &lt;item&gt; [amount = 1]"},{"location":"user/economy/#mine","text":"Mine for resources. You'll need a pickaxe equipped. Type: Prefix Command , Slash Command Cooldown: 300 seconds per 1 use per user.","title":"mine"},{"location":"user/economy/#trade","text":"View and/or perform a trade. Get your money ready. Type: Prefix Command , Slash Command Cooldown: 5 seconds per 1 use per user. Additional Info: Trades can contains purchases that can't be made via market . Trades will reset every 4 hours. This can only be used when you're in the Overworld.","title":"trade"},{"location":"user/economy/#travel-world","text":"Travel to another world. Type: Prefix Command , Slash Command Cooldown: 1 day per 1 use per user (hard). Parameters: world : The world to travel to. Valid options are overworld and nether . Last updated on Jul 25, 2022","title":"travel &lt;world&gt;"},{"location":"user/fun/","text":"Fun Category Fun Commands copypasta <type> My favorite copypasta. Type: Prefix Command Cooldown: 10 seconds after 1 use per user. Parameters: type : Which copypasta to show. Dig into the bot's code to see available options ;) dadjoke Give you a dad joke. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Aliases: ina-of-the-mountain-what-is-your-wisdom dice Roll a 6-face dice for you. Type: Prefix Command , Slash Command echo <content> Echo echo echo echo. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per user. Parameters: content : The string to echo. Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command. how <measure_unit> <*target> An ultimate measurement to measure everything. Type: Prefix Command , Slash Command (recommended) Parameters: measure_unit : The unit to measure. target : The target to measure. mock <*text> tuRn A teXT INtO MOCk teXt. Type: Prefix Command , Slash Command (recommended) Cooldown: 3 seconds after 1 use per user. Parameters: text : Text to mock. Additional Info: The text will be sent through DM if it exceeds 1500 characters. pekofy Pekofy a message peko. Type: Message Command Cooldown: 5 seconds after 1 use per user. speak <*content> Speak the message. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per user. Parameters: content : The string to speak. Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command. uwu <*text> Turn a text into uwu text. Type: Prefix Command , Slash Command , Message Command (recommended) Cooldown: 3 seconds after 1 use per user. Parameters: text : Text to uwuify. Last updated on Jul 25, 2022","title":"Fun"},{"location":"user/fun/#fun-category","text":"Fun Commands","title":"Fun Category"},{"location":"user/fun/#copypasta-type","text":"My favorite copypasta. Type: Prefix Command Cooldown: 10 seconds after 1 use per user. Parameters: type : Which copypasta to show. Dig into the bot's code to see available options ;)","title":"copypasta &lt;type&gt;"},{"location":"user/fun/#dadjoke","text":"Give you a dad joke. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Aliases: ina-of-the-mountain-what-is-your-wisdom","title":"dadjoke"},{"location":"user/fun/#dice","text":"Roll a 6-face dice for you. Type: Prefix Command , Slash Command","title":"dice"},{"location":"user/fun/#echo-content","text":"Echo echo echo echo. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per user. Parameters: content : The string to echo. Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command.","title":"echo &lt;content&gt;"},{"location":"user/fun/#how-measure_unit-target","text":"An ultimate measurement to measure everything. Type: Prefix Command , Slash Command (recommended) Parameters: measure_unit : The unit to measure. target : The target to measure.","title":"how &lt;measure_unit&gt; &lt;*target&gt;"},{"location":"user/fun/#mock-text","text":"tuRn A teXT INtO MOCk teXt. Type: Prefix Command , Slash Command (recommended) Cooldown: 3 seconds after 1 use per user. Parameters: text : Text to mock. Additional Info: The text will be sent through DM if it exceeds 1500 characters.","title":"mock &lt;*text&gt;"},{"location":"user/fun/#pekofy","text":"Pekofy a message peko. Type: Message Command Cooldown: 5 seconds after 1 use per user.","title":"pekofy"},{"location":"user/fun/#speak-content","text":"Speak the message. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per user. Parameters: content : The string to speak. Additional Info: Bot needs to have Manage Messages permission if used as a Prefix Command.","title":"speak &lt;*content&gt;"},{"location":"user/fun/#uwu-text","text":"Turn a text into uwu text. Type: Prefix Command , Slash Command , Message Command (recommended) Cooldown: 3 seconds after 1 use per user. Parameters: text : Text to uwuify. Last updated on Jul 25, 2022","title":"uwu &lt;*text&gt;"},{"location":"user/logger/","text":"Logs Category Logging commands. log-set Set a channel as a log channel. Type: Prefix Command Additional Info: This command doesn't do anything. Please use the subcommands. log-set all [channel = None] Set a channel to dump all the logs. This automatically enables logging system. Type: Prefix Command , Slash Command Parameters: channel : The Discord channel to dump all the logs. Default to current channel. Additional Info: Author needs to have Manage Server . log-set option <logging_option> Enable a logging option. Type: Prefix Command , Slash Command (recommended) Parameters: logging_option : Log type to turn on. Check log-view to see all options. Additional Info: Author needs to have Manage Server . It is recommended to use the Slash Command version of the command. log-disable Disable logging or part of the logging system. Type: Prefix Command Additional Info: This command doesn't do anything. Please use the subcommands. log-disable all Disable logging system. Type: Prefix Command , Slash Command log-disable option <logging_option> Disable a logging option. Type: Prefix Command , Slash Command (recommended) Parameters: logging_option : Log type to turn off. Check log-view to see all options. Additional Info: Author needs to have Manage Server . It is recommended to use the Slash Command version of the command. log-view View all log settings. Type: Prefix Command , Slash Command Additional Info: Author needs to have Manage Server . Last updated on Apr 1, 2022","title":"Logs"},{"location":"user/logger/#logs-category","text":"Logging commands.","title":"Logs Category"},{"location":"user/logger/#log-set","text":"Set a channel as a log channel. Type: Prefix Command Additional Info: This command doesn't do anything. Please use the subcommands.","title":"log-set"},{"location":"user/logger/#log-set-all-channel-none","text":"Set a channel to dump all the logs. This automatically enables logging system. Type: Prefix Command , Slash Command Parameters: channel : The Discord channel to dump all the logs. Default to current channel. Additional Info: Author needs to have Manage Server .","title":"log-set all [channel = None]"},{"location":"user/logger/#log-set-option-logging_option","text":"Enable a logging option. Type: Prefix Command , Slash Command (recommended) Parameters: logging_option : Log type to turn on. Check log-view to see all options. Additional Info: Author needs to have Manage Server . It is recommended to use the Slash Command version of the command.","title":"log-set option &lt;logging_option&gt;"},{"location":"user/logger/#log-disable","text":"Disable logging or part of the logging system. Type: Prefix Command Additional Info: This command doesn't do anything. Please use the subcommands.","title":"log-disable"},{"location":"user/logger/#log-disable-all","text":"Disable logging system. Type: Prefix Command , Slash Command","title":"log-disable all"},{"location":"user/logger/#log-disable-option-logging_option","text":"Disable a logging option. Type: Prefix Command , Slash Command (recommended) Parameters: logging_option : Log type to turn off. Check log-view to see all options. Additional Info: Author needs to have Manage Server . It is recommended to use the Slash Command version of the command.","title":"log-disable option &lt;logging_option&gt;"},{"location":"user/logger/#log-view","text":"View all log settings. Type: Prefix Command , Slash Command Additional Info: Author needs to have Manage Server . Last updated on Apr 1, 2022","title":"log-view"},{"location":"user/music/","text":"Music Category Music commands. join [voice_channel = None] Join a voice channel. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: voice_channel : The voice channel to join. Default to the VC you're in. Aliases: connect leave Leave the voice channel. Type: Prefix Command , Slash Command Aliases: dc (recommended), disconnect np Get info about the current track. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild. Aliases: now_playing play <*query> Play the query or add it to the queue. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 5 uses per guild. Parameters: query : The query to play (url, name, etc.) Aliases: p (recommended) pause Toggle pausing the player. Type: Prefix Command , Slash Command c search <*track> Search and return 10 relevant results. You can then copy the desired link into play . Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild. Parameters: track : Keywords to search. Example: blend w . seek <position> Jump to the provided timestamp. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild. Parameters: position : Timestamp to jump to. repeat Toggle repeating the track. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild. volume <vol> Set the volume of the player. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: vol : Volume to set (0-200). Additional Info: It's recommended to use the built-in feature User Volume instead of this command. queue Display the song queue. Type: Prefix Command Cooldown: 2 seconds after 1 use per guild. Aliases: q (recommended) queue view Display the song queue. This exists for Slash Commands. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild. queue clear Clear the entire queue but the current track. Type: Prefix Command , Slash Command queue shuffle Shuffle the queue. Type: Prefix Command , Slash Command queue loop Toggle queue loop. Type: Prefix Command , Slash Command queue move <from_index> <to_index> Move a track in queue to a new order index. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: from_index : The index in the queue to move. to_index : The index in the queue where you want the track to be. queue remove <index> Remove a track in the queue. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: index : The index in the queue to remove. skip Skip the current track. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild. Aliases: s (recommended) stop Stop the player. Type: Prefix Command , Slash Command Last updated on Apr 1, 2022","title":"Music"},{"location":"user/music/#music-category","text":"Music commands.","title":"Music Category"},{"location":"user/music/#join-voice_channel-none","text":"Join a voice channel. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: voice_channel : The voice channel to join. Default to the VC you're in. Aliases: connect","title":"join [voice_channel = None]"},{"location":"user/music/#leave","text":"Leave the voice channel. Type: Prefix Command , Slash Command Aliases: dc (recommended), disconnect","title":"leave"},{"location":"user/music/#np","text":"Get info about the current track. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild. Aliases: now_playing","title":"np"},{"location":"user/music/#play-query","text":"Play the query or add it to the queue. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 5 uses per guild. Parameters: query : The query to play (url, name, etc.) Aliases: p (recommended)","title":"play &lt;*query&gt;"},{"location":"user/music/#pause","text":"Toggle pausing the player. Type: Prefix Command , Slash Command c","title":"pause"},{"location":"user/music/#search-track","text":"Search and return 10 relevant results. You can then copy the desired link into play . Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild. Parameters: track : Keywords to search. Example: blend w .","title":"search &lt;*track&gt;"},{"location":"user/music/#seek-position","text":"Jump to the provided timestamp. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild. Parameters: position : Timestamp to jump to.","title":"seek &lt;position&gt;"},{"location":"user/music/#repeat","text":"Toggle repeating the track. Type: Prefix Command , Slash Command Cooldown: 1 second after 1 use per guild.","title":"repeat"},{"location":"user/music/#volume-vol","text":"Set the volume of the player. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: vol : Volume to set (0-200). Additional Info: It's recommended to use the built-in feature User Volume instead of this command.","title":"volume &lt;vol&gt;"},{"location":"user/music/#queue","text":"Display the song queue. Type: Prefix Command Cooldown: 2 seconds after 1 use per guild. Aliases: q (recommended)","title":"queue"},{"location":"user/music/#queue-view","text":"Display the song queue. This exists for Slash Commands. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild.","title":"queue view"},{"location":"user/music/#queue-clear","text":"Clear the entire queue but the current track. Type: Prefix Command , Slash Command","title":"queue clear"},{"location":"user/music/#queue-shuffle","text":"Shuffle the queue. Type: Prefix Command , Slash Command","title":"queue shuffle"},{"location":"user/music/#queue-loop","text":"Toggle queue loop. Type: Prefix Command , Slash Command","title":"queue loop"},{"location":"user/music/#queue-move-from_index-to_index","text":"Move a track in queue to a new order index. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: from_index : The index in the queue to move. to_index : The index in the queue where you want the track to be.","title":"queue move &lt;from_index&gt; &lt;to_index&gt;"},{"location":"user/music/#queue-remove-index","text":"Remove a track in the queue. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per guild. Parameters: index : The index in the queue to remove.","title":"queue remove &lt;index&gt;"},{"location":"user/music/#skip","text":"Skip the current track. Type: Prefix Command , Slash Command Cooldown: 2 seconds after 1 use per guild. Aliases: s (recommended)","title":"skip"},{"location":"user/music/#stop","text":"Stop the player. Type: Prefix Command , Slash Command Last updated on Apr 1, 2022","title":"stop"},{"location":"user/utilities/","text":"Utilities Category Utility Commands. base-convert <from_base> <to_base> <number> Convert a number to the desired base. Type: Prefix Command , Slash Command Parameters: from_base : The base the number you're converting. Valid options are 2 , 8 , 10 , and 16 . to_base : The base you want to convert to. Valid options are the same as from_base . number : The number you're converting. calc <expression> Calculate a math expression. Type: Prefix Command , Slash Command Parameters: expression : The math expression. Additional Info: Rounding errors, along with other debatable values such as 0^0 is incorrect due to language limitation. embed Send an embed. Additional Info: This command only works with subcommands. embed from-json <raw_embed> Send an embed from a JSON object. Check out https://embedbuilder.nadekobot.me/ for easier time. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: raw_embed : The embed in JSON format. embed to-json <message_id> [channel] Take the embed from a message and convert it to a JSON object. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: message_id : The message ID. The bot can't get a message that's too old. channel : The channel the message is in. Default to the current channel. Additional Info: This is useful when you want to change slightly from an existing embed. embed simple [title = None] [description = None] [color = green] [channel = None] Create and send a simple embed. Useful for quick embeds. Type: Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: title : The title of the embed. description : The description of the embed. color : Your choice of color. Default to green. channel : The channel to send this embed. Default to the current one. Additional Info: This is an alternative to embed interactive . Either title or description must be non-empty. embed interactive Create a simple embed with prompts. Type: Prefix Command Cooldown: 3 seconds after 1 use per user. Additional Info: Bot needs to have Manage Messages . This is an alternative to embed simple . embed interactive2 Create a simple embed with visual prompts. Type: Prefix Command Cooldown: 3 seconds after 1 use per user. Additional Info: Bot needs to have Manage Messages . This is an alternative to embed simple . profile [member = None] Information about yourself or another member. Type: Prefix Command , Slash Command Parameters: member : A Discord member. Default to you. remindme Create a reminder. Make sure your DM is open to the bot. Type: None Aliases: rmd , notify , timer Additional Info: This command only works with subcommands. remindme create <interval> <*message> Create a reminder. Make sure your DM is open to the bot. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: interval : How long until the bot reminds you. Must be between 1 minute and 30 days. Example: 3d2m1s message : The message the bot will send after the interval. Additional Info: An interval of less than 120 seconds is considered to be a \"short reminder\". remindme view View all your long reminders. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Additional Info: Due to optimization, this command won't display short reminders. remindme remove <remind_id> Remove a long reminder. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: remind_id : The reminder's id. You can find it in remindme view . Additional Info: Due to optimization, this command won't remove short reminders. urban <*term> Search a term on urbandictionary. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: term : The term to search. Example: rickroll . weather <*city_name> Display weather information for a location. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: city_name : The city to check. Example: Paris . Last updated on Jul 25, 2022","title":"Utilities"},{"location":"user/utilities/#utilities-category","text":"Utility Commands.","title":"Utilities Category"},{"location":"user/utilities/#base-convert-from_base-to_base-number","text":"Convert a number to the desired base. Type: Prefix Command , Slash Command Parameters: from_base : The base the number you're converting. Valid options are 2 , 8 , 10 , and 16 . to_base : The base you want to convert to. Valid options are the same as from_base . number : The number you're converting.","title":"base-convert &lt;from_base&gt; &lt;to_base&gt; &lt;number&gt;"},{"location":"user/utilities/#calc-expression","text":"Calculate a math expression. Type: Prefix Command , Slash Command Parameters: expression : The math expression. Additional Info: Rounding errors, along with other debatable values such as 0^0 is incorrect due to language limitation.","title":"calc &lt;expression&gt;"},{"location":"user/utilities/#embed","text":"Send an embed. Additional Info: This command only works with subcommands.","title":"embed"},{"location":"user/utilities/#embed-from-json-raw_embed","text":"Send an embed from a JSON object. Check out https://embedbuilder.nadekobot.me/ for easier time. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: raw_embed : The embed in JSON format.","title":"embed from-json &lt;raw_embed&gt;"},{"location":"user/utilities/#embed-to-json-message_id-channel","text":"Take the embed from a message and convert it to a JSON object. Type: Prefix Command , Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: message_id : The message ID. The bot can't get a message that's too old. channel : The channel the message is in. Default to the current channel. Additional Info: This is useful when you want to change slightly from an existing embed.","title":"embed to-json &lt;message_id&gt; [channel]"},{"location":"user/utilities/#embed-simple-title-none-description-none-color-green-channel-none","text":"Create and send a simple embed. Useful for quick embeds. Type: Slash Command Cooldown: 3 seconds after 1 use per user. Parameters: title : The title of the embed. description : The description of the embed. color : Your choice of color. Default to green. channel : The channel to send this embed. Default to the current one. Additional Info: This is an alternative to embed interactive . Either title or description must be non-empty.","title":"embed simple [title = None] [description = None] [color = green] [channel = None]"},{"location":"user/utilities/#embed-interactive","text":"Create a simple embed with prompts. Type: Prefix Command Cooldown: 3 seconds after 1 use per user. Additional Info: Bot needs to have Manage Messages . This is an alternative to embed simple .","title":"embed interactive"},{"location":"user/utilities/#embed-interactive2","text":"Create a simple embed with visual prompts. Type: Prefix Command Cooldown: 3 seconds after 1 use per user. Additional Info: Bot needs to have Manage Messages . This is an alternative to embed simple .","title":"embed interactive2"},{"location":"user/utilities/#profile-member-none","text":"Information about yourself or another member. Type: Prefix Command , Slash Command Parameters: member : A Discord member. Default to you.","title":"profile [member = None]"},{"location":"user/utilities/#remindme","text":"Create a reminder. Make sure your DM is open to the bot. Type: None Aliases: rmd , notify , timer Additional Info: This command only works with subcommands.","title":"remindme"},{"location":"user/utilities/#remindme-create-interval-message","text":"Create a reminder. Make sure your DM is open to the bot. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: interval : How long until the bot reminds you. Must be between 1 minute and 30 days. Example: 3d2m1s message : The message the bot will send after the interval. Additional Info: An interval of less than 120 seconds is considered to be a \"short reminder\".","title":"remindme create &lt;interval&gt; &lt;*message&gt;"},{"location":"user/utilities/#remindme-view","text":"View all your long reminders. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Additional Info: Due to optimization, this command won't display short reminders.","title":"remindme view"},{"location":"user/utilities/#remindme-remove-remind_id","text":"Remove a long reminder. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: remind_id : The reminder's id. You can find it in remindme view . Additional Info: Due to optimization, this command won't remove short reminders.","title":"remindme remove &lt;remind_id&gt;"},{"location":"user/utilities/#urban-term","text":"Search a term on urbandictionary. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: term : The term to search. Example: rickroll .","title":"urban &lt;*term&gt;"},{"location":"user/utilities/#weather-city_name","text":"Display weather information for a location. Type: Prefix Command , Slash Command Cooldown: 5 seconds after 1 use per user. Parameters: city_name : The city to check. Example: Paris . Last updated on Jul 25, 2022","title":"weather &lt;*city_name&gt;"}]}